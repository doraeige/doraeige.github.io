<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git管理 --- 常用Linux命令]]></title>
    <url>%2F2019%2F03%2F18%2Fgit%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[查看本机git公匙和私匙 打开终端，先进入 ssh 配置目录 cd ~/.ssh/ 查看文件目录 ls 查看公匙 cat id_rsa.pub 或者查看私匙 cat id_rsa 建立公司专有公匙私匙 ssh-keygen -t rsa -P "" 按提示输入公司名 再打开ssh 配置目录，可以看到配置成功 cd ~/.ssh/ 查看文件目录 ls 查看配置的公司公匙 cat xxxx.pub GitLab 来管理git 登录 GitLab，点击 Settings，左侧边栏 点击 SSH Keys 用户SSH密匙设置，把刚才创建的 公匙 粘贴到 KEY 一栏，Title 只是显示作用，默认就好，最后点 Add Key 公司的仓库地址 SSH ：格式是：协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID] 例如： ssh://git@git.9xxxxxx.com:22xxxx/frontend/xxxxxxxxx.git ssh 是协议，你可以类比为 http 或 https git@git.xxxxxxx.com 这个是服务器地址 22xxxx 是端口 回到终端 vim ~/.ssh/config 按 i (英文输入法) 编辑： # 公司名Host 服务器地址Port 端口User 用户名IdentityFile ~/.ssh/公司名 Host 就是服务器地址Port 就是端口User 就是你在Gitlab上的用户名IdentityFile 是认证文件，对应的是你的私钥 你电脑本地保存的是 私钥，服务器上保存的是公钥，这两个秘钥不相同，通过 RSA 算法不对称加密，来验证你是不是本人 编辑好，按 Esc 退出编辑模式，最后输入 :wq，保存并退出。 小结vim 是一个终端编辑器，可以看做是 VSCode，按 i 进入编辑模式，按 Esc 退出编辑模式，:w 是保存，:q 是退出， :wq 是保存并退出]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios 请求改造封装]]></title>
    <url>%2F2019%2F03%2F16%2Faxios-%E8%AF%B7%E6%B1%82%E6%94%B9%E9%80%A0%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[主要目标功能 快速请求，快速绑定 防止重复提交 模块梳理 接口模块 工具模块 请求模块 架构设计要点 利用 es6 的模块化规范，作为一个封装模块 直接无new 化构建对象 注入vue原型中，让后面的组件可以直接拿到 功能添加采用 原型式与静态结合 实现要点 保证可扩展性，可维护性 常用的方式设为默认加快速度 灵活控制目标data，请求回来直接自动绑定数据 代码演示 // src &gt; assets &gt; unit &gt; qs.jsimport axios from 'axios'export default(function()&#123; function qa()&#123; var _iqaob = new _iqa(); var _urlarr = arr || []; // 只在新建对象里执行一次循环 for (var i = 0,len = _urlarr.length; i&lt;len; i++)&#123; var _name = qa.getPathName(_urlarr[i]); (function(url)&#123; _iqaob[_name] = function () &#123; _iqaob.sendMes.call(_iqaob,url,ob); &#125; &#125;)(_urlarr[i]); &#125; // 无 new 化构造对象 // 返回一个对象 return _iqaob; &#125; function _iqa()&#123; // 内部代码 this._vueob = &#123;&#125;; this.statue = 0; // 状态码思想 &#125; // 请求模块 原型链注入 _iqa.prototype.sendMes = function (url, ob) &#123; var self = this; var _url = url || ""; var _ob = ob || &#123;&#125;; var _type = _ob.type || 'get'; // 百分之七八十的请求都是 get 请求 var _data = _ob.data || &#123;&#125;; // 请求参数 var _suecc = ob.suecc || function()&#123;&#125;; var _isblock = _ob.block || true; // 默认需要阻塞 // 状态 模式 var status = &#123; get: function()&#123; var _quary = qa.qs(_data); axios.get(_url+_quary).then(function(res)&#123; self.statue = 0; // 防止重复提交 var _result = _suecc.call(self._vueob, res); var _name = qa.getPathName(_urlarr[i]); // 用户是想数据处理之后加到 data 上面 if (_result) &#123; self._vueob[_name] = _result; &#125; else &#123; // 没有_result返回值，只是拿 data 做其他事情 self._vueob[_name] = res.data; &#125; &#125;); &#125;, post: function()&#123;&#125;, put: function()&#123;&#125;, delete: function()&#123;&#125; &#125; if(self.statue == 0 || _isblock)&#123; if (_isblock)&#123; self.statue = 1; &#125; status[_type](); &#125;else &#123;&#125; &#125; _iqa.prototype.v = function(vueob)&#123; this._vueob = vueob; return this; &#125; // 静态 // 拿到 文件名 './static/json1.json' 里的 json1 qa.getPathName = function (url) &#123; var _arr = url.split('/'); // ['.','static','json1.json'] var _name = _arr[_arr.length - 1]; // ['json1.json'] var _newname = _name.split('.')[0]; // ['json1'] return _newname; &#125; // get 请求参数 qs 然后拼接到 url qa.qs = function(ob)&#123; var _str = ""; if(JSON.stringify(ob) == '&#123;&#125;')&#123; &#125;else &#123; _str += "?"; var _len = 0; for (var item in ob) &#123; if(_len != 0)&#123; _str += "&amp;" &#125; _str += item; _str += "="; _str += ob[item]; _len ++ &#125; &#125; return _str; &#125; return qa;&#125;)(); static 下新建 json1.json、json2.json文件 模拟一个接口数据往 Vue 原型链中注入 qa 便于每个子组件都能拿到qa方法 // main.jsimport qa from './assets/unit/qa'Vue.prototype.qa = qa(['./static/json1.json', './static/json2.json']); // HelloWorld.vue&lt;template&gt; &lt;div&gt;&#123;&#123;json1&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import axios from 'axios' export default &#123; name: 'Helloworld', data()&#123; return &#123; json1: '' &#125; &#125;, mounted: function()&#123; this.qa.v(this).json1(&#123;data: &#123;a:1&#125;, suecc:function(res)&#123; console.log(res); &#125;&#125;) &#125; &#125;&lt;/script&gt; 小结设计思路： 功能确定 &gt; 模块梳理 &gt; 架构基础 &gt; 功能构建]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次面试]]></title>
    <url>%2F2019%2F03%2F14%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[面试2019.3.13 某网络科技有限公司 来源 前端团队 周工作时长 结果 BOSS直聘 2 10:00am-6:30pm 35h偶尔40h 过 未来上司面:聊聊上司的那点事： 小哥哥、温柔体贴、面试过程中端茶倒水、勤勤恳恳 问题由浅入深，耐心的给面试者解答，nice 盘他！ 面试中的主要瓶颈 其中某些题，没有办法较为顺畅的表达出来，说明可能掌握的还不够，或者理解的不太顺畅，需要回去总结下，捋捋思路 对底层原理的实现了解的不多 反问面试官的问题问面试官的问题 延展 前端面试题整理 InterviewMap面试图谱 浅拷贝与深拷贝 ES6核心特性]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试官问你"有什么问题问我吗?"，该如何回答？]]></title>
    <url>%2F2019%2F03%2F02%2F%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E4%BD%A0%E2%80%9C%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E9%97%AE%E6%88%91%E5%90%97%EF%BC%9F%E2%80%9D%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[面试官总会在面试结束时问我:”问了你这么多问题了，你有什么问题问我吗?”。 有哪些有价值的问题值得问?面对HR或者其他Level比较低的面试官时 能不能谈谈你作为一个公司老员工对公司的感受?(这个问题比较容易回答，不会让面试官陷入无话可说的尴尬境地。另外，从面试官的回答中你可以加深对这个公司的了解，让你更加清楚这个公司到底是不是你想的那样或者说你是否能适应这个公司的文化。除此之外，这样的问题在某种程度上还可以拉进你与面试官的距离) 能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你?有什么地方你觉得还不太好或者可以继续完善吗？（类似第一个问题，都是问面试官个人对于公司的看法） 我觉得我这次表现的不是太好，你有什么建议或者评价给我吗？(这个是我常问的。我觉得说自己表现不好只是这个语境需要这样来说，这样可以显的你比较谦虚好学上进) 如果我有幸被贵公司录取，有什么需要在入职前注意或学习的吗？（体现出你对工作比较上心，自助学习意识比较强） 这个岗位为什么还在招人？（岗位真实性和价值咨询） 大概什么时候能给我回复呢？（终面的时候，如果面试官没有说的话，可以问一下） 面对部门领导 部门的主要人员分配以及对应的主要工作能简单介绍一下吗？ 未来如果我要加入这个团队，你对我的期望是什么？（部门领导一般情况下是你的直属上级了，你以后和他打交道的机会应该是最多的。你问这个问题，会让他感觉你是一个对他的部门比较上心，比较有团体意识，并且愿意倾听的候选人。） 公司对新入职的员工的培养机制是什么样的呢？（正规的公司一般都有培养机制，提前问一下是对你自己的负责也会显的你比较上心） 以您来看，这个岗位未来在公司内部的发展如何？（在我看来，问这个问题也是对你自己的负责吧，谁不想发展前景更好的岗位呢？） 团队现在面临的最大挑战是什么？（这样的问题不会暴露你对公司的不了解，并且也能让你对未来工作的挑战或困难有一个提前的预期） 面对Level比较高的(比如总裁,老板) 贵公司的发展目标和方向是什么？（看下公司的发展是否满足自己的期望） 与同行业的竞争者相比，贵公司的核心竞争优势在什么地方？（充分了解自己的优势和劣势） 公司现在面临的最大挑战是什么？]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试-前端编程思路]]></title>
    <url>%2F2019%2F03%2F02%2F%E9%9D%A2%E8%AF%95-%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A8%8B%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[编写一个js函数，该函数有一个n（数字类型），其返回值是一个数组，该数组内是n个随机且不重复的整数，且整数取值范围是[2,32] 题目解读 输入一个数字类型的参数n，会返回一个包含2到32的数字的数组，数组长度是n(比如你输入数字是2，就会返回数组长度为2的数组); 数组里面的数字用 随机函数 生成，然后还要检查数字是否会重复，也要考虑负数情况等边界条件 知识点 Math.ceil(); //向上取整。Math.floor(); //向下取整。Math.round(); //四舍五入。Math.random(); //0.0 ~ 1.0 之间的一个伪随机数。【包含0不包含1) 比如0.8647578968666494 Math.ceil(Math.random()*10); // 获取从1到10的随机整数 ，取0的概率极小。Math.round(Math.random()); //可均衡获取0到1的随机整数。Math.floor(Math.random()*10); //可均衡获取0到9的随机整数。Math.round(Math.random()*10); //基本均衡获取0到10的随机整数，其中获取最小值0和最大值10的几率少一半。 直接使用 parseInt，parseFloat 或 Number 将一个非数字的值转化为数字时，表达式返回 NaN 'abc' - 3 // NaNparseInt('abc') // NaNparseFloat('abc') // NaNNumber('abc') // NaN isNaN() 是一个全局方法，它的作用是检查一个值是否能被 Number() 成功转换 。 如果能转换成功，就返回 false，否则返回 true isNaN(NaN) // true 不能转换isNaN('123') // false 能转换isNaN('abc') // true 不能转换isNaN('123ab') // true 不能转换isNaN('123.45abc') // true 不能转换 生成随机数方法总结 生成[1,max]的随机数，公式如下： // max - 期望的最大值parseInt(Math.random()*max,10)+1;Math.floor(Math.random()*max)+1;Math.ceil(Math.random()*max); 生成[0,max]到任意数的随机数，公式如下： // max - 期望的最大值parseInt(Math.random()*(max+1),10);Math.floor(Math.random()*(max+1)); 生成[min,max]的随机数，公式如下： // max - 期望的最大值// min - 期望的最小值parseInt(Math.random()*(max-min+1)+min,10);Math.floor(Math.random()*(max-min+1)+min); 编程思维： 可用 —&gt; 健壮 —&gt; 可靠 —&gt; 宽容 健壮： 最基本的兼容性处理、边界处理、异常处理、用户输入校验 对n的取值范围进行校验；对n是否为数字进行校验；对n是否存在进行校验 宽容： n是一个字符串数字，是否允许进入处理流程？是的话，经验系数*1.1 n是一个含有小数的数字，是否允许进入处理流程？是的话，经验系数*1.1 代码是否有足够多且清晰的注释？是的话，经验系数*1.2 调整[2，32]的范围，你的代码是否可以快速调整甚至不用调整？是的话，经验系数*1.2 伪代码// 生成一个随机数function getRand(min, max) &#123; return Math.floor(Math.random() * (max - min + 1) + min);&#125;// 去重校验// function checkArrIn(rand,array)&#123;// if(array.indexof(rand) &gt; -1)&#123;// return true;// &#125;// return false;// &#125;// 判断n是不是一个数字，包含字符串类型的数字function isNotNum(n)&#123; return isNaN(Number(n)) ? true : false&#125;// 判断n是不是在范围内function isRandOk(n, min, max)&#123; return n &gt;= min &amp;&amp; n &lt;= max ? true : false&#125;// 判断n是不是含有小数的数字function isXiaoShu(n)&#123; return String(n).indexOf(".") &gt; -1 ? true : false&#125;// 去重检验 arr.includes(e) includes 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。function fn(n)&#123; // 准备一个容器保存结果 let arr = []; // 将整数取值范围用变量保存起来 let min = 2; let max = 32; // 参数校验 if (isNotNum(n)) return []; if (!isRandOk(n,min,max)) return []; if (isXiaoShu(n)) return []; for(let i = 0; i &lt; n; i++)&#123; let rand = getRand(min, max); if (arr.includes(rand)) &#123; i--; // 减一是因为如果第i次循环的时候如果数组有了该值，就重新走一遍 &#125; else &#123; arr.push(rand); &#125; &#125; return arr&#125;fn(2); // (2) [15, 11] 随机fn('5'); // (5) [13, 2, 11, 27, 12] 随机fn('3.33'); // []fn(5.5); // [] 延伸程序员！为什么你的前端工作经验不值钱？]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>编程逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程调试]]></title>
    <url>%2F2018%2F10%2F02%2F%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[在真实设备上测试非常重要，所以你需要确保随时能进行测试 如何在 Chrome 中对 Android 进行远程调试 下载Chrome Canary版（它不会影响现有的Chrome安装） 在装有 Chrome 的 Android 上远程调试 什么是 Chrome Canary版 ，我为什么要使用它呢？ Chrome Canary版 是Chrome浏览器的开发版本。它的外观和行为与常规的Chrome浏览器类似，但它包含那些尚未公布的新的试验性功能。我们建议你使用最新的 Canary 来分析网站。然而，需要注意的一点是，Canary 不能保证稳定，因此可能会有崩溃和偶尔出错的情况。 用 iOS 网页调试代理 配合移动端的 Safari iOS WebKit 调试代理(英) Testing Mobile: Emulators, Simulators And Remote Debugging(英) 如何用 Chrome DevTools 调试 iOS Safari 想要使用云中的不同浏览器测试,尝试 BrowserStack]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>移动设备</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型继承:子类]]></title>
    <url>%2F2018%2F07%2F14%2F%E5%AD%90%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[子类 实现继承的好处之一就是它允许你重用现有代码。通过建立继承，我们可以子类化，也就是让一个“子”对象接受“父”对象的大部分或全部属性和方法，同时保留它自己独特的方法。 假设我们有一个父 Animal 对象（即构造函数），其中包含诸如 age 和 weight 等属性。同一个 Animal 对象还可以访问 eat 和 sleep 等方法。 现在，再假设我们要创建一个 Cat 子对象。与描述其他动物一样，你也可以通过 age 或 weight 来描述一只猫，而且你也可以确定猫会 eat 和 sleep。因此，在创建这个 Cat 对象的时候，我们可以简单地重写和重新实现 Animal 中的所有方法和属性——或者，我们也可以让 Cat 从 Animal 继承 这些现有的属性和方法，从而节省时间并防止重复代码！ 我们不仅可以让 Cat 接受 Animal 的属性和方法，还可以赋予 Cat 独特的属性和方法！也许一只 Cat 具有独特的 lives 属性为 9，或有一个专门的 meow() 方法，是其他 Animal 所没有的。使用原型继承，Cat 只需要实现 Cat 的独特功能，并重用 Animal 的现有功能即可。 通过原型继承 回想一下上一部分的原型链： 当在任何对象上调用任何属性时，JavaScript 引擎将首先在该对象中查找该属性（即该对象自己的、非继承的属性）。如果没有找到该属性，JavaScript 将查看该对象的原型。如果在对象原型中 仍然 找不到该属性，则 JavaScript 将在原型链上继续搜索。 JavaScript 中的继承重点就是建立原型链。 秘密链接 如你所知，在尝试搜索一个不存在于某个对象中的属性时，该对象的构造函数的原型是被首先搜索的。请考虑以下具有两个属性 claws 和 diet 的 bear 对象： const bear = &#123; claws: true, diet: 'carnivore'&#125;; 让我们将以下 PolarBear() 构造函数的 prototype 属性赋为 bear： function PolarBear() &#123; //...&#125;PolarBear.prototype = bear; 现在，让我们调用 PolarBear() 构造函数来创建一个新的对象，然后给它两个属性： const snowball = new PolarBear();snowball.color = 'white';snowball.favoriteDrink = 'cola'; snowball 对象目前看起来像这样： &#123; color: 'white', favoriteDrink: 'cola'&#125; 请注意，snowball 只有两个自己的属性：color 和 favoriteDrink。但是，snowball 也可以访问自身并不具有的属性：claws 和 diet： console.log(snowball.claws);//trueconsole.log(snowball.diet);//'carnivore' 由于 claw 和 diet 都作为 prototype 对象中的属性存在，因此它们会被查找，因为对象被秘密链接到其构造函数的 prototype 属性。 太棒了！但你可能会想：这个通向 prototype 对象的秘密链接到底是什么呢？当从 PolarBear() 构造函数构造对象之后（如 snowball），这些对象可以立即访问 PolarBear() 的原型中的属性。这究竟是怎么做到的呢？ 事实证明，这个秘密链接是 snowball 的 __proto__ 属性（注意每一端有两个下划线）。 __proto__ 是构造函数所创建的所有对象（即实例）的一个属性，并直接指向该构造函数的 prototype 对象。让我们来看看它是什么样的！ console.log(snowball.__proto__);//&#123; claws: true, diet: 'carnivore' &#125; 由于 __proto__ 属性所指向的对象与 PolarBear 的原型 bear 相同，因此将它们进行比较会返回 true： console.log(snowball.__proto__ === bear);//true 强烈建议不要重新分配 proto 属性，甚至不要在你编写的任何代码中使用它。 首先，会有跨浏览器的兼容性问题。更重要的是：由于 JavaScript 引擎会在原型链上搜索和访问属性，因此更改对象的原型可能会导致性能问题。有关 proto 的 MDN 文章甚至警告，不要在页面顶部的红色文本中使用此属性！ 我们有必要知道这个秘密链接，以了解函数和对象是如何相互关联的，但你不应该使用 __proto__ 来管理继承。如果你只是需要查看对象的原型，则仍然可以使用 Object.getPrototypeOf() 来达到目的。 如果只继承原型呢？ 假设我们希望一个 Child 对象从一个 Parent 对象继承。为什么不应该只设置 Child.prototype = Parent.prototype 呢？ 首先，还记得吗，对象是通过引用来传递的。这意味着，由于 Child.prototype 对象和 Parent.prototype 对象引用的是同一个对象，因此你对 Child 的原型所作的任何更改也会被应用于 Parent 的原型！我们可不希望子对象能够修改其父对象的属性！ 最重要的是，这样做不会创建原型链。如果我们想让一个对象从我们想要的任何对象进行继承，而不仅仅是它的原型呢？ 我们仍然需要一种方式来有效地管理继承，同时又完全不会改变原型。 小练习 请考虑以下代码: function GuineaPig (name) &#123; this.name = name; this.isCute = true;&#125;const waffle = new GuineaPig('Waffle'); waffle.__proto__指向什么？ 参考答案： GuineaPig.prototype 请考虑以下代码: function Car (color, year) &#123; this.color = color; this.year = year;&#125;Car.prototype.drive = function () &#123; console.log('Vroom vroom!');&#125;;const car = new Car('silver', 1988); 当 car.drive() 被调用时，会发生什么？ 参考答案： 顺序 事件 第一 JavaScript引擎在car对象内搜索名为drive的属性 第二 JavaScript引擎在car对象中找不到drive属性 第三 然后，JavaScript引擎会访问car.__proto__属性 第四 由于car.__proto__指向Car.prototype,因此JavaScript引擎会在该原型中搜索drive 第五 由于Car.prototype.drive是一个已定义的属性，因此它会被返回 第六 最后，由于drive作为一个方法在car上被调用，因此this的值会被设置为car Object.create() 到目前为止，我们在继承方面遇到了一些问题。首先，虽然 __proto__ 可以访问被调用的对象的原型，但是在你编写的代码中使用它并不是好习惯。 另一方面，我们也不应该_只_继承原型；这样做不会创建原型链，而且我们对子对象所作的任何更改也会反映在父对象中。 那么，我们应该如何继续往前呢？ 实际上，我们可以借助一种方式来自己设置对象的原型：使用 Object.create()。而且最棒的是，这种方式既可以让我们管理继承，同时又 不会 改变原型！ Object.create() 会接受一个对象作为参数，并返回一个新的对象，其 __proto__ 属性会被设置为传递给它的参数。然后，你只需要将所返回的对象设置为子对象构造函数的原型即可。让我们来看一个例子！ 首先，假设我们有一个 mammal 对象，它有两个属性：vertebrate 和 earBones： const mammal = &#123; vertebrate: true, earBones: 3&#125;; 还记得吗，Object.create() 会接受一个对象作为参数，并返回一个 新的 对象。这个新对象的 __proto__ 属性会被设置为最初传递给 Object.create() 的参数。让我们把这个返回值保存到变量 rabbit 中： const rabbit = Object.create(mammal); 我们预期这个新的 rabbit 对象是空白的，没有自己的属性： console.log(rabbit);//&#123;&#125; 但是，rabbit 现在应该已被秘密链接到 mammal。也就是说，它的 __proto__ 属性应该指向 mammal： console.log(rabbit.__proto__ === mammal);//true 太棒了！这意味着，现在 rabbit 扩展了 mammal（即 rabbit 继承自 mammal），而且 rabbit 可以将 mammal 的属性当作自己的属性一样进行访问！ console.log(rabbit.vertebrate);//trueconsole.log(rabbit.earBones);//3 Object.create() 给了我们一个在 JavaScript 中建立原型继承的简洁方法。我们可以通过这种方式轻松扩展原型链，而且可以让对象从我们想要的任何对象进行继承！ 下面让我们来看一个更复杂的例子： function Animal (name) &#123; this.name = name;&#125;Animal.prototype.walk = function () &#123; console.log(`$&#123;this.name&#125; walks!`);&#125;;function Cat (name) &#123; Animal.call(this, name); this.lives = 9;&#125; 这是一个 Animal 构造函数，以及一个在 Animal 的原型上直接定义的 walk 方法，此外，还有一个 Cat 构造函数，你可能注意到，我们在 Cat 构造函数中使用了 call 方法，并且直接在 Animal 构造函数 中调用它。 我们使用 call 而不是关键字 new ，因为我们不想构造一个全新的 animal 对象。我们只关心 cat 实例或 cat 对象上的 animal 初始化逻辑，call 方法的作用是调用 Animal 并将 this 设为 cat 实例，否则 this.name 将是 undefined。 现在，有了这个继承自 Animal 的 Cat: Cat.prototype = Object.create(Animal.prototype);// Animal&#123;&#125; 我们还需要更改构造函数, 否则所有的 cat 对象的构造函数将设为 animal： Cat.prototype.constructor = Cat;// f Cat(name)&#123;// Animal.call(this, name);// this.lives = 9; // &#125; 现在，我们向 cat 的原型添加一个 使所有 cat 对象都能共享的方法: Meow Cat.prototype.meow = function () &#123; console.log('Meow!');&#125;;// f () &#123;// console.log('Meow!');// &#125; 使用关键字 new 调用 cat 构造函数，并初始化新的 cat 对象 称之为 Bambi： const bambi = new Cat('Bambi');bambi.meow(); // Meow!bambi.walk(); // Bambi walks!bambi.name; // "Bambi" 总结下，为了在JavaScript 中有效地管理继承,一个很好的方式是避免完全更改原型 ，为此，我们可以使用 object.create 小练习 请考虑以下代码： function Parent() &#123; // ...&#125;function Child() &#123; // ...&#125;Child.prototype = Object.create(Parent.prototype);const child = new Child(); 当 child instanceof Parent; 被执行时，什么会被输出到控制台？ 参考答案： true 以下哪一项有关 Object.create() 的说法是正确的？请选择所有适用项： 它会返回一个新的对象，其 __proto__ 属性会被设置为传递给 Object.create() 的对象 使用 Object.create() ，我们可以让对象从我们想要的任何对象进行继承(即不仅是prototype) Object.create()让我们既可以实现原型继承，又不会改变原型 该方法直接在一个对象上被调用 参考答案： 1、2、3 小结 JavaScript 中的继承重点就是建立原型链。这让我们可以子类化，也就是创建一个“子”对象，让它继承“父”对象的大部分或全部属性和方法。然后，我们可以分别实现任何子对象的独特属性和方法，同时仍然保留其父对象的数据和功能。 对象（实例）通过该实例的 __proto__ 属性被秘密链接到其构造函数的原型对象。 你不应该在你编写的任何代码中使用 __proto__。在任何代码中使用 __proto__，或者只继承原型，将会直接导致某些不必要的问题。要在 JavaScript 中高效地管理继承，一个有效的方式就是避免完全改变原型。 Object.create() 可以帮助我们做到这一点，它可以接受一个父对象，返回一个 新的 对象，并将其 __proto__ 属性设置为该父对象。 延伸 MDN 上的继承和原型链 MDN 上的Object.create()]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型继承]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[原型、原型链 JavaScript 常被描述为一种基于原型的语言 (prototype-based language)。每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。 准确地说，这些属性和方法定义在 Object的构造器函数(constructor functions)之上的 prototype 属性上，而非对象实例本身。 继承 我的父母是黑色头发，我也是黑色的头发。可以看出，我从我父母那里遗传了黑头发基因。 在 JavaScript 中 继承是指一个对象基于另一个对象。 假设有一个新建的 car 对象的构造函数，每个 car 对象都具有不同的颜色属性值，例如 红色、蓝色和绿色；对象不仅具有自己的属性，而且与通用对象秘密关联，这种通用对象称之为原型；我们可以向原型中添加 car 对象都能共享的方法 drive方法 ，因此在每次新建一个 car 时，它们可以共享相同的 drive 方法，而不是创建新的 drive 方法。 和其他语言不同，JavaScript 利用原型来管理继承。 添加方法到原型 还记得吗，对象包含数据（即属性）和操纵数据的手段（即方法）。在此之前，我们都是将方法直接添加到构造函数本身： function Cat() &#123; this.lives = 9; this.sayName = function () &#123; console.log(`Meow! My name is $&#123;this.name&#125;`); &#125;;&#125; 这样，通过将一个函数保存到新创建的 Cat 对象的 sayName 属性中，可以将 sayName() 方法添加到所有 Cat 对象上。这样做没问题，但是如果我们想用这个构造函数实例化更多的 Cat 对象呢？你每一次都要为这个 Cat 对象的 sayName 创建一个新的函数！更重要的是：如果你想对方法进行更改，则必须逐个更新所有对象。在这种情况下，最好是让同一个 Cat 构造函数所创建的所有对象共享一个 sayName 方法。 为了节省内存并保持简洁，我们可以在构造函数的 prototype 属性中添加方法。原型只是一个对象，构造函数所创建的所有对象都会保持对原型的引用。这些对象甚至可以将 prototype 的属性当作自身属性来使用！ JavaScript 利用对象与其原型之间的这个秘密链接来实现继承。请考虑以下原型链： 还记得吗，每个函数都有一个 prototype 属性，它其实只是一个对象。当使用 new 运算符将该函数作为构造函数来调用时，它会创建并返回一个新的对象。该对象被秘密地链接到其构造函数的 prototype，而这个秘密链接让该对象可以访问 prototype 的属性和方法，就像它自己的一样！ 由于我们知道 prototype 属性仅仅指向一个普通对象，因此这个对象本身也有一个秘密链接指向它的原型。而且，这个原型对象也有引用指向它自己的原型，以此类推。原型链就是这样形成的。 无论你是访问属性（例如 bailey.lives）还是调用方法（即 bailey.meow()），JavaScript 解释器都会按照特定的顺序在原型链中查找它们： 首先，JavaScript 引擎将查看对象自身的属性。这意味着，直接在该对象中定义的任何属性和方法将优先于其他位置的任何同名属性和方法（类似于作用域链中的变量阴影）。 如果找不到目标属性，它将搜索对象的构造函数的原型，以寻找匹配。 如果原型中不存在该属性，则 JavaScript 引擎将沿着该链继续查找。 该链的最顶端是 Object() 对象，也就是顶级父对象。如果 仍然 找不到该属性，则该属性为未定义。 之前，我们都是直接在构造函数中定义方法。让我们来看看，如果我们转而在构造函数的 prototype 中定义方法，情况又会如何！ function Dog(age, weight, name) &#123; this.age = age; this.weight = weight; this.name = name; this.bark = function () &#123; console.log(`$&#123;this.name&#125; says woof!`); &#125;;&#125; 这是 Dog 构造函数，我们可以调用它来创建一个具有以下四种属性的对象：age, weight, name 和 bark， 可以在构造器中定义 bark 方法，我们也可以将 bark 方法移到 dog 的原型中，直接使用点记法来定义 bark，像这样: Dog.prototype.bark = function () &#123; console.log(`$&#123;this.name&#125; says woof!`);&#125;; 函数就变为: function Dog(age, weight, name) &#123; this.age = age; this.weight = weight; this.name = name;&#125;Dog.prototype.bark = function () &#123; console.log(`$&#123;this.name&#125; says woof!`);&#125;; 现在，我们将调用 dog 的构造函数来创建一个新的对象, 并调用这个新的 dog 的 bark方法: dog1 = new Dog(2, 60, 'Java');dog2 = new Dog(4, 55, 'Jodi');dog1.bark(); // Java says woof!dog2.bark(); // Jodi says woof! 让我们回顾一下，发生了什么？ 当我们在新建的 dog 对象中调用 bark 方法时，JavaScript 引擎会查看自己的属性，尝试找到与 bark 方法相匹配的名称，由于 bark 没有直接定义在这个 dog 上，它会看看 bark 方法的原型，最后，我们不需要调用 dog.prototype.bark()，我们只需要调用 dog.bark() 就会起作用，因为这个 dog 对象已经通过它的原型与 bark 方法联系起来了。 小练习 // (A)function Dalmatian (name) &#123; this.name = name; this.bark = function() &#123; console.log(`$&#123;this.name&#125; barks!`); &#125;;&#125;// (B)function Dalmatian (name) &#123; this.name = name;&#125;Dalmatian.prototype.bark = function() &#123; console.log(`$&#123;this.name&#125; barks!`);&#125;; 假设我们想定义一个可以在 Dalmatian 构造函数的实例（对象）上调用的方法（我们将会实例化至少 101 个对象！）。前面两种方式中的哪一种是最佳选择？ 参考答案： (B)是最佳选择，因为每次创建 Dalmatian 的实例时，将不需要重新创建 bark 所指向的函数。 替换 prototype 对象 如果完全替换某个函数的 prototype 对象，结果会怎样？这将如何影响该函数所创建的对象？让我们来看一个简单的 Hamster 构造函数，并实例化一些对象： function Hamster() &#123; this.hasFur = true; &#125;;let waffle = new Hamster(); let pancake = new Hamster(); 首先要注意的是，在创建新的对象 waffle 和 pancake 之后，我们仍然可以为 Hamster 的原型添加属性，而且它仍然可以访问这些新的属性。 Hamster.prototype.eat = function () &#123; console.log('Chomp chomp chomp!'); &#125;;waffle.eat(); // 'Chomp chomp chomp!'pancake.eat(); // 'Chomp chomp chomp!' 现在，让我们将 Hamster 的 prototype 对象完全替换为其他内容： Hamster.prototype = &#123; isHungry: false, color: 'brown'&#125;; 先前的对象无法访问更新后的原型的属性；它们只会保留与旧原型的秘密链接： console.log(waffle.color); // undefinedwaffle.eat(); // 'Chomp chomp chomp!'console.log(pancake.isHungry); // undefined 事实证明，此后创建的任何新的 Hamster 对象都会使用更新后的原型： const muffin = new Hamster();muffin.eat(); // TypeError: muffin.eat is not a functionconsole.log(muffin.isHungry); // falseconsole.log(muffin.color); // 'brown' 检查对象的属性 正如我们刚刚所看到的，如果一个对象本身没有某个特定属性，它可以访问原型链中某个这样的属性（当然，假设它是存在的）。由于选择很多，有时可能会不好判断某个特定的属性究竟来自哪里！这里有一些有用的方法可以帮助你进行判断。 hasOwnProperty() hasOwnProperty() 可以帮助你找到某个特定属性的来源。在向其传入你要查找的属性名称的字符串后，该方法会返回一个布尔值，指示该属性是否属于该对象本身（即该属性 不是 被继承的）。请考虑在函数中直接定义一个属性的 Phone 构造函数，以及它的 prototype 对象的另一个属性： function Phone() &#123; this.operatingSystem = 'Android';&#125;Phone.prototype.screenSize = 6; 现在，让我们创建一个新的对象 myPhone，并检查 operatingSystem 是否为其本身的属性，也就是说，它不是从该对象的原型（或原型链上的其他地方）继承来的： const myPhone = new Phone();const own = myPhone.hasOwnProperty('operatingSystem');console.log(own);//true 它确实返回为真！那么，Phone 对象的 prototype 上的 screenSize 属性又如何呢？ const inherited = myPhone.hasOwnProperty('screenSize');console.log(inherited);//false 使用 hasOwnProperty()，我们可以洞察某个属性的来源。 isPrototypeOf() 对象还可以访问 isPrototypeOf() 方法，该方法可以检查某个对象是否存在于另一个对象的原型链中。 使用这种方法，你可以确认某个特定的对象是否是另一个对象的原型。请看以下 rodent 对象： const rodent = &#123; favoriteFood: 'cheese', hasTail: true&#125;; 现在，让我们来构建一个 Mouse() 构造函数，并将它的 prototype 赋给 rodent： function Mouse() &#123; this.favoriteFood = 'cheese';&#125;Mouse.prototype = rodent; 如果我们创建一个新的 Mouse 对象，它的原型应该是 rodent 对象。让我们来确认一下： const ralph = new Mouse();const result = rodent.isPrototypeOf(ralph)console.log(result);//true 太棒了！isPrototypeOf() 是确认某个对象是否存在于另一个对象的原型链中的好办法。 Object.getPrototypeOf() isPrototypeOf() 很有用处，但要记住，要想使用它，你必须首先掌握原型对象！如果你不确定某个对象的原型是什么呢？Object.getPrototypeOf() 可以帮助你解决这个问题。 使用前面的例子，让我们将 Object.getPrototypeOf() 的返回值存储在变量 myPrototype 中，然后检查它是什么： const myPrototype = Object.getPrototypeOf(ralph);console.log(myPrototype);//&#123; favoriteFood: "cheese", hasTail: true &#125; 太棒了！ralph 的原型 rodent 对象 与 返回的结果 具有相同的属性，因为它们就是同一个对象。 Object.getPrototypeOf() 很适合检索给定对象的原型。 constructor 属性 每次创建一个对象时，都会有一个特殊的属性被暗中分配给它：constructor。 访问一个对象的 constructor 属性会返回一个对创建该对象的构造函数的引用！ 以下是一个简单的 Longboard 构造函数。我们还会继续创建一个新的对象，然后将其保存到一个 board 变量中： function Longboard() &#123; this.material = 'bamboo';&#125;const board = new Longboard(); 如果我们访问 board 的 constructor 属性，我们应该会看到原来的构造函数本身： console.log(board.constructor);// function Longboard() &#123;// this.material = 'bamboo';// &#125; 好极了！请记住，如果某个对象是使用字面量表示法创建的，那么它的构造函数就是内置的 Object() 构造函数！ const rodent = &#123; teeth: 'incisors', hasTail: true&#125;;console.log(rodent.constructor);//function Object() &#123; [native code] &#125; 小练习 以下哪一项有关 hasOwnProperty() 的说法是正确的？请选择所有适用项： 一个对象会作为参数传递给 hasOwnProperty 它会返回一个布尔值，指示对象是否具有所指定的属性作为其本身属性(即该属性不是被继承的) 一个字符串不能作为参数传递给 hasOwnProperty() hasOwnProperty() 作为一个方法被调用到一个对象 参考答案： 2、4 以下哪一项有关 isProtypeOf() 或 getPrototypeOf() 的说法是正确的？请选择所有适用项： isProtypeOf() 可以检查某个对象是否存在于另一个对象的原型链中 isProtypeOf() 会接受一个参数：一个原型链将被搜索的对象 getProtypeOf() 在构造函数的一个实例(即单个对象本身)上被调用 getProtypeOf() 会返回传递给它的对象的原型 参考答案： 2、4 以下哪一项有关 constructor 属性的说法是正确的？请选择所有适用项： 访问一个对象的 constructor 属性会返回一个对创建该对象(实例)的构造函数的引用 constructor 属性的值只是构造函数名称的一个字符串，而不是该函数本身 每个对象都有一个 constructor 属性 使用字面量表示法创建的对象是用 Object() 构造函数构建的 参考答案： 1、3、4 假设我们使用常规的对象字面量表示法来创建以下对象 capitals：当 Object.getPrototypeOf(capitals); 被执行时，会返回什么？ const capitals = &#123; California: 'Sacramento', Washington: 'Olympia', Oregon: 'Salem', Texas: 'Austin'&#125;; 参考答案： 对 Object() 原型的引用 小结 JavaScript 中的继承是指一个对象基于另一个对象。继承让我们可以重用现有的代码，使对象具有其他对象的属性。 当使用 new 运算符将一个函数作为构造函数来调用时，该函数会创建并返回一个新的对象。这个对象会被秘密链接到其构造函数的 prototype，而它只是另一个对象。使用这个秘密链接，可以让一个对象访问原型的属性和方法，就像是它自己的一样。如果 JavaScript 没有在某个对象中找到一个特定属性，它将在原型链上继续查找。如有必要，它会一路查找到 Object()（顶级父对象）。 对象如何查看对象的构造函数 –&gt; obj.constructor 属性 对象如何查看原型 –&gt; 隐式属性 __proto__ 修改原型 –&gt; obj.prototype.xxx = xxx (原型链的终端)绝大多数对象的最终原型: Object.prototype 为了更理解 原型 / 构造函数 / 实例 三者的关系，请看下面这张图： 实例.__proto__ === 原型构造函数.prototype === 原型原型.constructorr === 构造函数 此外，我们还介绍了几个方法和属性，可以用于检查对象及其原型的来源和引用，即： hasOwnProperty() isPrototypeOf() Object.getPrototypeOf() constructor 在下一部分，我们将从子类化的角度来探索原型继承的另一方面。如果你想从一个对象中只继承几个属性，但是又想让这个对象具有其他专有属性，该怎么办呢？我们将在下一部分对原型继承进行更深入的探讨。 延伸 MDN 上的hasOwnProperty() MDN 上的isPropertyOf() MDN 上的Object.getPrototypeOf() MDN 上的constructor]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置自己的this]]></title>
    <url>%2F2018%2F07%2F02%2F%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[我们知道 根据函数的调用方式 this 会设成不同的值，Javascript 提供了几种设置 this值的方法: call() apply() bind() call 和 apply 作为方法在函数上被调用，会因为参数的传入方式不同而有所不同，bind 是返回新函数的方法. call call() 是一个直接调用到函数上的方法。我们传递给它一个单一的值，以设置为 this 的值，然后逐个传入该函数的任何参数，用逗号分隔。 请考虑以下函数 multiply()，它只会返回其两个参数的乘积： function multiply(n1, n2) &#123; return n1 * n2;&#125; 让我们在控制台中调用它： multiply(3, 4); // 12 这里没有任何惊喜！但现在，让我们使用 call() 方法来调用同一个函数： multiply.call(window, 3, 4); // 12 我们得到了相同的结果！这是怎么发生的？我们首先直接调用 call() 方法到 multiply() 函数上。请注意，.call(window, 3, 4) 之前的 multiply 后​​面没有任何括号！ call() 将会处理该调用 和 multiply() 函数的参数本身！ 这一步完成后，我们传递将设置为 this 的值作为 call() 的第一个参数：window。最后，我们逐个传递 multiply() 函数的参数，并用逗号分隔。 当 multiply.call(window, 3, 4); 执行后，该函数将以 this 的给定值被调用，我们所看到的结果就是 12。在严格模式之外，调用 multiply() 的这两种方式是等价的。 除了调用常规函数之外，我们如何调用附加到对象上的函数（即方法）呢？这是 call() 真正发挥强大功能的地方。使用 call() 来调用方法允许我们从对象中“借用”方法，然后将其用于另一个对象！请看以下对象 mockingbird： const mockingbird = &#123; title: 'To Kill a Mockingbird', describe: function () &#123; console.log(`$&#123;this.title&#125; is a classic novel`); &#125;&#125;; 我们可以让 mockingbird 调用自己的 describe() 方法： mockingbird.describe();// 'To Kill a Mockingbird is a classic novel' 但是，借助 call()，以下 pride 对象可以使用 mockingbird 的 describe() 方法： const pride = &#123; title: 'Pride and Prejudice'&#125;;mockingbird.describe.call(pride);// 'Pride and Prejudice is a classic novel' 让我们来分析一下当 mockingbird.describe.call(pride); 被执行时，究竟发生了什么！首先，call() 方法被调用到 mockingbird.describe（它指向一个函数）上。然后，this 的值被传递给 call() 方法：pride。 由于 mockingbird 的 describe() 方法引用了 this.title，我们需要访问 this 所指向的对象的 title 属性。但是，由于我们已经设置了自己的 this 的值，this.title 的值将会从 pride 对象中被访问！结果，mockingbird.describe.call(pride); 被执行，我们在控制台中看到 &#39;Pride and Prejudice is a classic novel&#39;。 如果你打算在传递给它的第一个参数的作用域内调用一个函数，那么 call() 是非常有效的。同样，我们可以利用 apply() 方法达到相同的目的，尽管在参数传入的方式上有所不同。让我们来仔细看看！ apply 就像 call() 一样，apply() 在一个函数上被调用，不仅可以调用该函数，而且还可以为它关联一个特定的 this 值。但是，apply() 并不是逐个传递参数并用逗号分隔，而是将函数的参数放在一个_数组_中。请回想一下之前的 multiply() 函数： function multiply(n1, n2) &#123; return n1 * n2;&#125; 我们使用了 call()，并逐个传递参数： multiply.call(window, 3, 4);// 12 然而，使用 apply()，我们则是将 multiply() 函数的所有参数收集到一个数组中，然后再将这个数组传递给 apply()： 太棒了！那么，使用 apply() 来调用对象的方法，又会怎样呢？请回想一下之前的 mockingbird 和 pride 对象： const mockingbird = &#123; title: 'To Kill a Mockingbird', describe: function () &#123; console.log(`$&#123;this.title&#125; is a classic novel`); &#125;&#125;;const pride = &#123; title: 'Pride and Prejudice'&#125;; 之前，我们使用了 call() 来允许 pride 对象”借用” mockingbird 的 describe() 方法： mockingbird.describe.call(pride);// 'Pride and Prejudice is a classic novel' 我们可以使用 apply() 来达到相同的结果！ mockingbird.describe.apply(pride);// 'Pride and Prejudice is a classic novel' 请注意，传递给 call() 和 apply() 的第一个参数是相同的（即绑定 this 值的对象）。由于 describe() 方法不接受任何参数，因此 mockingbird.describe.call(pride); 和 mockingbird.describe.apply(pride); 唯一的区别就是方法！这两种方法都会产生相同的结果。 偏向选择其中一种方法 call() 和 apply() 都会在其传入的第一个参数（即作为 this 值的对象）的作用域内调用一个函数。那么，你什么时候会偏向于选择 call()，或偏向于选择 apply() 呢？ 如果你事先并不知道函数所需要的参数个数，那么 call() 的使用可能会受到限制。在这种情况下，apply() 是一个更好的选择，因为它只接受一个参数数组，然后将其解包并传递给函数。请记住，解包可能会略微影响性能，但这种影响并不显著。 小练习 请考虑以下 dave 对象和 sayHello() 函数： const dave = &#123; name: 'Dave'&#125;;function sayHello(message) &#123; console.log(`$&#123;message&#125;, $&#123;this.name&#125;. You're looking well today.`);&#125; 假设你想将消息 &#39;Hello, Dave. You&#39;re looking well today.&#39; 输出到控制台。你应该编写哪个表达式来达到这个目的？ 参考答案： sayHello.apply(dave, [‘Hello’]); 请考虑以下 Andrew 和 Richard 对象： const Andrew = &#123; name: 'Andrew', introduce: function () &#123; console.log(`Hi, my name is $&#123;this.name&#125;!`); &#125;&#125;;const Richard = &#123; name: 'Richard', introduce: function () &#123; console.log(`Hello there! I'm $&#123;this.name&#125;.`); &#125;&#125;; 当 Richard.introduce.call(Andrew); 被执行时，什么会被记录到控制台？ 参考答案： &#39;Hello there! I&#39;m Andrew.&#39; 请考虑以下代码： const andrew = &#123; name: 'Andrew'&#125;;function introduce(language) &#123; console.log(`I'm $&#123;this.name&#125; and my favorite programming language is $&#123;language&#125;.`);&#125; 请编写一个表达式，使用 call() 方法产生以下消息：&#39;I&#39;m Andrew and my favorite programming language is JavaScript.&#39; 参考答案： introduce.call(andrew,&#39;JavaScript&#39;) 回调和 this 当涉及到回调函数时，this 的值有一些潜在的作用域问题，事情会变得比较棘手。接下来，让我们来看看这个问题。 function invokeTwice(cb) &#123; cb(); cb();&#125;const dog = &#123; age: 5, growOneYear: function () &#123; this.age += 1; &#125;&#125;; 首先，调用 growOneYear() 按预期运作，将 dog 对象的 age 属性的值从 5 更新为 6： dog.growOneYear();// undefineddog.age; // 6 但是，将 dog.growOneYear（一个函数）作为参数传递给 invokeTwice() 则会产生不希望的结果： invokeTwice(dog.growOneYear);// undefineddog.age; // 6 这是什么原因呢？事实证明，invokeTwice() 确实会调用 growOneYear，但它是被调用为一个 函数而不是一个方法！让我们回顾一下先前的 this 网格： Call Style new method function this {} object itself global object Example new Cat() bailey.sayName() introduce() 如果使用 new 运算符来调用构造函数，this 的值将被设置为新创建的对象，如果在对象上调用方法，this 将被设置为该对象本身，如果简单地调用一个函数，this 将被设置为全局对象: window 使用匿名闭包来保存 this 还记得吗，简单地调用一个普通函数会将 this 的值设置为全局对象（即 window）。我们如何解决这个问题呢？ 解决这个问题的一种方式就是使用一个匿名闭包来遮蔽 dog 对象： invokeTwice(function () &#123; dog.growOneYear(); &#125;);dog.age// 7 使用这种方式，调用 invokeTwice() 仍然会将 this 的值设置为 window。但是，这对闭包没有影响；在匿名函数中，growOneYear() 方法仍然会被直接调用到 dog 对象上。因此，dog 的 age 属性的值会从 5 更新为 7。 由于这是一种十分常见的模式，因此 JavaScript 提供了另一种比较简洁的方式：bind() 方法。 使用 bind() 来保存 this 与 call() 和 apply() 类似，bind() 方法也允许用户直接为 this 定义一个值。bind() 也是一个在函数上调用的方法，但不同于 call() 或 apply()，它们都会立即调用函数——bind() 会返回一个新的函数。当被调用时，该函数会将 this 设置为我们赋给它的值。 const dog = &#123; age: 5, growOneYear: function () &#123; this.age += 1; &#125;&#125;function invokeTwice(cb) &#123; cb(); cb();&#125;invokeTwice(dog.growOneYear);// undefined 因为bind() 会返回一个新的函数，将其保存在新的变量中，称之为 myGrow const myGrow = dog.growOneYear.bind(dog);// undefinedinvokeTwice(myGrow);// undefineddog.age;// 7 小练习 请考虑以下 driver 和 car 对象： const driver = &#123; name: 'Danica', displayName: function () &#123; console.log(`Name: $&#123;this.name&#125;`); &#125;&#125;;const car = &#123; name: 'Fusion'&#125;; 请使用 bind() 编写一个表达式，让我们可以从 driver 中”借用” displayName() 方法，以供 car 对象使用。 参考答案： driver.displayName.bind(car) 小结 JavaScript 提供了三种方法，让我们可以为一个给定的函数设置 this 的值： call() 会调用该函数，逐个传入参数，并用逗号分隔。 apply() 与 call() 类似；它会照样调用该函数，但它会将参数作为一个数组传入。 bind() 会返回一个新的函数，并将 this 绑定到一个特定对象，让我们可以按照函数的样式来调用它。如需进一步研究，我们建议你查看 Kyle Simpson 有关 this 的你不了解 JS 系列，链接已在下方提供。 到目前为止，你已经看到函数、对象和 this 关键字是如何相互关联的。你也看到了 JavaScript 中的几乎所有东西都是一个对象！你知道吗，你甚至可以将对象建立在其他对象上！这是原型继承背后的主要思想。通过实现它，对象可以接受其他对象的属性。接下来，我们将探索这一切，以及更多知识！ 延伸 你不知道的JavaScript（上卷） 你不知道的JavaScript（中卷） 你不知道的 JavaScript（下卷） MDN 上的call() MDN 上的apply() MDN 上的bind()]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 的 this 用法]]></title>
    <url>%2F2018%2F06%2F28%2FJavascript-%E7%9A%84-this-%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[this 是 JavaScript 语言的一个关键字。 构造函数中的 this 在上一部分，我们使用了方法中的 this 来访问该方法所属的 对象。让我们再来看一个例子： function Cat(name) &#123; this.name = name this.lives = 9; this.sayName = function () &#123; console.log( 'Meow! My name is ' + this.name); &#125;;&#125;const bailey = new Cat(); 在上面的 Cat() 构造函数中，sayName 所指向的函数引用了 this.name。之前，我们已经看到过在方法中使用 this，但在这里，this 是指什么呢？ 事实证明，当使用 new 运算符来调用构造函数时，this 会被设置为新创建的对象！让我们来看看新的 bailey 对象是什么样的： &#123; name: Bailey, sayName: function () &#123; console.log('Meow! My name is ' + this.name); &#125;&#125; 在以上代码段中，请注意 this 位于构造函数 外部。正如我们在上一篇文章中所看到的，当你说 this 时，你其实是在说“这个对象”或“当前对象”。因此，sayName() 方法可以使用 this 来访问该对象的 name 属性！这使得以下方法调用成为可能： bailey.sayName();// Meow! My name is Bailey this 什么时候会被赋值？ 一个常见的误解是，this 指向定义它的对象。事实并非如此！直到某个对象调用使用 this 的方法，this 才会被赋值。换句话说，赋给 this 的值取决于 调用定义 this 的方法的对象。让我们来看一个例子： const dog = &#123; bark: function () &#123; console.log('Woof!'); &#125;, barkTwice: function () &#123; this.bark(); this.bark(); &#125;&#125;; 让我们继续调用 dog 的两个方法： dog.bark();// Woof!dog.barkTwice();// Woof!// Woof! 我们知道，当我们调用 dog.bark() 或 dog.barkTwice() 时，变量 this 将被设置。由于 this 可以访问调用它的对象，因此 barkTwice 可以使用 this 来访问包含 bark 方法的 dog 对象。但是，如果我们在 barkTwice 中使用 bark()，而不是 this.bark()，将会怎样？该函数会先在 barkTwice 的作用域内查找一个名为 bark 的局部变量。如果没有找到 bark，则会沿着作用域链继续查找。综合来看：this.bark() 会告诉 barkTwice 查看 dog（调用该方法的对象）以查找 bark。 this 会被设置为什么？ 到目前为止，我们已经在许多不同的上下文中看到了 this，比如在方法中，或被构造函数引用。现在，让我们把它们放在一起来看一下！有四种方式可以调用函数，而每种方式都会不同地设置 this。 首先，使用 new 关键字来调用构造函数会将 this 设置为一个新创建的对象。还记得吗，在我们之前创建 Cat() 的实例时，this 被设置为新的 bailey 对象。 另一方面，调用属于一个对象的函数（即_方法_）会将 this 设置为该对象本身。回想一下前面的示例，dog 对象的 barkTwice 方法能够访问 dog 本身的属性。 第三，单独调用一个函数（即简单地调用一个常规函数）将把 this 设置为 window。如果主机环境是浏览器，则它将是全局对象。 function funFunction() &#123; return this;&#125;funFunction();// (返回全局对象, `window`) 第四种调用函数的方式可以让我们自己设置 this！现在不用在意这一点，我们将在下一部分进行深入探讨。 Call Style new method function this {} object itself global object Example new Cat() bailey.sayName() introduce() 如果使用 new 运算符来调用构造函数，this 的值将被设置为新创建的对象，如果在对象上调用方法，this 将被设置为该对象本身，如果简单地调用一个函数，this 将被设置为全局对象: window 小练习 请考虑以下构造函数 City： function City(name, population) &#123; this.name = name; this.population = population; this.identify = function () &#123; console.log(`$&#123;this.name&#125;'s population is $&#123;this.population&#125;.`); &#125;;&#125; 当 const sanFrancisco = new City(&#39;San Francisco&#39;, 870000); 被执行时，this 的值是什么？ 答案： 新创建的对象，被 sanFrancisco 引用 请考虑以下对象 building： const building = &#123; floors: 5, addFloor: function () &#123; this.floors += 1; &#125; &#125;;building.addFloor(); 当 building.addFloor() 被执行时，this 的值是什么？ 答案： building 当以下函数被调用时，this 的值是多少？ function myFunction() &#123; console.log("What is the value of 'this'?");&#125; 答案： window 小结 函数、对象和 this 彼此相互关联。当使用 new 运算符来调用构造函数时，this 变量会被设置为新创建的对象。当在对象上调用方法时，this 会被设置为该对象本身。当在浏览器环境中调用函数时，this 会被设置为 window，也被称为全局对象。 除此之外，还有一组方式可以调用函数：使用 apply() 和使用 call()。这两种方式有许多相似之处，每一种方式都允许我们指定如何设置 this。接下来，我们会对它们进行详细分析！]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数]]></title>
    <url>%2F2018%2F06%2F20%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[创建对象的一个重要方式是使用构造函数，构造函数以大写字母开头，构造函数必须始终使用特殊关键字 new 来调用，与普通函数的区别是：普通函数必须创建将返回的对象并直接修改该对象，而构造函数会自动创建对象，然后，为了向此对象中添加属性或方法，需要使用特殊的关键字 this。 要实例化（即 创建 ）一个新的对象，我们可以使用 new 运算符来调用这个函数：new SoftwareDeveloper(); 构造函数：结构和语法 function SoftwareDeveloper() &#123; this.favoriteLanguage = 'JavaScript';&#125; 首先，构造函数并不声明局部变量，而是使用 this 关键字来保存数据。以上函数将为所创建的任何对象添加一个 favoriteLanguage 属性，并为其分配一个默认值 ‘JavaScript’。现在不用太在意构造函数中的 this；只要知道 this 是指在构造函数前面使用 new 关键字创建的新对象即可。我们很快就会详细介绍这个 this！最后一点比较特别的是，这个函数似乎不会返回任何东西！JavaScript 中的构造函数不应该有一个显式的返回值（即使用 return 语句）。 创建一个新的对象 正如我们在上面看到的，让我们使用 new 运算符来创建一个新的对象： let developer = new SoftwareDeveloper(); 我们已经把这个调用的返回值保存到了变量 developer 中。让我们执行 console.log(developer); 将这个 SoftwareDeveloper 对象记录到控制台： console.log(developer); // SoftwareDeveloper &#123;favoriteLanguage: "JavaScript"&#125; 用对象字面量的方式来创建对象，看看有何不同 let orderDeveloper = &#123; favoriteLanguage: 'JavaScript' &#125;;otherDeveloper; // &#123; favoriteLanguage: "JavaScript" &#125; 可以看出 与 developer 相比，创建对象的构造函数 SoftwareDeveloper 没有列在Chrome 开发者工具中；在 Chrome 开发者工具中 构造函数通常显示在 {} 前面；developer 的构造函数是 SoftwareDeveloper，而 orderDeveloper 的构造函数是 object 构造函数；比较之下，两者原型将有所不同。 构造函数可以有参数 与常规函数一样，使用构造函数的一个好处是它们也可以接受参数。让我们更新以上构造函数来接受一个参数，并为其分配 name 属性： function SoftwareDeveloper(name) &#123; this.favoriteLanguage = 'JavaScript'; this.name = name;&#125; 在更新的 SoftwareDeveloper() 函数中，无论传入函数的值是什么，它都将是对象的 name 属性的值。让我们来看看： let instructor = new SoftwareDeveloper('Andrew');console.log(instructor);// SoftwareDeveloper &#123; favoriteLanguage: 'JavaScript', name: 'Andrew' &#125; 正如我们在上面看到的，我们可以使用相同的构造函数来创建不同的对象： let teacher = new SoftwareDeveloper('Richard');console.log(teacher);// SoftwareDeveloper &#123; favoriteLanguage: 'JavaScript', name: 'Richard' &#125; 构造函数的好处是，我们可以调用相同的构造函数，创建无数个实例或对象。 省略 new 运算符 如果你无意中 没有 使用 new 运算符来调用构造函数，会发生什么？ function SoftwareDeveloper(name) &#123; this.favoriteLanguage = 'JavaScript'; this.name = name;&#125;let coder = SoftwareDeveloper('David');console.log(coder);// undefined 这是怎么回事？如果不使用 new 运算符，则不会创建对象。该函数会像任何其他常规函数一样被调用。由于该函数不会 _返回_ 任何东西（除了所有函数都会默认返回的 undefined 之外），因此 coder 变量最终会被分配给 undefined。 还有一点需要注意：由于这个函数作为一个常规函数被调用，因此 this 的值也会截然不同。现在不用太在意这一点，我们将在下一部分深入探讨 this 关键字！ 查看对象的构造函数(instanceof) 如果我们想查看某个对象是否是用构造函数创建的呢？我们可以使用 instanceof（它会返回一个布尔值）来窥见一些端倪。让我们来看看吧！ function Developer(name)&#123; this.name = name;&#125;const dev = new Developer('Veronkia');typeof dev; // "object"dev instanceof Developer; // true instanceof 和原型链 在以上示例中，instanceof 确认一个特定的构造函数确实创建了一个特定的对象。我们知道这一点，是因为我们在调用 Developer() 构造函数之后直接实例化了 dev 对象。 然而，很多时候并没有这么简单：instanceof 运算符实际上会测试构造函数是否出现在某个对象的原型链中。这意味着，虽然我们不是总能检查到底是 哪个构造函数 创建了该对象，但是它使我们能够洞察某个对象可能访问哪些其他的属性和方法。 小结 JavaScript 的类系统是直接使用函数和对象来构建的。使用 new 运算符来调用构造函数可以实例化一个新的对象。相同的构造函数可以用于创建不同的对象。 我们在整篇中广泛讨论了函数、对象和 this。事实证明，这三者是密切相关的！ 我们将在下一部分深入探讨 this 关键字，并仔细分析这三者之间的关系。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Constructor</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式设计(五)]]></title>
    <url>%2F2018%2F05%2F08%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[响应式图片 图片平均消耗 60% 以上的字节数来打开网页，但“网络中”大多数字节数用于视频。 在这章中，你将用到 Google Chrome 和 Chrome开发者工具。 你可以用 Chrome开发者工具 快速得知你的网页在各种设备上的表现。当然，设备模拟器并不能真正代替在实际设备上的体验。为了在手机或平板设备上进行测试，你需要确保已经配置好了远程调试所需的环境。 比特和像素 Total bits = pixels x bits per pixel 照片等图片文件的大小，取决于 像素数 乘以 存储每个像素所需比特的数量。因此，为了提高网站性能，你要使用 尽可能小的图片尺寸 以及 尽可能高的图片压缩率。 保存图片时的第一条原则是 用尽可能最低的质量和尽可能小的尺寸。不过，你该如何在保持图片质量的同时减少文件大小呢。 请求和盈利 更重要的是 平均每个网页发出 56个 请求以加载图片；每次请求对页面加载都是一项成本。 谷歌，亚马逊和其他公司的研究表明，即使是一个非常小的页面加载延误都可能造成明显的流量和经济损失。 相对大小 将图片的 max-width 设置为 100%，图片会很好的扩大，不过最大也只能放大到它的自然宽度。 如果想要两张图片（假设图片宽426px）并列对齐，无论视图区域的尺寸如何，该怎么做？简单，调整相对尺寸为50%的宽度。如果想要在两个图片之间加一个 10px 的边距，可以使用 margin-right: 10px; 也可以使用 calc，这是一个结合绝对值和相对值的好办法。比如，将百分比宽度与一个固定的边距组合 img &#123; margin-right: 10px; max-width: 426px; width: calc((100% - 10px) / 2);&#125; 横向和纵向 对于响应式设计来说，一个黄金法则就是 不要假设视图区域的尺寸一致保持相同。 学习对于不同屏幕方向，如何使用 media queries 鲜为人知的CSS单位 你想要一张图片响应式铺满视图区域的整个高度吗？随意拿一张图片（宽512px,高384px；屏幕尺寸：800px x 612px）来测试一下。 你可能经常设置图片高度为 100%，不过这个只在 HTML 的高度下起作用。而且 body 元素得高度也同样被设置为 100%。 一个简单方法是使用 VH 单位，是视图高度的缩写。一个VH 单位对应着 1% 的视图高度。因而，100VH 对应着 100% 的高度。 img &#123; height: 100vh;&#125; 屏幕上测试图片比例为：816px x 612px 你可以同样使用 VW 视图宽度，你可以设置图片的宽度为 100VW ，等于 100% 的视图宽度。都是最大的。 img &#123; width: 100vw;&#125; 屏幕上测试图片比例为：800px x 600px 另一个常见的响应式用例是 当你想要调整图片尺寸去适应视图区域较小的高度或宽度，可以使用 vmin单位，对应着 1% 的宽度或高度，使得视图区域最小化。 img &#123; width: 100vmin; height: 100vmin;&#125; 屏幕上测试图片比例为：612px x 612px 如果你想要一张图片铺满整个视图区域而不需要拉伸或收缩图片的话，可以使用 vmax单位，对应着 1% 的视图区域宽度或高度，都是最大的。 img &#123; width: 100vmax; height: 100vmax;&#125; 屏幕上测试图片比例为：800px x 800px 是否注意到，将 height 和 width 设置为 100vmax 或 100vmin 会如何改变图片的宽高比？它会将你的图片压缩成正方形，所以，如果你想要保留其宽高比，请小心！ 光栅图(Raster)和矢量图(Vector) 有两种不同的基础方式去创建和存储图片，以及这会影响你如何响应式地部署图片：光栅图(Raster)和矢量图(Vector)。 光栅图 就是照片以及其他类型的图片以及单独颜色点所组成的网格。可能来源于照相机、扫描仪或者由HTML画布元素创建。 矢量图 就是比如商标和线条艺术的图片，可以由一组曲线、直线、形状、填充颜色和渐变所定义的。可以由 Adobe Illustrator 等类型的程序创建 Inkscape 或者 由 SVG一类的矢量格式。SVG 使得响应式矢量图像运用在网页中成为可能。 矢量文档格式优于光栅文档格式是浏览器可以渲染各种尺寸的矢量图片。毕竟，矢量图片格式描述了图片的几何形状，是由线条、曲线、颜色等组成，而非单独颜色点组成。矢量图片的缩放不会降低图片质量。 有一个很好的基本原则提高跨平台的图片性能，就是为相片使用JPEG格式，以及例如 Chrome 的浏览器也同样支持其他格式。例如 WebP 是一种可以提供更好的压缩比例和特性的图像格式，支持 alpha 有损动画处理以及无损压缩。 你可以为矢量图使用 SVG。对于 矢量图和纯色图，例如商标以及线条艺术，如果你不能使用 SVG 格式就使用 PNG 格式。优先选择 PNG 而不是 GIF 格式是因为前者有更多颜色，更好的压缩率以及没有版权问题。 压缩、优化和自动化图像通常占据了网页上下载字节的大部分，通常也占据了大量的视觉空间。 因此，优化图像通常可以最大限度地减少从网站下载的字节数以及提高网站性能：浏览器需要下载的字节越少，占用客户端的带宽就越少，浏览器下载并在屏幕上渲染有用内容的速度就越快。 一个最著名的批量图片处理软件叫 ImageMagick，光栅图和矢量图都可以处理。它是一款免费的开源软件，它将你在平时基于GUI界面的图片处理软件中的操作自动化执行，比如转换图片格式、裁剪或者应用滤镜。对于响应式图片，这意味着 可以自动生成同一幅图片的多种版本，不同尺寸或格式。 Mac 上的一个简单的 ImageMagick 安装包 Graphicsmagick(ImageMagick 的一个分叉) 你可以将图片自动优化工具融合进你的工作流： Grunt 简介 Grunt 使用入门 用 Grunt 生成不同分辨率的图片 用于生成多张图片的 grunt-responsive-images 插件 用于响应式图片工作流的 grunt-respimg 插件 图片处理工具： ImageOptim(Mac) Trimage 和 ImageOptim 类似 (Windows, Mac, Linux) ImageAlpha File Optimizer(Windows, Linux) 我们怎样才能检查网页上的所有图片都被优化了呢？ 现在这有一个很棒的检查图片的工具是 PageSpeed Insights。我们可以在开发者工具中使用它。 Grunt PageSpeed 插件 PageSpeed Insights Node module cURL 示例 性能 现实中，移动网络的实际情况是 文件请求次数和请求文件的大小同样重要。也就是说，你需要减少请求图片的次数，而不仅仅是图片文件的大小。 性能是真正响应式设计的基本组成部分。在实践中，这意味着你需要减小文件大小的同时，还要减少请求文件的次数。一种减少图片数据的好办法是压缩图片或者减少图片的数量。 要减少图片下载次数，你也可以使用 CSS 图片精灵 或 响应式精灵 。精灵页 图片组合了大量图片，这些图片可以通过将精灵页设置为元素背景，然后通过 CSS 调整背景位置来单独显示。此技巧对图标和其他重复图形尤为有用。 无论你采用何种技巧来避免延迟，都请注意 HTTP/2 带来的变化。 简单地说，HTTP/2 表示请求多个文件的成本更小：准备停止使用脚本编写、连接和其他 HTTP/1 技巧！ CSS 背景图片技巧 图片的尺寸会尽可能的小，但仍然会覆盖整个包含块：background-size: cover; cover 属性确保包含块被完全填充，意味着某一个边的边长过长。 图片的尺寸会尽可能大，并保持在包含块中是完整可见的：background-size: contain; contain 属性时，图片会完全被显示出来，意味着某一边长可能会小于包含块的边长 符号字符 避免使用图片并保持网站的响应性，如果需要图形标志，例如箭头、星星或者桃心，可以看看有无这样的字符。 Unicode 字符集Unicode 符号集合 Unicode 字符真的非常厉害。它包含 110,000 个字符。使用 Unicode 字符时，你需要确保 在 meta 标签中将 charset 属性值设为 utf-8。 &lt;meta http-equiv="Content-Type" content="text/html;charset=utf-8"&gt; 更多关于 meta tag charsets 的信息 这是一个 unicode 符号的列表 查看 unicode 字符时遇到问题？很遗憾，并非所有浏览器默认情况下都能查看所有 unicode 字符所需的字体。此站点将帮助你确定你的浏览器可以呈现的字符。请参阅此处的一些建议，了解如何在 Windows 上通过 Chrome 启用 unicode。 图标字体 图标字体相比于图片有很多优点。它们是矢量的图形，可以被无限的缩放，并且整套图像可以以一种字体被下载，这使得它成为一种非常有潜力的响应式设计解决方案。它只需要最小的下载量而能达到最大的可伸缩性。 Zocial Font Awesome We Love Icon Fonts! Icon fonts on CSS-Tricks &lt;link rel="stylesheet" href="http://weloveiconfonts.com/api/?family=zocial" /&gt;&lt;a href="#" class="zocial-facebook"&gt;Facebook&lt;/a&gt;&lt;a href="#" class="zocial-twitter"&gt;Twitter&lt;/a&gt;&lt;a href="#" class="zocial-googleplus"&gt;Google+&lt;/a&gt;&lt;a href="#" class="zocial-digg"&gt;Digg&lt;/a&gt; [class*="zocial-"]:before &#123; color: black; display: inline-block; font-family: 'zocial', sans-serif; text-shadow: 3px 3px 3px #aaa; width: 2em;&#125; SVG 和数据 URI 内嵌图片 说到文本，如果你真的想要减少网页的文件请求数量，那你可以利用代码实现内嵌图片。有两种方式可以做到，就是 SVG 或者 DataURIs。 内嵌 SVG 具有非常好的手机和电脑浏览器支持，并且优化工具可以极大的减少 SVG 的字节。 DataURIs 提供了一种将文件 例如图片 内嵌为一个 base64 编码的字符串，使用格式如下： &lt;img src="data:image/svg+xml;base64,[data]"&gt; 和 SVG一样 DataURIs也有很好的手机和电脑浏览器支持。 但是 DataURIs 和 SVG 还可以内嵌在 CSS 里，手机和电脑都支持。 一些不同的技巧，用来处理网页的图片 利用 外部文件 然后把它们链接到你的 HTML &lt;img src=&quot;file.png&quot;&gt; 或者可以使用 内嵌图片 将你需要的所有图片数据都放在你的网页中 &lt;img src=&quot;data:image/png;base64.....&quot;&gt; 可以利用 光栅图片 可以用 矢量图片 将图片打包然后用类似 font awesome 的 图标字体 &lt;i class=&quot;fa fa-adjust&quot;&gt;&lt;/i&gt; 然后利用css技术为它们添加效果 小练习 当你在 开发一个手机应用来展示随时会变化的商品，你需要一张 星星图片 放在右上角，你希望这个图片能够在应用中自由缩放以分别适应手机及电脑客户端的显示，所以，你应该选择 矢量图片 还是 光栅图片？ 是 内嵌图标 还是 外部文件链接？ 答案： 矢量图片 内嵌图标 或者 外部文件链接 都可以。站在 内嵌图标 的角度，星星是一个非常简单的图形，很容易创建出它的 SVG 文件，并且内嵌它们并不会增加太多字节；如果需要重复利用这张图片，链接外部文件也有道理，这意味着可以缓存图片，当用户每查看新一个网页时也不用再次加载它。 开发一个可以自行发布图片日记的手机网站，也就是说图片都是单次利用的。用户会创建一些独有的网页来发布单张图片并佐以说明文字，你应该把它们转化为 矢量图 还是 仅仅保留格式为 .jpg 的图片呢？是 内嵌图片 还是 设置它们的 src 属性来链接外部文件呢？ 答案： 首先，用户的图片应该仍然被保留为 jpeg 格式，这些图片本来就是光栅图，所以还是以光栅图的形式保存它们。 考虑到你的用户是手机上访问网站，实际上内嵌图片是个不错的想法，如果你可以做到的话。内嵌图片可以减少浏览器的请求次数，而文件请求是造成手机访问延迟和网页加载不全的重要原因之一。文件请求会增加往返通讯，而往返通讯是手机网页加载缓慢的最重要因素之一。但是内嵌图片会限制你的响应式网站，这个下面会讲到，所以最终，外部文件链接依然可以是一种选择。 开发一个公司网站，公司希望它的 logo 出现在任何一个页面的左上角，很有可能他们还希望一个更大版本的公司logo能出现在搜索引擎的着陆页面，通常来说，用户可以通过手机或者电脑的任何一种来访问，所以你应该使用logo的 矢量图片 还是 光栅图片？ 是 内嵌logo图片 还是 设置它的 src 外部文件链接呢？ 答案： 第一个问题是 应该使用 矢量图，首先，这个logo 非常简单，因为它是基于文本的，所以将其装换为矢量图不会太困难，其次，你希望它有一大一小两个版本，矢量图可伸缩性很好。所以 logo 的大小版本可以使用同一个源文件。 第二个问题，我觉得应该选择外部文件链接，这样它可以被用于多个页面，浏览器可以将它缓存。 你在创建一个叫做 vicarious concerts 的 移动网页应用，用来比较任意观众为音乐会录制的视频，每个视频的加载都需要几秒钟的时间，你决定显示一个旋转的光碟图标，在视频加载时，出现在视频的位置，你应该用这个光碟图标的 gif动画 还是 svg 动图 呢？是应该 内嵌 这个旋转动画呢？还是 设置它的 src 外部文件链接呢？ 答案： 第一个问题是 应该使用 svg 动图；首先，矢量图形更好因为它们可以被无限伸缩而不像 gif 是光栅图形；其次，svg 文件实际上要比 gif 文件小，因为你用的是同一张图片，只是生成了它的旋转动画，而不是播放许多张光碟的图片来表示它在旋转时每个时刻的样子。 第二个问题，选择外部文件链接就很合理，因为多个视频都使用同一个旋转光碟的图标，让浏览器缓存动画再应用到各个页面非常合理。 image 的 srcset 属性 srcset 有两种自定义方式，一种使用 x 来区分设备像素比 (DPR)，另一种使用 w 来描述图像的宽度。 对设备像素比的反应: &lt;img src="image_2x.jpg" srcset="image_2x.jpg 2x, image_1x.jpg 1x" alt="a cool image"&gt; 将 srcset 设置为与逗号分隔的一连串 filename multiplier 对相等，其中每个 multiplier乘数 必须是后跟 x 的整数。 例如，1x 表示 1 倍显示屏，2x 表示像素密度为两倍的显示屏，如 Apple 的 Retina 显示屏。 浏览器会下载与其 DPR 对应的最佳图片。 另请注意，有一个作为备用的 src 属性。 对图片宽度的反应: &lt;img src="image_200.jpg" srcset="image_200.jpg 200w, image_100.jpg 100w" alt="a cool image"&gt; 将 srcset 设置为与逗号分隔的一连串 filename widthDescriptor 对相等，其中每个 widthDescriptor宽度描述符 都以像素为测量单位， 并且必须是后跟 w 的整数。在这里，widthDescriptor宽度描述符 指定每个图片文件的自然宽度，使浏览器能够根据窗口大小和 DPR 选择要请求的最适当的图片。 （如果有 widthDescriptor宽度描述符，浏览器下载图片才能知道其宽度！） 另请注意，有一个作为备用的 src 属性。 包含大小的图片宽度如果图片不以全窗口宽度显示会怎样？那么，除了 srcset 外，你还需要其他元素（假设图片将为全窗口宽度） 向包含媒体查询的图片添加一个 sizes 属性和一个 vw 值。srcset 和 sizes 合起来可让浏览器知道图片的自然宽度以及图片相对于窗口宽度的显示宽度。 知道图片的显示宽度和可用图片文件的宽度后，浏览器将获得下载具有满足其需求的适当分辨率且尽可能小的图片所需的信息。 而且，浏览器在页面加载初期，解析 HTML 时即可做出此选择。 srcset 与 sizes 配合使用的语法示例： &lt;img class="w" src="images/great_pic_800.jpg" sizes="(max-width: 400px) 100vw, (min-width: 401px) 50vw" srcset="images/great_pic_400.jpg 400w, images/great_pic_800.jpg 800w" alt="great picture"&gt; 在本示例中，如果浏览器的窗口宽度等于或小于 400 像素，浏览器知道图片将为全窗口宽度；如果窗口宽度大于 400 像素，则为一半窗口宽度。浏览器知道它具有两个图片选项 - 一个具有 400 像素的自然宽度，另一个具有 800 像素。 &lt;img class="w" src="images/Coffee_1280w.jpg" srcset="images/Coffee_1280w.jpg 1280w, images/Coffee_640w.jpg 640w" sizes="(max-width: 960px) 50vw, 100vw" alt="Coffee by Amy March from Turkey"&gt; 在本示例中，浏览器知道它可以选择使用Coffee_1280w.jpg 和Coffee_640w.jpg，宽度分别为1280px和640px。如果页面宽度为960px或更小，浏览器图像将以一半窗口宽度 50vw显示，否则图像将显示为全窗口宽度 100vw。 我没有在 sizes 中包括第二个媒体查询，因为如果没有媒体查询，列出的宽度会被视为默认值。 另外请注意，sizes 中的媒体查询与 CSS 匹配。说明一下，更改 sizes 不会影响 CSS。它只会提醒浏览器注意最终需要在该处显示的图片。 sizes 由以逗号分隔的 mediaQuery width 对组成。sizes 会在加载流程初期告诉浏览器，该图片会在点击 mediaQuery 时以某个 width 显示。 实际上，如果 sizes 缺失，浏览器会将 sizes 默认为 100vw，表示它预计图片将以全窗口宽度显示。 sizes 会为浏览器额外提供一条信息，以确保它根据图片的最终显示宽度下载正确的图片文件。说明一下，它实际上不会调整图片的大小 - 这是 CSS 的工作。 Picture polyfill 响应式图片社区 小结 通过这节，你已经学会图片并不总是必要的，利用 css 和 图标字体来替代传统图片给响应式设计提供了高性能的解决方案。 综合练习要求： 首先，找到笑脸标志，这是个PNG 图片，把它替换成 Unicode 字符 博客怎能没有社交链接，利用 zocial 在页面底部添加一些社交媒体链接 看到底部那张诡异的装饰图了吗？是个 PNG 图片，它显然非常的不合时宜，所以请将它替换成一个更合理的内容 你可以添加一个响应式 logo，尽情发挥你的灵感 利用 picture 元素提供不同尺寸的图片基于不同的视窗宽度 利用 source 属性设置不同的图片基于设备的像素比 并为所有图片添加合适的 alt 属性 项目链接 项目参考答案 延展 Chrome 开发者工具概览 页面加载时间每延迟 100 毫秒，Amazon 的利润就会降低 1% HTTP 存档：一般来说，网页会对图片发出 56 次请求 PNG，GIF 还是 JPEG？哪个是电子邮件的最佳图像格式？ 图片优化 Imager.js:为 BBC 新闻开发的响应式图片加载 简单的 HTTP 服务器 Trajan 的 Column SVG 例子 20 个让你惊艳不已的 SVG 例子 SVG 动画示例]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>响应式</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式设计(四)]]></title>
    <url>%2F2018%2F05%2F05%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[图片 一图胜千言，而且图片是每个网站的重要组成部分。 每个页面的 HTTP 文档大约有 1.2MB 的图片。这意味着图片占据每个网页的 65% 的体积。 设计响应式网页时，我们需要把图片考虑进去。 自适应网页设计 其余时候，图像也许需要更大幅度的修改：更改比例、裁剪甚至更换整个图像。 在这种情况下，更改图像通常称作艺术指导 实例 下一节，具体说明 响应式图片 处理。 表格 表格有很多花样，如果表格的列超过一定数量，那么它很有可能会溢出视窗。小屏幕会从产生水平滚动条。这里有三种方式可以解决： 隐藏某些列 取消表格样式 封闭表格，例如转折点 隐藏某些列 当视窗尺寸缩小时，隐藏纵列实质上是根据它们的重要性来进行的。让我们来看看一个棒球计分板的做法： Demo 在这个例子，从小屏幕开始，什么信息最重要？短队名 和 最终得分，使用不显示的属性来隐藏所有其他东西。 body &#123; margin: 1em;&#125;.longName &#123; display: none;&#125;.inning&#123; display: none;&#125; 然后随着视窗尺寸变大，显示出长队名，接着开始显示每局的得分。隐藏纵列最大的问题是你在向用户隐瞒内容，如果我需要知道狄启菊有多少得分怎么办？如果我用一个狭窄屏幕的设备，它就不见了，所以使用这些技术的时候要注意，如果可能，请使用 缩写 而不是完全隐藏它。 取消表格样式 用这种方式，当视窗宽度小于一定值的时候，表格会瓦解重组成长列表，与数据表很不同，这种技术的好处是所有的数据，都是可见的，不管视窗的尺寸是多大。让我们看一下案例。 Demo 当视窗变小时，表格瓦解。每个纵列实际上变成独立一行，表头在旁边。使用 媒体查询 我需要告诉表格 当视窗小于一定宽度，这里是500px，我不想让它表现得像一个表格，所以强制 所有的表格、表头元素、表格主体执行块级显示。 @media screen and (max-width: 500px) &#123; table, thead, tbody, th, td, tr &#123; display: block; &#125; /* 移除thead 里的tr */ thead tr &#123; position: absolute; top: -9999px; left: -9999px; &#125; td &#123; position: relative; padding-left: 50%; &#125; td:before &#123; position: absolute; left: 6px; content: attr(data-th); font-weight: bold; &#125; td:first-of-type &#123; font-weight: bold; &#125;&#125; 值得注意的是，我可以设置不显示 thead tr，但是那会对使用屏幕阅读器的人引起可访问性问题，因为浏览器不会告诉它们表格标题，相反，我将内容置于屏幕之外。 为了添加行的标签，使用前置伪选择器 td:before，我用 content: attr(data-th) 来设置使得 data-th 的值应用到每个 td 元素。 表格内滚动 为了把表格放在视窗里，其中一个你可以做的最简单的事情，就是把它放在一个 div 里面，然后设置宽度为 100%，接着设置 overflow-x:auto；然后，与其溢出视窗，表格会占据同样的宽度。但是可以用滚动条在视窗里拉动。 Demo 字体 在网页上大约每行 65 个字符是最普遍的。我们设计的时候要考虑用户的阅读方式，因为它会影响我们的布局，这就是为什么行的长度是你建立网站时的重要参考因素，也是在选择断点时经常拿来参考的。 使字体足够大以适应不同设备的阅读效果是很重要的。我总是把基本字体设置为至少 16像素，行高至少有 1.2em。根据情况，可能会在文本很多网站增加更多行高。 增加次要断点 在主要断点之间调整元素的外边距和内边距是可能有帮助的，或者给一些内容增加字号，会更容易阅读，而且在布局上会感到更自然。 小结这一篇主要描述了响应式设计的几个优化点。下一篇，具体说明 响应式图片 处理。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>响应式</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式设计(三)]]></title>
    <url>%2F2018%2F05%2F04%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[响应模式 响应模式的变化是快的，但是也有一些确定的模式，能在几乎任何设备上都有不错的表现。 响应式网页布局可以大致分为四种模式： 大体流动模型(Mostly Fluid) 掉落列模型(Column Drop) 活动布局模型(Layout Shifter) 画布溢出模型(Off Canvas) 有时，一个网页同时结合几种模式，例如 掉落列和画布溢出模型。以下部分将会讲解每种模式是怎样工作的，然后你就可以运用所学的 flexbox 和 媒体查询 技术来实现它们了。 掉落列模型(Column Drop) 掉落列模型(Column Drop) 可能是最简单的。 在视窗最窄的时候，每个元素都纵向堆放，一个接着一个；当视窗变宽，元素也随之延展，直至到达第一个断点；在第一个断点，所有元素不再竖直堆放，而是前两个元素并排显示，第三个元素在它们下面，这些元素会继续随着视窗而延展，直至到达下一个断点，接着，它们会重排成一个三列布局，通常，当视窗到达最大宽度，列也到达最大宽度，然后它们便不再随视窗而延展，而是在两侧添加外边距。 如何实现 第一阶段从最小的视图开始，我们现在有三个 div 标签，包含在一个 container 标签里 &lt;div class="container"&gt; &lt;div class="box dark_blue"&gt;&lt;/div&gt; &lt;div class="box light_blue"&gt;&lt;/div&gt; &lt;div class="box green"&gt;&lt;/div&gt;&lt;/div&gt; 添加相应的 css 属性，将所有的元素宽度设为 100%: .container &#123; display: flex; flex-wrap: wrap;&#125;.box &#123; width: 100%;&#125; 第二阶段因为这是个例子，我就随机的将断点设为 450px。 我想让这个 深蓝的div 占据视窗宽度的 25%，这个 浅蓝色的div 占据 75%，然后我将 绿色的div 占据整个视窗。 为了实现这些，我需要添加一个新的 媒体查询 来检查，视窗宽度是否大于等于 450px，然后将 深蓝的div 的宽度 设为 25%，浅蓝色的div 的宽度 设为 75%。 @media screen and (min-width: 450px) &#123; .dark_blue &#123; width: 25%; &#125; .light_blue &#123; width: 75%; &#125;&#125; 第三阶段在 550px 处添加第二个断点，然后让 深蓝的div 为 25%，浅蓝色的div 为 50%， 绿色的div 为 25%，为了实现这些，我需要添加一个新的 媒体查询。 @media screen and (min-width: 550px) &#123; .dark_blue, .green &#123; width: 25%; &#125; .light_blue &#123; width: 50%; &#125;&#125; 完成！可以在浏览器中查看效果。 大体流动模型(Mostly Fluid) 大体流动模型(Mostly Fluid) 与 掉落列模型(Column Drop) 非常相似，但是它更像网格系统。它有更多的列，而且列的响应方式也不想她，这要取决于视窗宽度。 在视窗宽度最窄时，与 掉落列模型(Column Drop) 一样，为竖直堆放布局；但是随着视窗变宽，网格模型开始出现，最终，当视窗宽度到达最大宽度，两边会出现外边距，而内容不再延展。 如何实现 第一阶段我把这个网页做的复杂一点，加了几个 div。 从最小的视图开始，我们现在有五个 div 标签，包含在一个 container 标签里 &lt;div class="container"&gt; &lt;div class="box dark_blue"&gt;&lt;/div&gt; &lt;div class="box light_blue"&gt;&lt;/div&gt; &lt;div class="box green"&gt;&lt;/div&gt; &lt;div class="box red"&gt;&lt;/div&gt; &lt;div class="box orange"&gt;&lt;/div&gt;&lt;/div&gt; 与 掉落列模型(Column Drop) 一样，我需要用 flexbox，并在最窄视窗时，将所有的元素宽度设为 100%: .container &#123; display: flex; flex-wrap: wrap;&#125;.box &#123; width: 100%;&#125; 第二阶段在第一个断点，我将 浅蓝色的div 和 绿色的div 宽度设为 50%，和之前一样，我要加上最小宽度检测，确保视窗宽度大于 450px： @media screen and (min-width: 450px) &#123; .light_blue, .green &#123; width: 50%; &#125;&#125; 第三阶段在 550px设置另一个断点，添加 媒体查询 语句，并为每个元素设置相应的宽度： @media screen and (min-width: 550px) &#123; .dark_blue, .light_blue&#123; width: 50%; &#125; .green, .red, .orange &#123; width: 33.333333%; &#125;&#125; 第四阶段最后，再设一个断点来添加两边的外边距，当视窗宽度大于 700px 时： @media screen and (min-width: 700px) &#123; .container &#123; width: 700px; margin-left: auto; margin-right: auto; &#125;&#125; 太棒了，你可以在浏览器上查看成果。 活动布局模型(Layout Shifter) 活动布局模型 应该是最灵活的响应式模型了。 它有很多适用于不同设备的断点，但最关键的是它的布局变化方式，并不是单纯的重排到其他列的下方；flexbox 的亮点在这才真正凹显，因为我们可以利用 CSS顺序属性，这很了不起，因为这样一来，每个布局可变化的地方太多，这就需要更多的计划来维持。 如何实现 第一阶段这一回我做的页面，要稍微复杂一些： 为了实现我想要的布局，我将 浅蓝 div 和 绿色 div 都打包进 id 为 container2 的这个 div 里: &lt;div class="container"&gt; &lt;div class="box dark_blue"&gt;&lt;/div&gt; &lt;div class="container" id="container2"&gt; &lt;div class="box light_blue"&gt;&lt;/div&gt; &lt;div class="box green"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="box red"&gt;&lt;/div&gt;&lt;/div&gt; 我还对 container 这个类做了一些小改动，将它的宽度设为了 100%，所以它包含的元素也占据全部宽度，当没有触发任何断点时，应用的默认样式使所有元素都占据100%宽度，竖直堆放在一起: .container &#123; width: 100%; display: flex; flex-wrap: wrap;&#125;.box &#123; width: 100%;&#125; 第二阶段当在 500px 触发第一个媒体查询时，断点的设置让 深蓝色 和 container2 的宽度都变为 50%，红色的 div 依然宽 100%，因为我们没有修改它的属性。 @media screen and (min-width: 500px) &#123; .dark_blue &#123; width: 50%; &#125; #container2 &#123; width: 50%; &#125;&#125; 第三阶段当在 600px 触发第二个媒体查询时，事情就开始变得很有意思了。 为了让所有元素就位，我需要将 container2 的宽度设为 50%， 并将 深蓝色块 和 红色块 的宽度都设为 25%，接着，为了改变显示顺序，我需要为每个元素指定次序数，如果我将 红色 div 的次序设为 _-1_，他将会在第一个出现，为了让深蓝色元素在最后一个显示，我需要将它的次序数大于 0， 所以我设为 1： 记住 每个元素的默认次序数是 0 @media screen and (min-width: 600px) &#123; .dark_blue &#123; width: 25%; order: 1; &#125; #container2 &#123; width: 50%; &#125; .red &#123; width: 25%; order: -1; &#125;&#125; 让我们在浏览器上看看效果，是不是很棒呢！ 小练习 如图所示，在为红色、绿色和深蓝色的元素中，哪个 div 相对应哪个元素？ 在下方的文本框里，请写出它们对应的 id。你的选项分别是 boxA、boxB 和 boxC. 答案：Red Box (红色框） ----- boxAGreen Box ( 绿色框）----- boxCDark Blue Box ( 深蓝色框 ) ----- boxB 画布溢出模型(Off Canvas) 在画布溢出模型中，内容并不是竖直堆放的。 而是将不常用的内容，比如 导航栏 或者 应用菜单 放在屏幕以外，只有当屏幕足够大的时候，才显示出来。在小尺寸屏幕上，溢出画布的内容通常会在用户点击菜单按钮时出现。 溢出画布的内容，可能的确是从屏幕之外进入屏幕。在这个示例中，内容是从画面左侧进入的。但在其他案例中，它也可以从右侧进入。 如何实现 第一阶段这里有两个元素，深蓝色的 nav 元素 和 浅蓝色的 main 元素。 &lt;nav id="drawer" class="dark_blue"&gt; &lt;h2&gt;关闭画布&lt;/h2&gt; &lt;p&gt;单击抽屉外的区域关闭&lt;/p&gt;&lt;/nav&gt;&lt;main class="light_blue"&gt; &lt;a id="menu"&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"&gt; &lt;path d="M2 6h20v3H2zm0 5h20v3H2zm0 5h20v3H2z"&gt;&lt;/path&gt; &lt;/svg&gt; &lt;/a&gt; &lt;p&gt;单击菜单图标打开抽屉&lt;/p&gt;&lt;/main&gt; 为了确保元素占据整个视窗宽度，我需要将 html、body、main 元素的宽度都设为 100%： html, body, main &#123; height: 100%; width: 100%;&#125; 接着，我要为 nav 元素设置添加 画布溢出样式，指定宽度时要小心，以防止元素占满视窗宽度。我要将 translate属性 值设为 -300px，来将它移出屏幕，然后添加 transition 属性值为 0.3秒，使动画平滑过渡，当我想让它出现时，我要添加 open 类并重设 transform 值。 nav &#123; width: 300px; height: 100%; position: absolute; /* 该变换将菜单移出画布. */ -webkit-transform: translate(-300px, 0); transform: translate(-300px, 0); /* 我们还可以为菜单添加过渡动画。 */ transition: transform 0.3s ease;&#125;nav.open &#123; -webkit-transform: translate(0, 0); transform: translate(0, 0);&#125; 第二阶段现在，在 600px 添加一个断点，让所有元素都回到原来的位置，在 600px 的 媒体查询 中重设 transform 值，将 main 元素的 flex-grow 属性设为1，来使元素能够伸缩至占据余下的视窗宽度。 @media screen and (min-width: 600px) &#123; nav &#123; position: relative; transform: translate(0, 0); &#125; body &#123; display: flex; flex-flow: row nowrap; &#125; main &#123; width: auto; flex-grow: 1; &#125;&#125; 这里是用于切换 open 类的 JavaScript： menu.addEventListener('click', function(e) &#123; drawer.classList.toggle('open'); e.stopPropagation();&#125;); 源码：画布溢出模型让我们在浏览器上看看效果，是不是很棒呢！ 小练习 使用以下的 CSS 来明确这组图，以便准确地展现 nav 在屏幕中的呈现形式。 这个 open 类，会在点击后应用。 下面的四幅图里的哪一个表示的是点击后的结果呢？这几幅图中，灰色方框代表视窗， 蓝紫色块代表弹出菜单， 请选择一幅最能体现这段 CSS 代码运行结果的图。 答案： 第一幅图 综合Demo响应式页面 小结 这篇中，你已经学到了 四个常见的响应式设计模式。下一部分，你将学习一些更高级的技巧来让你的网页出类拔萃。 延展e.stopPropagation()的作用是什么]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>响应式</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式设计(二)]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[媒体查询 响应式网页会基于设备的特征而变化。也就是说，你的响应式网页，需要在不同的设备上应用不同的样式。有几种办法可以有选择性的应用CSS代码，最简单的是 使用 媒体查询。 媒体查询 提供了简单的逻辑方法，来根据不同的设备特征应用不同的样式，比如设备的宽度、高度或者像素比。你可以修改所有内容，从背景图片到页面布局，甚至其他的任何东西。 添加响应式样式很简单，在需要在你的页面里添加另外的样式表，并附上 媒体查询 : &lt;link rel="stylesheet" media="screen and (min-width:300px)" href="patterns.css"&gt; /* patterns.css *//* 屏幕宽带 大于300px 时应用下面这个样式 */body &#123; background-color: blue;&#125; 除了利用样式表链接的媒体查询属性，还有两种方式可以应用媒体查询，你可以在 @media 标签嵌入 或者在 @import 标签嵌入 @media screen and (min-width: 500px) &#123; body &#123; background-color: green; &#125;&#125; @import url("patterns.css") only screen and (min-width: 500px); 因为性能原因，你应该绝对避免使用 @import; 它是一个代价和优先级都非常高的标签 你需要权衡 CSS链接 和 @media 的代价: 如果使用 CSS链接，你会有很多小文件，但是很多 HTTP 请求 如果使用 @media，HTTP 请求 会少一些，但是文件都会变大 响应式网页设计中，最常用的媒体查询变量是 min-width 和 max-width；max-width 的规则是在视窗宽度小于其赋值时生效。min-width的规则是在视窗宽度大于其赋值时生效。 你还可以创建基于 min-device-width 或者 max-device-width 的媒体查询，但是这十分不推荐，它们的区别很细微，但却很重要。 min-width 是基于浏览器窗口大小的；min-device-width 是基于屏幕大小的；额外添加 device-width 变量可以防止在电脑或其他桌面设备上的网页内容 随窗口大小 而变化，因为这样的媒体查询是基于真实设备的尺寸的，而非浏览器窗口；另外一个原因是 一些浏览器 比如 Legacy 安卓浏览器可能返回错误的设备值。 断点 页面改变布局的那个点叫断点 要在哪设置断点？ 根据你的内容来设置断点 一开始设置断点时，先在电脑浏览器上将窗口尺寸设置到最小，顺便打开 Chrome 的开发者工具，因为当改变窗口时，它会在右上角显示当前窗口的分辨率。接下来慢慢拉大窗口，仔细观察内容，看它什么时候需要断点 网格布局网格布局的基本概念 动态网格系统中，有一些动态调整的纵列，当窗口变小时，它们会自动顺延到下一行，有很多不错的范例可供使用，比如 Bootstrap 或者 960px 网格布局系统，它们都非常易于使用，并且已经为你做好了一切准备工作。 弹性框 – FlexboxFlexbox 是最好用的布局工具之一。 之所以功能强大，是因为它能够自动填充空白区域。如果一个元素周围出现了空白，它会自动填补上，而如果空间变得拥挤，它会缩小，直至占据最小空间 怎样用 Flexbox 实现设计？ display: flex flex 的默认堆放方式为 横向堆放；默认情况下 flex 项目会自动填充在一行内，所以无论将元素的宽度设为多少，它们都不会换行。相反，浏览器将其大小适应在视窗内，要改变这些，可以为元素添加 flex-wrap:wrap 语句，这是在告诉浏览器，可以允许内部的元素换行。 flexbox 另外一个很有用的特性，是 能够改变元素的次序，利用 CSS order 属性。比如以下 5个div 在浏览器窗口宽度大于 700px 时会根据 order 属性从小到大的顺序排列 @media screen and (min-width: 700px) &#123; .dark_blue &#123; order: 4; &#125; .light_blue &#123; order: 5; &#125; .green &#123; order: 2; &#125; .orange &#123; order: 3; &#125; .red &#123; order: 1; &#125;&#125; 小练习 看以下图片，从左图设置成右图的布局 答案：header &#123; width: 100%; order:1; &#125;.red &#123; width: 50%; order: 2; &#125;.orange &#123; width: 50%; order: 3; &#125;footer &#123; width: 100%; order:4 &#125;.light_blue &#123; width: 20%; order: 5; &#125;.dark_blue &#123; width: 60%; order: 6; &#125;.green &#123; width: 20%; order: 7; &#125; 请为图片上你看到所有不同颜色的元素，写出它们的宽度和和每个元素在这个布局中所需要的次序。Width (宽度） Order （次序） 参考答案： 或者： 小结flexbox 和 动态网格 看起来都是响应式设计中很棒的通用策略。 延伸学习CSS布局]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>响应式</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式设计(一)]]></title>
    <url>%2F2018%2F05%2F02%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[视窗 视窗是指浏览器能够显示内容的区域。 举个例子，在我的电脑上，我把浏览器窗口设置为 800px 宽，这让我的可视部分也为 800px 宽。如果我拉宽显示窗口，可视部分的宽度也随之变化。 Chromebook 显示器的像素是 宽度 2560px, 高度为 1700px；但是当我把浏览器全屏显示，然后查看显示窗口宽度的话，他显示的宽度只有 1280px。 为什么显示的宽度不是 2560px 呢？ 浏览器并不是根据 物理硬件的像素宽度(Hardware Pixels,这里指 2560px) 而工作的，而是根据 DIPs(Device Independent Pixels)宽度，也就是 设备独立像素值。 一如其名，DIP 是一种计量单位，它将像素值与实际距离联系起来，同一 DIP 值表示的是 屏幕上同样大小的空间，而不论显示器的像素密度是多少。 所以说，如果物理硬件的实际像素值 是 浏览器像素的两倍的话，那么 Chromebook 的像素比就是 2； 所以，浏览器视图的宽度是 1280 dips， 1280 dips 在实际显示的时候，其实是被硬件扩展到了 2560 的硬件像素宽度。 如果没有设定视图端口，浏览器会怎么做呢？ 除非你告诉浏览器，你的网页会在更小的屏幕上显示，否则它不会知道。 以 Nexus 5 手机为例，1080px hw pixels 物理硬件的像素宽度, 像素比 deviec pixel radio: 3，既是 360 dips 在渲染网页的时候，如果它原本是显示在宽 980 DIPs 的屏幕上的，能够放在一个宽度仅有 360 DIPs 的手机屏幕，被压缩了一半还多，显示的效果如下图所见： 然后它为了让内容看上去好一些，会开启字体改善机制，浏览器会试图挑出页面上的首要内容，并把他们放大。也就是说有的字体会变大，易于阅读，但是其他字体还是会一样小，非常难看清。用户必须花好多时间放大屏幕，才能看清或者与内容互动。 小练习 假设你在查看一个手机屏幕技术规格，其分辨率是 1920 * 1080 px， 这里的像素是指以下哪一种像素呢？ DIPs （设备独立像素） 硬件像素 CSS 像素 参考答案： 硬件像素 以下四个图中，哪个图能代表像素比为 2 的设备呢？要知道，像素比是一维数字比，请从一维空间思考。 参考答案： 右边第一幅图 为什么同样的文字会在两个分辨率相同的屏幕上表现不同呢？ CSS 样式没有按预设渲染 两个设备的像素比不同 &lt;meta&gt; 的 initial- scale 导致在不同设备上缩放比例不一致 没有设置好视图端口 参考答案： 两个设备的像素比不同、没有设置好视图端口 计算 CSS 像素已知一个屏幕的分辨率是 1920 ＊ 1080px，像素比为 2，那么它横屏放置时，最大视窗宽度是多少 CSS 像素呢？ 参考答案： 960pixels 1920/2 = 960 计算视窗宽度:请计算以下这四个设备的视窗宽度 (dips) 参考答案： 第二个答案，有时候设备的制造商会模糊处理一些数字，所以任何接近 300 的数字都可以。第四个注意：笔记本屏幕的总宽度是大于浏览器宽度的，但是这个视窗只跟浏览器有关，与整个屏幕宽度无关，所以它只是 800px。 设置窗口 为 head 元素添加 viewport 标签 &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt; 可以让浏览器知道我们的意图，我们需要在视窗值后面设置页面宽度，来指导页面针对具体设备进行宽度调整，这使页面内容可以匹配不同屏幕尺寸，不论在较小的手机还是笔记本上； 添加初始缩放比例属性initial-scale，并赋值为1，告诉浏览器相对像素与CSS像素的比例是一比一。 CSS 像素值曾经是我们调整最多的属性，也是唯一需要担心的，如果不把初始缩放比例设为1的话，有的浏览器会在切换到横屏模式时，依旧保持之前的页面宽度；而且它们还会使内容进行缩放，而无法自动调整布局 元素的最大宽度 内容需要适应视窗宽度，这样才能避免左右滚动 在定义元素宽度时，应采用 相对宽度，来防止元素溢出视窗。 CSS 是允许内容溢出其容器的，所以如果你没有定义边长，当某一元素，例如图片，其尺寸大于其容器时，它就会溢出。你完全可以避免这一困扰，只需要将最大宽度设为 100%。 img &#123; max-width: 100%;&#125; 事实上，我推荐你添加一个多类选择器，将 image、embed、object、video元素的属性一次性都设好。 img,embed,object, video&#123; max-width: 100%;&#125; 小练习 以下选项中，哪段代码是响应式的？请选出所有适用项。 答案： 因为 125px 比任何设备都小得多，所以它符合响应式要求；350px 在一些小的设备视窗宽度可能低至320px的来说会溢出。 触控目标 敲击目标，也就是任何用户可能会点击或者输入的控件，都应该足够大，以便于触击，还要留足空隙，以避免不小心同时按到两个按钮。如果是鼠标，用户可以精准的点击，而如果用我们的手指，操作的精确度会很糟糕。 我们的手指大约有 10mm宽，也就是半英尺，差不多就等于40 CSS像素，与其把按钮尺寸设为 40*40px，你更应该把按钮尺寸设为 48*48px。这样确保元素之间有足够的距离，但是，请确保任何两个敲击目标之间 至少有 40px 的距离，这样能防止用户同时点击到两个按钮，或者完全看不到按钮。 nav, a, button&#123; min-width: 48px; min-height: 48px;&#125; 响应式页面的概念和过程设计响应式网页的概念和过程，和非响应式是一样的，除了不只是画一种宽度的设计稿，而是要多画几种来适应不同屏幕尺寸。 我的设计是从最小的屏幕开始做起，通常是手机设备，做完一个，我会接着做下一个更大一点的，当所有的设计都完成，我会问我自己，还需要为更宽的屏幕做设计吗？有时候，真的不需要做更宽的设计了。 从最小的屏幕做起，我就必须优先考虑什么是对用户最重要的，什么事情是用户最想做的，或者什么是用户最希望在屏幕上看到的。 如果是从最大的屏幕开始设计，一些重要的信息很可能会被轻易删掉，相反，明确内容的优先级，然后最小到大的实际，最重要的内容永远都会留在页面上，用户也能得到最完整的体验，无论使用什么样的设备。 比如一个硬件商店的设计，优先考虑的信息是商店的地址，营业时间和联系方式。把这些信息放在页面的顶部可以让我更好的看到。 除了从小到大的设计，我的代码编写也是从小到大的，这样我就能知道主要风格和布局是否能兼容任何设备，甚至是古老的不支持媒体查询浏览器，但是我最喜欢的理由是性能，如果从小的视图开始设计，我必须一开始就去思考性能的问题，我需要有意识的去做一些决定，来确定内容优先级以及要为用户提供多少信息。 小结 本篇，你已经学习了响应式设计的各个部分，比如，视图端口、元素尺寸以及触控目标 延伸 在移动浏览器中使用viewport元标签控制布局]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>响应式</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序猿必备英语单词]]></title>
    <url>%2F2018%2F04%2F02%2F%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%BF%85%E5%A4%87%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[A abstract 抽象的abstract base class (ABC)抽象基类abstract class 抽象类abstraction 抽象、抽象物、抽象性access 存取、访问access function 访问函数access level访问级别account 账户action 动作activate 激活active 活动的actual parameter 实参adapter 适配器add-in 插件address 地址address space 地址空间ADO(ActiveX Data Object)ActiveX数据对象advanced 高级的aggregation 聚合、聚集algorithm 算法alias 别名align 排列、对齐allocate 分配、配置allocator分配器、配置器angle bracket 尖括号annotation 注解、评注API (Application Programming Interface) 应用(程序)编程接口appearance 外观append 附加application 应用、应用程序application framework 应用程序框架Approximate String Matching 模糊匹配architecture 架构、体系结构archive file 归档文件、存档文件argument参数。array 数组arrow operator 箭头操作符assert(ion) 断言assign 赋值assignment 赋值、分配assignment operator 赋值操作符associated 相关的、相关联的asynchronous 异步的attribute 特性、属性authentication service 验证服务authorization 授权 B background 背景、后台(进程)backup 备份backup device备份设备backup file 备份文件backward compatible 向后兼容、向下兼容base class 基类base type 基类型batch 批处理BCL (base class library)基类库Bin Packing 装箱问题binary 二进制binding 绑定bit 位bitmap 位图block 块、区块、语句块boolean 布林值(真假值，true或false)border 边框bounds checking 边界检查boxing 装箱、装箱转换brace (curly brace) 大括号、花括号bracket (square brakcet) 中括号、方括号breakpoint 断点browser applications 浏览器应用(程序)browser-accessible application 可经由浏览器访问的应用程序bug 缺陷错误build 编连(专指编译和连接)built-in 内建、内置bus 总线business 业务、商务(看场合)business Logic 业务逻辑business rules 业务规则buttons 按钮by/through 通过byte 位元组(由8 bits组成) C cache 高速缓存calendar 日历Calendrical Calculations 日期call 调用call operator 调用操作符callback 回调candidate key 候选键 (for database)cascading delete 级联删除 (for database)cascading update 级联更新 (for database)casting 转型、造型转换catalog 目录chain 链(function calls)character 字符character format 字符格式character set 字符集check box 复选框check button 复选按钮CHECK constraints CHECK约束 (for database)checkpoint 检查点 (for database)child class 子类CIL (common intermediate language)通用中间语言、通用中介语言class 类class declaration 类声明class definition 类定义class derivation list 类继承列表class factory 类厂class hierarchy 类层次结构class library 类库class loader 类装载器class template 类模板class template partial specializations 类模板部分特化class template specializations 类模板特化classification 分类clause 子句cleanup 清理、清除CLI (Common Language Infrastructure) 通用语言基础设施client 客户、客户端client application 客户端应用程序client area 客户区client cursor 客户端游标 (for database)client-server 客户机/服务器、客户端/服务器clipboard 剪贴板clone 克隆CLS (common language specification) 通用语言规范code access security 代码访问安全code page 代码页COFF (Common Object File Format) 通用对象文件格式collection 集合COM (Component Object Model) 组件对象模型combo box 组合框command line 命令行comment 注释commit 提交 (for database)communication 通讯compatible 兼容compile time 编译期、编译时compiler 编译器component组件composite index 复合索引、组合索引 (for database)composite key 复合键、组合键 (for database)composition 复合、组合concept 概念concrete具体的concrete class 具体类concurrency 并发、并发机制configuration 配置、组态Connected Components 连通分支connection 连接 (for database)connection pooling 连接池console 控制台constant 常量Constrained and Unconstrained Optimization 最值问题constraint 约束 (for database)construct 构件、成分、概念、构造（for language）constructor (ctor) 构造函数、构造器container 容器containment包容context 环境、上下文control 控件cookiecopy 拷贝CORBA 通用对象请求中介架构(Common Object Request Broker Architecture)cover 覆盖、涵盖create/creation 创建、生成crosstab query 交叉表查询 (for database)Cryptography 密码CTS (common type system)通用类型系统cube 多维数据集 (for database)cursor 光标cursor 游标 (for database)custom 定制、自定义 D data 数据data connection 数据连接 (for database)data dictionary 数据字典 (for database)data file 数据文件 (for database)data integrity 数据完整性 (for database)data manipulation language (DML)数据操作语言(DML) (for database)data member 数据成员、成员变量data source 数据源 (for database)Data source name (DSN) 数据源名称(DSN) (for database)data structure数据结构Data Structures 基本数据结构data table 数据表 (for database)data-bound 数据绑定 (for database)database 数据库 (for database)database catalog 数据库目录 (for database)database diagram 数据关系图 (for database)database file 数据库文件 (for database)database object 数据库对象 (for database)database owner 数据库所有者 (for database)database project 数据库工程 (for database)database role 数据库角色 (for database)database schema 数据库模式、数据库架构 (for database)database script 数据库脚本 (for database)datagram 数据报文dataset 数据集 (for database)dataset 数据集 (for database)DBMS (database management system)数据库管理系统 (for database)DCOM (distributed COM)分布式COMdead lock 死锁 (for database)deallocate 归还debug 调试debugger 调试器decay 退化declaration 声明default 缺省、默认值DEFAULT constraint默认约束 (for database)default database 默认数据库 (for database)default instance 默认实例 (for database)default result set 默认结果集 (for database)defer 推迟definition 定义delegate 委托delegation 委托deploy 部署derived class 派生类design pattern 设计模式destroy 销毁destructor(dtor)析构函数、析构器device 设备DHTML (dynamic HyperText Markup Language)动态超文本标记语言dialog 对话框Dictionaries 字典digest 摘要digital 数字的directive (编译)指示符directory 目录disassembler 反汇编器DISCO (Discovery of Web Services)Web Services的查找dispatch 调度、分派、派发distributed computing 分布式计算distributed query 分布式查询 (for database)DNA (Distributed interNet Application) 分布式网间应用程序document 文档DOM (Document Object Model)文档对象模型dot operator (圆)点操作符double-byte character set (DBCS)双字节字符集(DBCS)driver 驱动(程序)DTD (document type definition) 文档类型定义dump 转储dump file 转储文件 E e-business 电子商务efficiency 效率efficient 高效encapsulation 封装end user 最终用户end-to-end authentication 端对端身份验证engine 引擎entity 实体enum (enumeration) 枚举enumerators 枚举成员、枚举器equal 相等equality 相等性equality operator 等号操作符error log 错误日志 (for database)escape character 转义符、转义字符escape code 转义码evaluate 评估event 事件event driven 事件驱动的event handler 事件处理器evidence 证据exception 异常exception declaration 异常声明exception handling 异常处理、异常处理机制exception specification 异常规范exception-safe 异常安全的exit 退出explicit 显式explicit specialization 显式特化explicit transaction 显式事务 (for database)export 导出expression 表达式 F fat client 胖客户端feature 特性、特征fetch 提取field 字段 (for database)field 字段(java)field length 字段长度 (for database)file 文件filter 筛选 (for database)finalization 终结finalizer 终结器firewall 防火墙flag 标记flash memory 闪存flush 刷新font 字体foreign key (FK) 外键(FK) (for database)form 窗体formal parameter 形参forward declaration 前置声明forward-only 只向前的forward-only cursor 只向前游标 (for database)framework 框架full specialization 完全特化function 函数function call operator (即operator ()) 函数调用操作符function object 函数对象function template函数模板functionality 功能functor 仿函数 G GC (Garbage collection) 垃圾回收(机制)、垃圾收集(机制)generate 生成generic 泛化的、一般化的、通用的generic algorithm通用算法genericity 泛型getter (相对于 setter)取值函数global 全局的global object 全局对象grant 授权 (for database)group 组、群group box 分组框GUI 图形界面GUID (Globally Unique Identifier) 全球唯一标识符 H handle 句柄handler 处理器hard disk 硬盘hard-coded 硬编码的hard-copy 截屏图hardware 硬件hash table 散列表、哈希表header file头文件heap 堆help file 帮助文件hierarchical data 阶层式数据、层次式数据hierarchy 层次结构、继承体系high level 高阶、高层hook 钩子Host (application)宿主(应用程序)hot key 热键HTML (HyperText Markup Language) 超文本标记语言HTTP (HyperText Transfer Protocol) 超文本传输协议HTTP pipeline HTTP管道hyperlink 超链接 I icon 图标IDE (Integrated Development Environment)集成开发环境identifier 标识符IDL (Interface Definition Language) 接口定义语言idle time 空闲时间if and only if当且仅当IL (Intermediate Language) 中间语言、中介语言image 图象IME 输入法immediate base 直接基类immediate derived 直接派生类immediate updating 即时更新 (for database)implement 实现implementation 实现、实现品implicit 隐式implicit transaction隐式事务 (for database)import 导入incremental update 增量更新 (for database)Independent Set 独立集index 索引 (for database)infinite loop 无限循环infinite recursive 无限递归information 信息inheritance 继承、继承机制initialization 初始化initialization list 初始化列表、初始值列表initialize 初始化inline 内联inline expansion 内联展开inner join 内联接 (for database)instance 实例instantiated 具现化、实体化(常应用于template)instantiation 具现体、具现化实体(常应用于template)integrate 集成、整合integrity 完整性、一致性integrity constraint完整性约束 (for database)interacts 交互interface 接口interoperability 互操作性、互操作能力interpreter 解释器introspection 自省invariants 不变性invoke 调用isolation level 隔离级别 (for database)item 项、条款、项目iterate 迭代iteration 迭代(回圈每次轮回称为一个iteration)iterative 反复的、迭代的iterator 迭代器 J JIT compilation JIT编译即时编译Job Scheduling 工程安排 K key 键 (for database)key column 键列 (for database) L left outer join 左向外联接 (for database)level 阶、层例library 库lifetime 生命期、寿命Linear Programming 线性规划link 连接、链接linkage 连接、链接linker 连接器、链接器list 列表、表、链表list box 列表框literal constant 字面常数livelock 活锁 (for database)load 装载、加载load balancing 负载平衡loader 装载器、载入器local 局部的local object 局部对象lock 锁log 日志login 登录login security mode登录安全模式 (for database)lookup table 查找表 (for database)loop 循环loose coupling 松散耦合lvalue 左值 M machine code 机器码、机器代码macro 宏maintain 维护managed code 受控代码、托管代码Managed Extensions 受控扩充件、托管扩展managed object 受控对象、托管对象manifest 清单many-to-many relationship 多对多关系 (for database)many-to-one relationship 多对一关系 (for database)marshal 列集Matching 匹配member 成员member access operator 成员取用运算子(有dot和arrow两种)member function 成员函数member initialization list成员初始值列表memory 内存memory leak 内存泄漏menu 菜单message 消息message based 基于消息的message loop 消息环message queuing消息队列metadata 元数据metaprogramming元编程method 方法micro 微middle tier 中间层middleware 中间件modeling 建模modeling language 建模语言modem 调制解调器modifier 修饰字、修饰符module 模块most derived class最底层的派生类mouse 鼠标multi-tasking 多任务multi-thread 多线程multicast delegate 组播委托、多点委托multithreaded server application 多线程服务器应用程序multiuser 多用户mutable 可变的mutex 互斥元、互斥体 N named parameter 命名参数named pipe 命名管道namespace 名字空间、命名空间native 原生的、本地的native code 本地码、本机码nested class 嵌套类nested query 嵌套查询 (for database)nested table 嵌套表 (for database)network 网络network card 网卡Network Flow 网络流 O object 对象object based 基于对象的object model 对象模型object oriented 面向对象的ODBC data source ODBC数据源 (for database)ODBC driver ODBC驱动程序 (for database)one-to-many relationship 一对多关系 (for database)one-to-one relationship 一对一关系 (for database)operating system (OS) 操作系统operation 操作operator 操作符、运算符option 选项outer join 外联接 (for database)overflow 上限溢位(相对于underflow)overload 重载override 覆写、重载、重新定义 P package 包packaging 打包palette 调色板parallel 并行parameter 参数、形式参数、形参parameter list 参数列表parameterize 参数化parent class 父类parentheses 圆括弧、圆括号parse 解析parser 解析器part 零件、部件partial specialization 局部特化pass by reference 引用传递pass by value 值传递pattern 模式persistence 持久性pixel 像素placeholder 占位符platform 平台Point Location 位置查询pointer 指针polymorphism 多态pooling 池化pop up 弹出式port 端口postfix 后缀precedence 优先序(通常用于运算子的优先执行次序)prefix 前缀preprocessor 预处理器primary key (PK)主键(PK) (for database)primary table 主表 (for database)primitive type 原始类型print 打印printer 打印机procedure 过程process 进程program 程序programmer 程序员programming编程、程序设计progress bar 进度指示器project 项目、工程property 属性protocol 协议pseudo code伪码 Q qualified 合格的qualifier 修饰符quality 质量queue 队列 R radio button 单选按钮random number 随机数Random Number Generation 随机数生成range 范围、区间rank 等级raw 未经处理的re-direction 重定向readOnly只读record 记录 (for database)recordset 记录集 (for databaserecursion —— 递归recursive 递归refactoring 重构refer 引用、参考reference 引用、参考reflection 反射refresh data 刷新数据 (for database)register 寄存器regular expression 正则表达式relational database 关系数据库remote 远程remote request 远程请求represent 表述，表现resolution 解析过程resolve 解析、决议result set 结果集 (for database)retrieve data 检索数据return 返回return type 返回类型return value 返回值revoke 撤销right outer join 右向外联接 (for database)robust 健壮robustness 健壮性roll back 回滚 (for database)roll forward 前滚 (for database)routine 例程row 行 (for database)rowset 行集 (for database)RPC (remote procedure call)RPC(远程过程调用)runtime 执行期、运行期、执行时、运行时rvalue 右值 S Satisfiability 可满足性save 保存savepoint 保存点 (for database)SAX (Simple API for XML)scalable 可伸缩的、可扩展的schedule 调度scheduler 调度程序schema 模式、纲目结构scope 作用域、生存空间screen 屏幕scroll bar滚动条SDK (Software Development Kit)软件开发包sealed class 密封类search 查找Searching 查找semantics 语义sequential container序列式容器serial 串行serialization/serialize 序列化server 服务器、服务端session 会话 (for database)Set and String Problems 集合与串的问题Set Cover 集合覆盖Set Data Structures 集合Set Packing 集合配置setter 设值函数side effect 副作用signature 签名single-threaded 单线程slider滑块slot 槽SMTP (Simple Mail Transfer Protocol) 简单邮件传输协议snapshot 截屏图snapshot 快照 (for database)SOAP (simple object access protocol) 简单对象访问协议software 软件Sorting 排序source code 源码、源代码specialization 特化specification 规范、规格splitter 切分窗口SQL (Structured Query Language) 结构化查询语言 (for database)stack 栈、堆栈standard library 标准库standard template library 标准模板库stateless 无状态的statement 语句、声明static cursor 静态游标 (for database)static SQL statements 静态SQL语句 (for database)status bar 状态条stored procedure 存储过程 (for database)stream 流string 字符串String Matching 模式匹配stub 存根subobject子对象subquery 子查询 (for database)subscript operator 下标操作符support 支持suspend 挂起symbol 记号syntax 语法system databases 系统数据库 (for database)system tables 系统表 (for database) T table 表 (for database)table-level constraint 表级约束 (for database)target 标的,目标task switch 工作切换TCP (Transport Control Protocol) 传输控制协议template 模板temporary object 临时对象temporary table 临时表 (for database)text 文本Text Compression 压缩text file 文本文件thin client 瘦客户端third-party 第三方thread 线程thread-safe 线程安全的throw 抛出、引发(常指发出一个exception)trace 跟踪transaction 事务 (for database)transaction log 事务日志 (for database)transaction rollback 事务回滚 (for database)traverse 遍历trigger 触发器 (for database)type 类型 U UDDI(Universary Description, Discovery and Integration)统一描述、查询与集成UML (unified modeling language)统一建模语言unary function 单参函数unary operator 一元操作符unboxing 拆箱、拆箱转换underflow 下限溢位(相对于overflow)Unicode 统一字符编码标准，采用双字节对字符进行编码Union query 联合查询 (for database)UNIQUE constraints UNIQUE约束 (for database)unique index 唯一索引 (for database)unmanaged code 非受控代码、非托管代码unmarshal 散集unqualified 未经限定的、未经修饰的URI (Uniform Resource identifier) 统一资源标识符URL (Uniform Resource Locator) 统一资源定位器user 用户user interface 用户界面 V value types 值类型variable 变量vector 向量(一种容器，有点类似array)vendor 厂商viable 可行的video 视频view 视图 (for database)view 视图virtual function 虚函数virtual machine 虚拟机virtual memory 虚拟内存 W Web Services web服务WHERE clause WHERE子句 (for database)wildcard characters 通配符字符 (for database)wildcard search 通配符搜索 (for database)window 窗口window function 窗口函数window procedure 窗口过程Windows authentication Windows身份验证wizard 向导word 单词write enable 写启用 (for database)write-only 只写WSDL (Web Service Description Language)Web Service描述语言 X XML (eXtensible Markup Language) 可扩展标记语言XML Message Interface (XMI) XML消息接口XSD (XML Schema Definition) XML模式定义语言XSL (eXtensible Stylesheet Language) 可扩展样式表语言XSLT (eXtensible Stylesheet Language Transformation)可扩展样式表语言转换xxx based 基于xxx的xxx oriented 面向xxx]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment Multiple hexo personalization settingsMore info: settings]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
