<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试-前端编程思路]]></title>
    <url>%2F2019%2F03%2F02%2F%E9%9D%A2%E8%AF%95-%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A8%8B%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[编写一个js函数，该函数有一个n（数字类型），其返回值是一个数组，该数组内是n个随机且不重复的整数，且整数取值范围是[2,32] 题目解读 输入一个数字类型的参数n，会返回一个包含2到32的数字的数组，数组长度是n(比如你输入数字是2，就会返回数组长度为2的数组); 数组里面的数字用 随机函数 生成，然后还要检查数字是否会重复，也要考虑负数情况等边界条件 知识点 1234Math.ceil(); //向上取整。Math.floor(); //向下取整。Math.round(); //四舍五入。Math.random(); //0.0 ~ 1.0 之间的一个伪随机数。【包含0不包含1) 比如0.8647578968666494 1234Math.ceil(Math.random()*10); // 获取从1到10的随机整数 ，取0的概率极小。Math.round(Math.random()); //可均衡获取0到1的随机整数。Math.floor(Math.random()*10); //可均衡获取0到9的随机整数。Math.round(Math.random()*10); //基本均衡获取0到10的随机整数，其中获取最小值0和最大值10的几率少一半。 直接使用 parseInt，parseFloat 或 Number 将一个非数字的值转化为数字时，表达式返回 NaN 。 ‘abc’ - 3 // NaN parseInt(‘abc’) // NaN parseFloat(‘abc’) // NaN Number(‘abc’) // NaN isNaN() 是一个全局方法，它的作用是检查一个值是否能被 Number() 成功转换 。 如果能转换成功，就返回 false，否则返回 true 。 isNaN(NaN) // true 不能转换 isNaN(‘123’) // false 能转换 isNaN(‘abc’) // true 不能转换 isNaN(‘123ab’) // true 不能转换 isNaN(‘123.45abc’) // true 不能转换 生成随机数方法总结 生成[1,max]的随机数，公式如下： // max - 期望的最大值 parseInt(Math.random()*max,10)+1; Math.floor(Math.random()*max)+1; Math.ceil(Math.random()*max); 生成[0,max]到任意数的随机数，公式如下： // max - 期望的最大值 parseInt(Math.random()*(max+1),10); Math.floor(Math.random()*(max+1)); 生成[min,max]的随机数，公式如下： // max - 期望的最大值 // min - 期望的最小值 parseInt(Math.random()*(max-min+1)+min,10); Math.floor(Math.random()*(max-min+1)+min); 编程思维： 可用 —&gt; 健壮 —&gt; 可靠 —&gt; 宽容 健壮： 最基本的兼容性处理、边界处理、异常处理、用户输入校验 对n的取值范围进行校验；对n是否为数字进行校验；对n是否存在进行校验 宽容： n是一个字符串数字，是否允许进入处理流程？是的话，经验系数*1.1 n是一个含有小数的数字，是否允许进入处理流程？是的话，经验系数*1.1 代码是否有足够多且清晰的注释？是的话，经验系数*1.2 调整[2，32]的范围，你的代码是否可以快速调整甚至不用调整？是的话，经验系数*1.2 伪代码// 生成一个随机数 function getRand(min, max) { return Math.floor(Math.random() * (max - min + 1) + min); } // 去重校验 // function checkArrIn(rand,array){ // if(array.indexof(rand) &gt; -1){ // return true; // } // return false; // } // 判断n是不是一个数字，包含字符串类型的数字 function isNotNum(n){ return isNaN(Number(n)) ? true : false } // 判断n是不是在范围内 function isRandOk(n, min, max){ return n &gt;= min &amp;&amp; n &lt;= max ? true : false } // 判断n是不是含有小数的数字 function isXiaoShu(n){ return String(n).indexOf(&quot;.&quot;) &gt; -1 ? true : false } // 去重检验 arr.includes(e) includes 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 function fn(n){ // 准备一个容器保存结果 let arr = []; // 将整数取值范围用变量保存起来 let min = 2; let max = 32; // 参数校验 if (isNotNum(n)) return []; if (!isRandOk(n,min,max)) return []; if (isXiaoShu(n)) return []; for(let i = 0; i &lt; n; i++){ let rand = getRand(min, max); if (arr.includes(rand)) { i--; // 减一是因为如果第i次循环的时候如果数组有了该值，就重新走一遍 } else { arr.push(rand); } } return arr } fn(2); // (2) [15, 11] 随机 fn(&apos;5&apos;); // (5) [13, 2, 11, 27, 12] 随机 fn(&apos;3.33&apos;); // [] fn(5.5); // []]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>编程逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序猿必备英语单词]]></title>
    <url>%2F2019%2F03%2F02%2F%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%BF%85%E5%A4%87%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[A abstract 抽象的abstract base class (ABC)抽象基类abstract class 抽象类abstraction 抽象、抽象物、抽象性access 存取、访问access function 访问函数access level访问级别account 账户action 动作activate 激活active 活动的actual parameter 实参adapter 适配器add-in 插件address 地址address space 地址空间ADO(ActiveX Data Object)ActiveX数据对象advanced 高级的aggregation 聚合、聚集algorithm 算法alias 别名align 排列、对齐allocate 分配、配置allocator分配器、配置器angle bracket 尖括号annotation 注解、评注API (Application Programming Interface) 应用(程序)编程接口appearance 外观append 附加application 应用、应用程序application framework 应用程序框架Approximate String Matching 模糊匹配architecture 架构、体系结构archive file 归档文件、存档文件argument参数。array 数组arrow operator 箭头操作符assert(ion) 断言assign 赋值assignment 赋值、分配assignment operator 赋值操作符associated 相关的、相关联的asynchronous 异步的attribute 特性、属性authentication service 验证服务authorization 授权 B background 背景、后台(进程)backup 备份backup device备份设备backup file 备份文件backward compatible 向后兼容、向下兼容base class 基类base type 基类型batch 批处理BCL (base class library)基类库Bin Packing 装箱问题binary 二进制binding 绑定bit 位bitmap 位图block 块、区块、语句块boolean 布林值(真假值，true或false)border 边框bounds checking 边界检查boxing 装箱、装箱转换brace (curly brace) 大括号、花括号bracket (square brakcet) 中括号、方括号breakpoint 断点browser applications 浏览器应用(程序)browser-accessible application 可经由浏览器访问的应用程序bug 缺陷错误build 编连(专指编译和连接)built-in 内建、内置bus 总线business 业务、商务(看场合)business Logic 业务逻辑business rules 业务规则buttons 按钮by/through 通过byte 位元组(由8 bits组成) C cache 高速缓存calendar 日历Calendrical Calculations 日期call 调用call operator 调用操作符callback 回调candidate key 候选键 (for database)cascading delete 级联删除 (for database)cascading update 级联更新 (for database)casting 转型、造型转换catalog 目录chain 链(function calls)character 字符character format 字符格式character set 字符集check box 复选框check button 复选按钮CHECK constraints CHECK约束 (for database)checkpoint 检查点 (for database)child class 子类CIL (common intermediate language)通用中间语言、通用中介语言class 类class declaration 类声明class definition 类定义class derivation list 类继承列表class factory 类厂class hierarchy 类层次结构class library 类库class loader 类装载器class template 类模板class template partial specializations 类模板部分特化class template specializations 类模板特化classification 分类clause 子句cleanup 清理、清除CLI (Common Language Infrastructure) 通用语言基础设施client 客户、客户端client application 客户端应用程序client area 客户区client cursor 客户端游标 (for database)client-server 客户机/服务器、客户端/服务器clipboard 剪贴板clone 克隆CLS (common language specification) 通用语言规范code access security 代码访问安全code page 代码页COFF (Common Object File Format) 通用对象文件格式collection 集合COM (Component Object Model) 组件对象模型combo box 组合框command line 命令行comment 注释commit 提交 (for database)communication 通讯compatible 兼容compile time 编译期、编译时compiler 编译器component组件composite index 复合索引、组合索引 (for database)composite key 复合键、组合键 (for database)composition 复合、组合concept 概念concrete具体的concrete class 具体类concurrency 并发、并发机制configuration 配置、组态Connected Components 连通分支connection 连接 (for database)connection pooling 连接池console 控制台constant 常量Constrained and Unconstrained Optimization 最值问题constraint 约束 (for database)construct 构件、成分、概念、构造（for language）constructor (ctor) 构造函数、构造器container 容器containment包容context 环境、上下文control 控件cookiecopy 拷贝CORBA 通用对象请求中介架构(Common Object Request Broker Architecture)cover 覆盖、涵盖create/creation 创建、生成crosstab query 交叉表查询 (for database)Cryptography 密码CTS (common type system)通用类型系统cube 多维数据集 (for database)cursor 光标cursor 游标 (for database)custom 定制、自定义 D data 数据data connection 数据连接 (for database)data dictionary 数据字典 (for database)data file 数据文件 (for database)data integrity 数据完整性 (for database)data manipulation language (DML)数据操作语言(DML) (for database)data member 数据成员、成员变量data source 数据源 (for database)Data source name (DSN) 数据源名称(DSN) (for database)data structure数据结构Data Structures 基本数据结构data table 数据表 (for database)data-bound 数据绑定 (for database)database 数据库 (for database)database catalog 数据库目录 (for database)database diagram 数据关系图 (for database)database file 数据库文件 (for database)database object 数据库对象 (for database)database owner 数据库所有者 (for database)database project 数据库工程 (for database)database role 数据库角色 (for database)database schema 数据库模式、数据库架构 (for database)database script 数据库脚本 (for database)datagram 数据报文dataset 数据集 (for database)dataset 数据集 (for database)DBMS (database management system)数据库管理系统 (for database)DCOM (distributed COM)分布式COMdead lock 死锁 (for database)deallocate 归还debug 调试debugger 调试器decay 退化declaration 声明default 缺省、默认值DEFAULT constraint默认约束 (for database)default database 默认数据库 (for database)default instance 默认实例 (for database)default result set 默认结果集 (for database)defer 推迟definition 定义delegate 委托delegation 委托deploy 部署derived class 派生类design pattern 设计模式destroy 销毁destructor(dtor)析构函数、析构器device 设备DHTML (dynamic HyperText Markup Language)动态超文本标记语言dialog 对话框Dictionaries 字典digest 摘要digital 数字的directive (编译)指示符directory 目录disassembler 反汇编器DISCO (Discovery of Web Services)Web Services的查找dispatch 调度、分派、派发distributed computing 分布式计算distributed query 分布式查询 (for database)DNA (Distributed interNet Application) 分布式网间应用程序document 文档DOM (Document Object Model)文档对象模型dot operator (圆)点操作符double-byte character set (DBCS)双字节字符集(DBCS)driver 驱动(程序)DTD (document type definition) 文档类型定义dump 转储dump file 转储文件 E e-business 电子商务efficiency 效率efficient 高效encapsulation 封装end user 最终用户end-to-end authentication 端对端身份验证engine 引擎entity 实体enum (enumeration) 枚举enumerators 枚举成员、枚举器equal 相等equality 相等性equality operator 等号操作符error log 错误日志 (for database)escape character 转义符、转义字符escape code 转义码evaluate 评估event 事件event driven 事件驱动的event handler 事件处理器evidence 证据exception 异常exception declaration 异常声明exception handling 异常处理、异常处理机制exception specification 异常规范exception-safe 异常安全的exit 退出explicit 显式explicit specialization 显式特化explicit transaction 显式事务 (for database)export 导出expression 表达式 F fat client 胖客户端feature 特性、特征fetch 提取field 字段 (for database)field 字段(java)field length 字段长度 (for database)file 文件filter 筛选 (for database)finalization 终结finalizer 终结器firewall 防火墙flag 标记flash memory 闪存flush 刷新font 字体foreign key (FK) 外键(FK) (for database)form 窗体formal parameter 形参forward declaration 前置声明forward-only 只向前的forward-only cursor 只向前游标 (for database)framework 框架full specialization 完全特化function 函数function call operator (即operator ()) 函数调用操作符function object 函数对象function template函数模板functionality 功能functor 仿函数 G GC (Garbage collection) 垃圾回收(机制)、垃圾收集(机制)generate 生成generic 泛化的、一般化的、通用的generic algorithm通用算法genericity 泛型getter (相对于 setter)取值函数global 全局的global object 全局对象grant 授权 (for database)group 组、群group box 分组框GUI 图形界面GUID (Globally Unique Identifier) 全球唯一标识符 H handle 句柄handler 处理器hard disk 硬盘hard-coded 硬编码的hard-copy 截屏图hardware 硬件hash table 散列表、哈希表header file头文件heap 堆help file 帮助文件hierarchical data 阶层式数据、层次式数据hierarchy 层次结构、继承体系high level 高阶、高层hook 钩子Host (application)宿主(应用程序)hot key 热键HTML (HyperText Markup Language) 超文本标记语言HTTP (HyperText Transfer Protocol) 超文本传输协议HTTP pipeline HTTP管道hyperlink 超链接 I icon 图标IDE (Integrated Development Environment)集成开发环境identifier 标识符IDL (Interface Definition Language) 接口定义语言idle time 空闲时间if and only if当且仅当IL (Intermediate Language) 中间语言、中介语言image 图象IME 输入法immediate base 直接基类immediate derived 直接派生类immediate updating 即时更新 (for database)implement 实现implementation 实现、实现品implicit 隐式implicit transaction隐式事务 (for database)import 导入incremental update 增量更新 (for database)Independent Set 独立集index 索引 (for database)infinite loop 无限循环infinite recursive 无限递归information 信息inheritance 继承、继承机制initialization 初始化initialization list 初始化列表、初始值列表initialize 初始化inline 内联inline expansion 内联展开inner join 内联接 (for database)instance 实例instantiated 具现化、实体化(常应用于template)instantiation 具现体、具现化实体(常应用于template)integrate 集成、整合integrity 完整性、一致性integrity constraint完整性约束 (for database)interacts 交互interface 接口interoperability 互操作性、互操作能力interpreter 解释器introspection 自省invariants 不变性invoke 调用isolation level 隔离级别 (for database)item 项、条款、项目iterate 迭代iteration 迭代(回圈每次轮回称为一个iteration)iterative 反复的、迭代的iterator 迭代器 J JIT compilation JIT编译即时编译Job Scheduling 工程安排 K key 键 (for database)key column 键列 (for database) L left outer join 左向外联接 (for database)level 阶、层例library 库lifetime 生命期、寿命Linear Programming 线性规划link 连接、链接linkage 连接、链接linker 连接器、链接器list 列表、表、链表list box 列表框literal constant 字面常数livelock 活锁 (for database)load 装载、加载load balancing 负载平衡loader 装载器、载入器local 局部的local object 局部对象lock 锁log 日志login 登录login security mode登录安全模式 (for database)lookup table 查找表 (for database)loop 循环loose coupling 松散耦合lvalue 左值 M machine code 机器码、机器代码macro 宏maintain 维护managed code 受控代码、托管代码Managed Extensions 受控扩充件、托管扩展managed object 受控对象、托管对象manifest 清单many-to-many relationship 多对多关系 (for database)many-to-one relationship 多对一关系 (for database)marshal 列集Matching 匹配member 成员member access operator 成员取用运算子(有dot和arrow两种)member function 成员函数member initialization list成员初始值列表memory 内存memory leak 内存泄漏menu 菜单message 消息message based 基于消息的message loop 消息环message queuing消息队列metadata 元数据metaprogramming元编程method 方法micro 微middle tier 中间层middleware 中间件modeling 建模modeling language 建模语言modem 调制解调器modifier 修饰字、修饰符module 模块most derived class最底层的派生类mouse 鼠标multi-tasking 多任务multi-thread 多线程multicast delegate 组播委托、多点委托multithreaded server application 多线程服务器应用程序multiuser 多用户mutable 可变的mutex 互斥元、互斥体 N named parameter 命名参数named pipe 命名管道namespace 名字空间、命名空间native 原生的、本地的native code 本地码、本机码nested class 嵌套类nested query 嵌套查询 (for database)nested table 嵌套表 (for database)network 网络network card 网卡Network Flow 网络流 O object 对象object based 基于对象的object model 对象模型object oriented 面向对象的ODBC data source ODBC数据源 (for database)ODBC driver ODBC驱动程序 (for database)one-to-many relationship 一对多关系 (for database)one-to-one relationship 一对一关系 (for database)operating system (OS) 操作系统operation 操作operator 操作符、运算符option 选项outer join 外联接 (for database)overflow 上限溢位(相对于underflow)overload 重载override 覆写、重载、重新定义 P package 包packaging 打包palette 调色板parallel 并行parameter 参数、形式参数、形参parameter list 参数列表parameterize 参数化parent class 父类parentheses 圆括弧、圆括号parse 解析parser 解析器part 零件、部件partial specialization 局部特化pass by reference 引用传递pass by value 值传递pattern 模式persistence 持久性pixel 像素placeholder 占位符platform 平台Point Location 位置查询pointer 指针polymorphism 多态pooling 池化pop up 弹出式port 端口postfix 后缀precedence 优先序(通常用于运算子的优先执行次序)prefix 前缀preprocessor 预处理器primary key (PK)主键(PK) (for database)primary table 主表 (for database)primitive type 原始类型print 打印printer 打印机procedure 过程process 进程program 程序programmer 程序员programming编程、程序设计progress bar 进度指示器project 项目、工程property 属性protocol 协议pseudo code伪码 Q qualified 合格的qualifier 修饰符quality 质量queue 队列 R radio button 单选按钮random number 随机数Random Number Generation 随机数生成range 范围、区间rank 等级raw 未经处理的re-direction 重定向readOnly只读record 记录 (for database)recordset 记录集 (for databaserecursion —— 递归recursive 递归refactoring 重构refer 引用、参考reference 引用、参考reflection 反射refresh data 刷新数据 (for database)register 寄存器regular expression 正则表达式relational database 关系数据库remote 远程remote request 远程请求represent 表述，表现resolution 解析过程resolve 解析、决议result set 结果集 (for database)retrieve data 检索数据return 返回return type 返回类型return value 返回值revoke 撤销right outer join 右向外联接 (for database)robust 健壮robustness 健壮性roll back 回滚 (for database)roll forward 前滚 (for database)routine 例程row 行 (for database)rowset 行集 (for database)RPC (remote procedure call)RPC(远程过程调用)runtime 执行期、运行期、执行时、运行时rvalue 右值 S Satisfiability 可满足性save 保存savepoint 保存点 (for database)SAX (Simple API for XML)scalable 可伸缩的、可扩展的schedule 调度scheduler 调度程序schema 模式、纲目结构scope 作用域、生存空间screen 屏幕scroll bar滚动条SDK (Software Development Kit)软件开发包sealed class 密封类search 查找Searching 查找semantics 语义sequential container序列式容器serial 串行serialization/serialize 序列化server 服务器、服务端session 会话 (for database)Set and String Problems 集合与串的问题Set Cover 集合覆盖Set Data Structures 集合Set Packing 集合配置setter 设值函数side effect 副作用signature 签名single-threaded 单线程slider滑块slot 槽SMTP (Simple Mail Transfer Protocol) 简单邮件传输协议snapshot 截屏图snapshot 快照 (for database)SOAP (simple object access protocol) 简单对象访问协议software 软件Sorting 排序source code 源码、源代码specialization 特化specification 规范、规格splitter 切分窗口SQL (Structured Query Language) 结构化查询语言 (for database)stack 栈、堆栈standard library 标准库standard template library 标准模板库stateless 无状态的statement 语句、声明static cursor 静态游标 (for database)static SQL statements 静态SQL语句 (for database)status bar 状态条stored procedure 存储过程 (for database)stream 流string 字符串String Matching 模式匹配stub 存根subobject子对象subquery 子查询 (for database)subscript operator 下标操作符support 支持suspend 挂起symbol 记号syntax 语法system databases 系统数据库 (for database)system tables 系统表 (for database) T table 表 (for database)table-level constraint 表级约束 (for database)target 标的,目标task switch 工作切换TCP (Transport Control Protocol) 传输控制协议template 模板temporary object 临时对象temporary table 临时表 (for database)text 文本Text Compression 压缩text file 文本文件thin client 瘦客户端third-party 第三方thread 线程thread-safe 线程安全的throw 抛出、引发(常指发出一个exception)trace 跟踪transaction 事务 (for database)transaction log 事务日志 (for database)transaction rollback 事务回滚 (for database)traverse 遍历trigger 触发器 (for database)type 类型 U UDDI(Universary Description, Discovery and Integration)统一描述、查询与集成UML (unified modeling language)统一建模语言unary function 单参函数unary operator 一元操作符unboxing 拆箱、拆箱转换underflow 下限溢位(相对于overflow)Unicode 统一字符编码标准，采用双字节对字符进行编码Union query 联合查询 (for database)UNIQUE constraints UNIQUE约束 (for database)unique index 唯一索引 (for database)unmanaged code 非受控代码、非托管代码unmarshal 散集unqualified 未经限定的、未经修饰的URI (Uniform Resource identifier) 统一资源标识符URL (Uniform Resource Locator) 统一资源定位器user 用户user interface 用户界面 V value types 值类型variable 变量vector 向量(一种容器，有点类似array)vendor 厂商viable 可行的video 视频view 视图 (for database)view 视图virtual function 虚函数virtual machine 虚拟机virtual memory 虚拟内存 W Web Services web服务WHERE clause WHERE子句 (for database)wildcard characters 通配符字符 (for database)wildcard search 通配符搜索 (for database)window 窗口window function 窗口函数window procedure 窗口过程Windows authentication Windows身份验证wizard 向导word 单词write enable 写启用 (for database)write-only 只写WSDL (Web Service Description Language)Web Service描述语言 X XML (eXtensible Markup Language) 可扩展标记语言XML Message Interface (XMI) XML消息接口XSD (XML Schema Definition) XML模式定义语言XSL (eXtensible Stylesheet Language) 可扩展样式表语言XSLT (eXtensible Stylesheet Language Transformation)可扩展样式表语言转换xxx based 基于xxx的xxx oriented 面向xxx]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型继承:子类]]></title>
    <url>%2F2019%2F03%2F01%2F%E5%AD%90%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[子类 实现继承的好处之一就是它允许你重用现有代码。通过建立继承，我们可以子类化，也就是让一个“子”对象接受“父”对象的大部分或全部属性和方法，同时保留它自己独特的方法。 假设我们有一个父 Animal 对象（即构造函数），其中包含诸如 age 和 weight 等属性。同一个 Animal 对象还可以访问 eat 和 sleep 等方法。 现在，再假设我们要创建一个 Cat 子对象。与描述其他动物一样，你也可以通过 age 或 weight 来描述一只猫，而且你也可以确定猫会 eat 和 sleep。因此，在创建这个 Cat 对象的时候，我们可以简单地重写和重新实现 Animal 中的所有方法和属性——或者，我们也可以让 Cat 从 Animal 继承 这些现有的属性和方法，从而节省时间并防止重复代码！ 我们不仅可以让 Cat 接受 Animal 的属性和方法，还可以赋予 Cat 独特的属性和方法！也许一只 Cat 具有独特的 lives 属性为 9，或有一个专门的 meow() 方法，是其他 Animal 所没有的。使用原型继承，Cat 只需要实现 Cat 的独特功能，并重用 Animal 的现有功能即可。 通过原型继承 回想一下上一部分的原型链： 当在任何对象上调用任何属性时，JavaScript 引擎将首先在该对象中查找该属性（即该对象自己的、非继承的属性）。如果没有找到该属性，JavaScript 将查看该对象的原型。如果在对象原型中 仍然 找不到该属性，则 JavaScript 将在原型链上继续搜索。 JavaScript 中的继承重点就是建立原型链。 秘密链接 如你所知，在尝试搜索一个不存在于某个对象中的属性时，该对象的构造函数的原型是被首先搜索的。请考虑以下具有两个属性 claws 和 diet 的 bear 对象： const bear = { claws: true, diet: &apos;carnivore&apos; }; 让我们将以下 PolarBear() 构造函数的 prototype 属性赋为 bear： function PolarBear() { //... } PolarBear.prototype = bear; 现在，让我们调用 PolarBear() 构造函数来创建一个新的对象，然后给它两个属性： const snowball = new PolarBear(); snowball.color = &apos;white&apos;; snowball.favoriteDrink = &apos;cola&apos;; snowball 对象目前看起来像这样： { color: &apos;white&apos;, favoriteDrink: &apos;cola&apos; } 请注意，snowball 只有两个自己的属性：color 和 favoriteDrink。但是，snowball 也可以访问自身并不具有的属性：claws 和 diet： console.log(snowball.claws); //true console.log(snowball.diet); //&apos;carnivore&apos; 由于 claw 和 diet 都作为 prototype 对象中的属性存在，因此它们会被查找，因为对象被秘密链接到其构造函数的 prototype 属性。 太棒了！但你可能会想：这个通向 prototype 对象的秘密链接到底是什么呢？当从 PolarBear() 构造函数构造对象之后（如 snowball），这些对象可以立即访问 PolarBear() 的原型中的属性。这究竟是怎么做到的呢？ 事实证明，这个秘密链接是 snowball 的 __proto__ 属性（注意每一端有两个下划线）。 __proto__ 是构造函数所创建的所有对象（即实例）的一个属性，并直接指向该构造函数的 prototype 对象。让我们来看看它是什么样的！ console.log(snowball.__proto__); //{ claws: true, diet: &apos;carnivore&apos; } 由于 __proto__ 属性所指向的对象与 PolarBear 的原型 bear 相同，因此将它们进行比较会返回 true： console.log(snowball.__proto__ === bear); //true 强烈建议不要重新分配 proto 属性，甚至不要在你编写的任何代码中使用它。 首先，会有跨浏览器的兼容性问题。更重要的是：由于 JavaScript 引擎会在原型链上搜索和访问属性，因此更改对象的原型可能会导致性能问题。有关 proto 的 MDN 文章甚至警告，不要在页面顶部的红色文本中使用此属性！ 我们有必要知道这个秘密链接，以了解函数和对象是如何相互关联的，但你不应该使用 __proto__ 来管理继承。如果你只是需要查看对象的原型，则仍然可以使用 Object.getPrototypeOf() 来达到目的。 如果只继承原型呢？ 假设我们希望一个 Child 对象从一个 Parent 对象继承。为什么不应该只设置 Child.prototype = Parent.prototype 呢？ 首先，还记得吗，对象是通过引用来传递的。这意味着，由于 Child.prototype 对象和 Parent.prototype 对象引用的是同一个对象，因此你对 Child 的原型所作的任何更改也会被应用于 Parent 的原型！我们可不希望子对象能够修改其父对象的属性！ 最重要的是，这样做不会创建原型链。如果我们想让一个对象从我们想要的任何对象进行继承，而不仅仅是它的原型呢？ 我们仍然需要一种方式来有效地管理继承，同时又完全不会改变原型。 小练习 请考虑以下代码: function GuineaPig (name) { this.name = name; this.isCute = true; } const waffle = new GuineaPig(&apos;Waffle&apos;); waffle.__proto__指向什么？ 参考答案： GuineaPig.prototype 请考虑以下代码: function Car (color, year) { this.color = color; this.year = year; } Car.prototype.drive = function () { console.log(&apos;Vroom vroom!&apos;); }; const car = new Car(&apos;silver&apos;, 1988); 当 car.drive() 被调用时，会发生什么？ 参考答案： 顺序 事件 第一 JavaScript引擎在car对象内搜索名为drive的属性 第二 JavaScript引擎在car对象中找不到drive属性 第三 然后，JavaScript引擎会访问car.__proto__属性 第四 由于car.__proto__指向Car.prototype,因此JavaScript引擎会在该原型中搜索drive 第五 由于Car.prototype.drive是一个已定义的属性，因此它会被返回 第六 最后，由于drive作为一个方法在car上被调用，因此this的值会被设置为car Object.create() 到目前为止，我们在继承方面遇到了一些问题。首先，虽然 __proto__ 可以访问被调用的对象的原型，但是在你编写的代码中使用它并不是好习惯。 另一方面，我们也不应该_只_继承原型；这样做不会创建原型链，而且我们对子对象所作的任何更改也会反映在父对象中。 那么，我们应该如何继续往前呢？ 实际上，我们可以借助一种方式来自己设置对象的原型：使用 Object.create()。而且最棒的是，这种方式既可以让我们管理继承，同时又 不会 改变原型！ Object.create() 会接受一个对象作为参数，并返回一个新的对象，其 __proto__ 属性会被设置为传递给它的参数。然后，你只需要将所返回的对象设置为子对象构造函数的原型即可。让我们来看一个例子！ 首先，假设我们有一个 mammal 对象，它有两个属性：vertebrate 和 earBones： const mammal = { vertebrate: true, earBones: 3 }; 还记得吗，Object.create() 会接受一个对象作为参数，并返回一个 新的 对象。这个新对象的 __proto__ 属性会被设置为最初传递给 Object.create() 的参数。让我们把这个返回值保存到变量 rabbit 中： const rabbit = Object.create(mammal); 我们预期这个新的 rabbit 对象是空白的，没有自己的属性： console.log(rabbit); //{} 但是，rabbit 现在应该已被秘密链接到 mammal。也就是说，它的 __proto__ 属性应该指向 mammal： console.log(rabbit.__proto__ === mammal); //true 太棒了！这意味着，现在 rabbit 扩展了 mammal（即 rabbit 继承自 mammal），而且 rabbit 可以将 mammal 的属性当作自己的属性一样进行访问！ console.log(rabbit.vertebrate); //true console.log(rabbit.earBones); //3 Object.create() 给了我们一个在 JavaScript 中建立原型继承的简洁方法。我们可以通过这种方式轻松扩展原型链，而且可以让对象从我们想要的任何对象进行继承！ 下面让我们来看一个更复杂的例子： function Animal (name) { this.name = name; } Animal.prototype.walk = function () { console.log(`${this.name} walks!`); }; function Cat (name) { Animal.call(this, name); this.lives = 9; } 这是一个 Animal 构造函数，以及一个在 Animal 的原型上直接定义的 walk 方法，此外，还有一个 Cat 构造函数，你可能注意到，我们在 Cat 构造函数中使用了 call 方法，并且直接在 Animal 构造函数 中调用它。 我们使用 call 而不是关键字 new ，因为我们不想构造一个全新的 animal 对象。我们只关心 cat 实例或 cat 对象上的 animal 初始化逻辑，call 方法的作用是调用 Animal 并将 this 设为 cat 实例，否则 this.name 将是 undefined。 现在，有了这个继承自 Animal 的 Cat: Cat.prototype = Object.create(Animal.prototype); // Animal{} 我们还需要更改构造函数, 否则所有的 cat 对象的构造函数将设为 animal： Cat.prototype.constructor = Cat; // f Cat(name){ // Animal.call(this, name); // this.lives = 9; // } 现在，我们向 cat 的原型添加一个 使所有 cat 对象都能共享的方法: Meow Cat.prototype.meow = function () { console.log(&apos;Meow!&apos;); }; // f () { // console.log(&apos;Meow!&apos;); // } 使用关键字 new 调用 cat 构造函数，并初始化新的 cat 对象 称之为 Bambi： const bambi = new Cat(&apos;Bambi&apos;); bambi.meow(); // Meow! bambi.walk(); // Bambi walks! bambi.name; // &quot;Bambi&quot; 总结下，为了在JavaScript 中有效地管理继承,一个很好的方式是避免完全更改原型 ，为此，我们可以使用 object.create 小练习 请考虑以下代码： function Parent() { // ... } function Child() { // ... } Child.prototype = Object.create(Parent.prototype); const child = new Child(); 当 child instanceof Parent; 被执行时，什么会被输出到控制台？ 参考答案： true 以下哪一项有关 Object.create() 的说法是正确的？请选择所有适用项： 它会返回一个新的对象，其 __proto__ 属性会被设置为传递给 Object.create() 的对象 使用 Object.create() ，我们可以让对象从我们想要的任何对象进行继承(即不仅是prototype) Object.create()让我们既可以实现原型继承，又不会改变原型 该方法直接在一个对象上被调用 参考答案： 1、2、3 小结 JavaScript 中的继承重点就是建立原型链。这让我们可以子类化，也就是创建一个“子”对象，让它继承“父”对象的大部分或全部属性和方法。然后，我们可以分别实现任何子对象的独特属性和方法，同时仍然保留其父对象的数据和功能。 对象（实例）通过该实例的 __proto__ 属性被秘密链接到其构造函数的原型对象。 你不应该在你编写的任何代码中使用 __proto__。在任何代码中使用 __proto__，或者只继承原型，将会直接导致某些不必要的问题。要在 JavaScript 中高效地管理继承，一个有效的方式就是避免完全改变原型。 Object.create() 可以帮助我们做到这一点，它可以接受一个父对象，返回一个 新的 对象，并将其 __proto__ 属性设置为该父对象。 延伸 MDN 上的继承和原型链 MDN 上的Object.create()]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型继承]]></title>
    <url>%2F2019%2F03%2F01%2F%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[原型、原型链 JavaScript 常被描述为一种基于原型的语言 (prototype-based language)。每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。 准确地说，这些属性和方法定义在 Object的构造器函数(constructor functions)之上的 prototype 属性上，而非对象实例本身。 继承 我的父母是黑色头发，我也是黑色的头发。可以看出，我从我父母那里遗传了黑头发基因。 在 JavaScript 中 继承是指一个对象基于另一个对象。 假设有一个新建的 car 对象的构造函数，每个 car 对象都具有不同的颜色属性值，例如 红色、蓝色和绿色；对象不仅具有自己的属性，而且与通用对象秘密关联，这种通用对象称之为原型；我们可以向原型中添加 car 对象都能共享的方法 drive方法 ，因此在每次新建一个 car 时，它们可以共享相同的 drive 方法，而不是创建新的 drive 方法。 和其他语言不同，JavaScript 利用原型来管理继承。 添加方法到原型 还记得吗，对象包含数据（即属性）和操纵数据的手段（即方法）。在此之前，我们都是将方法直接添加到构造函数本身： function Cat() { this.lives = 9; this.sayName = function () { console.log(`Meow! My name is ${this.name}`); }; } 这样，通过将一个函数保存到新创建的 Cat 对象的 sayName 属性中，可以将 sayName() 方法添加到所有 Cat 对象上。这样做没问题，但是如果我们想用这个构造函数实例化更多的 Cat 对象呢？你每一次都要为这个 Cat 对象的 sayName 创建一个新的函数！更重要的是：如果你想对方法进行更改，则必须逐个更新所有对象。在这种情况下，最好是让同一个 Cat 构造函数所创建的所有对象共享一个 sayName 方法。 为了节省内存并保持简洁，我们可以在构造函数的 prototype 属性中添加方法。原型只是一个对象，构造函数所创建的所有对象都会保持对原型的引用。这些对象甚至可以将 prototype 的属性当作自身属性来使用！ JavaScript 利用对象与其原型之间的这个秘密链接来实现继承。请考虑以下原型链： 还记得吗，每个函数都有一个 prototype 属性，它其实只是一个对象。当使用 new 运算符将该函数作为构造函数来调用时，它会创建并返回一个新的对象。该对象被秘密地链接到其构造函数的 prototype，而这个秘密链接让该对象可以访问 prototype 的属性和方法，就像它自己的一样！ 由于我们知道 prototype 属性仅仅指向一个普通对象，因此这个对象本身也有一个秘密链接指向它的原型。而且，这个原型对象也有引用指向它自己的原型，以此类推。原型链就是这样形成的。 无论你是访问属性（例如 bailey.lives）还是调用方法（即 bailey.meow()），JavaScript 解释器都会按照特定的顺序在原型链中查找它们： 首先，JavaScript 引擎将查看对象自身的属性。这意味着，直接在该对象中定义的任何属性和方法将优先于其他位置的任何同名属性和方法（类似于作用域链中的变量阴影）。 如果找不到目标属性，它将搜索对象的构造函数的原型，以寻找匹配。 如果原型中不存在该属性，则 JavaScript 引擎将沿着该链继续查找。 该链的最顶端是 Object() 对象，也就是顶级父对象。如果 仍然 找不到该属性，则该属性为未定义。 之前，我们都是直接在构造函数中定义方法。让我们来看看，如果我们转而在构造函数的 prototype 中定义方法，情况又会如何！ function Dog(age, weight, name) { this.age = age; this.weight = weight; this.name = name; this.bark = function () { console.log(`${this.name} says woof!`); }; } 这是 Dog 构造函数，我们可以调用它来创建一个具有以下四种属性的对象：age, weight, name 和 bark， 可以在构造器中定义 bark 方法，我们也可以将 bark 方法移到 dog 的原型中，直接使用点记法来定义 bark，像这样: Dog.prototype.bark = function () { console.log(`${this.name} says woof!`); }; 函数就变为: function Dog(age, weight, name) { this.age = age; this.weight = weight; this.name = name; } Dog.prototype.bark = function () { console.log(`${this.name} says woof!`); }; 现在，我们将调用 dog 的构造函数来创建一个新的对象, 并调用这个新的 dog 的 bark方法: dog1 = new Dog(2, 60, &apos;Java&apos;); dog2 = new Dog(4, 55, &apos;Jodi&apos;); dog1.bark(); // Java says woof! dog2.bark(); // Jodi says woof! 让我们回顾一下，发生了什么？ 当我们在新建的 dog 对象中调用 bark 方法时，JavaScript 引擎会查看自己的属性，尝试找到与 bark 方法相匹配的名称，由于 bark 没有直接定义在这个 dog 上，它会看看 bark 方法的原型，最后，我们不需要调用 dog.prototype.bark()，我们只需要调用 dog.bark() 就会起作用，因为这个 dog 对象已经通过它的原型与 bark 方法联系起来了。 小练习 // (A) function Dalmatian (name) { this.name = name; this.bark = function() { console.log(`${this.name} barks!`); }; } // (B) function Dalmatian (name) { this.name = name; } Dalmatian.prototype.bark = function() { console.log(`${this.name} barks!`); }; 假设我们想定义一个可以在 Dalmatian 构造函数的实例（对象）上调用的方法（我们将会实例化至少 101 个对象！）。前面两种方式中的哪一种是最佳选择？ 参考答案： (B)是最佳选择，因为每次创建 Dalmatian 的实例时，将不需要重新创建 bark 所指向的函数。 替换 prototype 对象 如果完全替换某个函数的 prototype 对象，结果会怎样？这将如何影响该函数所创建的对象？让我们来看一个简单的 Hamster 构造函数，并实例化一些对象： function Hamster() { this.hasFur = true; }; let waffle = new Hamster(); let pancake = new Hamster(); 首先要注意的是，在创建新的对象 waffle 和 pancake 之后，我们仍然可以为 Hamster 的原型添加属性，而且它仍然可以访问这些新的属性。 Hamster.prototype.eat = function () { console.log(&apos;Chomp chomp chomp!&apos;); }; waffle.eat(); // &apos;Chomp chomp chomp!&apos; pancake.eat(); // &apos;Chomp chomp chomp!&apos; 现在，让我们将 Hamster 的 prototype 对象完全替换为其他内容： Hamster.prototype = { isHungry: false, color: &apos;brown&apos; }; 先前的对象无法访问更新后的原型的属性；它们只会保留与旧原型的秘密链接： console.log(waffle.color); // undefined waffle.eat(); // &apos;Chomp chomp chomp!&apos; console.log(pancake.isHungry); // undefined 事实证明，此后创建的任何新的 Hamster 对象都会使用更新后的原型： const muffin = new Hamster(); muffin.eat(); // TypeError: muffin.eat is not a function console.log(muffin.isHungry); // false console.log(muffin.color); // &apos;brown&apos; 检查对象的属性 正如我们刚刚所看到的，如果一个对象本身没有某个特定属性，它可以访问原型链中某个这样的属性（当然，假设它是存在的）。由于选择很多，有时可能会不好判断某个特定的属性究竟来自哪里！这里有一些有用的方法可以帮助你进行判断。 hasOwnProperty() hasOwnProperty() 可以帮助你找到某个特定属性的来源。在向其传入你要查找的属性名称的字符串后，该方法会返回一个布尔值，指示该属性是否属于该对象本身（即该属性 不是 被继承的）。请考虑在函数中直接定义一个属性的 Phone 构造函数，以及它的 prototype 对象的另一个属性： function Phone() { this.operatingSystem = &apos;Android&apos;; } Phone.prototype.screenSize = 6; 现在，让我们创建一个新的对象 myPhone，并检查 operatingSystem 是否为其本身的属性，也就是说，它不是从该对象的原型（或原型链上的其他地方）继承来的： const myPhone = new Phone(); const own = myPhone.hasOwnProperty(&apos;operatingSystem&apos;); console.log(own); //true 它确实返回为真！那么，Phone 对象的 prototype 上的 screenSize 属性又如何呢？ const inherited = myPhone.hasOwnProperty(&apos;screenSize&apos;); console.log(inherited); //false 使用 hasOwnProperty()，我们可以洞察某个属性的来源。 isPrototypeOf() 对象还可以访问 isPrototypeOf() 方法，该方法可以检查某个对象是否存在于另一个对象的原型链中。 使用这种方法，你可以确认某个特定的对象是否是另一个对象的原型。请看以下 rodent 对象： const rodent = { favoriteFood: &apos;cheese&apos;, hasTail: true }; 现在，让我们来构建一个 Mouse() 构造函数，并将它的 prototype 赋给 rodent： function Mouse() { this.favoriteFood = &apos;cheese&apos;; } Mouse.prototype = rodent; 如果我们创建一个新的 Mouse 对象，它的原型应该是 rodent 对象。让我们来确认一下： const ralph = new Mouse(); const result = rodent.isPrototypeOf(ralph) console.log(result); //true 太棒了！isPrototypeOf() 是确认某个对象是否存在于另一个对象的原型链中的好办法。 Object.getPrototypeOf() isPrototypeOf() 很有用处，但要记住，要想使用它，你必须首先掌握原型对象！如果你不确定某个对象的原型是什么呢？Object.getPrototypeOf() 可以帮助你解决这个问题。 使用前面的例子，让我们将 Object.getPrototypeOf() 的返回值存储在变量 myPrototype 中，然后检查它是什么： const myPrototype = Object.getPrototypeOf(ralph); console.log(myPrototype); //{ favoriteFood: &quot;cheese&quot;, hasTail: true } 太棒了！ralph 的原型 rodent 对象 与 返回的结果 具有相同的属性，因为它们就是同一个对象。 Object.getPrototypeOf() 很适合检索给定对象的原型。 constructor 属性 每次创建一个对象时，都会有一个特殊的属性被暗中分配给它：constructor。 访问一个对象的 constructor 属性会返回一个对创建该对象的构造函数的引用！ 以下是一个简单的 Longboard 构造函数。我们还会继续创建一个新的对象，然后将其保存到一个 board 变量中： function Longboard() { this.material = &apos;bamboo&apos;; } const board = new Longboard(); 如果我们访问 board 的 constructor 属性，我们应该会看到原来的构造函数本身： console.log(board.constructor); // function Longboard() { // this.material = &apos;bamboo&apos;; // } 好极了！请记住，如果某个对象是使用字面量表示法创建的，那么它的构造函数就是内置的 Object() 构造函数！ const rodent = { teeth: &apos;incisors&apos;, hasTail: true }; console.log(rodent.constructor); //function Object() { [native code] } 小练习 以下哪一项有关 hasOwnProperty() 的说法是正确的？请选择所有适用项： 一个对象会作为参数传递给 hasOwnProperty 它会返回一个布尔值，指示对象是否具有所指定的属性作为其本身属性(即该属性不是被继承的) 一个字符串不能作为参数传递给 hasOwnProperty() hasOwnProperty() 作为一个方法被调用到一个对象 参考答案： 2、4 以下哪一项有关 isProtypeOf() 或 getPrototypeOf() 的说法是正确的？请选择所有适用项： isProtypeOf() 可以检查某个对象是否存在于另一个对象的原型链中 isProtypeOf() 会接受一个参数：一个原型链将被搜索的对象 getProtypeOf() 在构造函数的一个实例(即单个对象本身)上被调用 getProtypeOf() 会返回传递给它的对象的原型 参考答案： 2、4 以下哪一项有关 constructor 属性的说法是正确的？请选择所有适用项： 访问一个对象的 constructor 属性会返回一个对创建该对象(实例)的构造函数的引用 constructor 属性的值只是构造函数名称的一个字符串，而不是该函数本身 每个对象都有一个 constructor 属性 使用字面量表示法创建的对象是用 Object() 构造函数构建的 参考答案： 1、3、4 假设我们使用常规的对象字面量表示法来创建以下对象 capitals：当 Object.getPrototypeOf(capitals); 被执行时，会返回什么？ const capitals = { California: &apos;Sacramento&apos;, Washington: &apos;Olympia&apos;, Oregon: &apos;Salem&apos;, Texas: &apos;Austin&apos; }; 参考答案： 对 Object() 原型的引用 小结 JavaScript 中的继承是指一个对象基于另一个对象。继承让我们可以重用现有的代码，使对象具有其他对象的属性。 当使用 new 运算符将一个函数作为构造函数来调用时，该函数会创建并返回一个新的对象。这个对象会被秘密链接到其构造函数的 prototype，而它只是另一个对象。使用这个秘密链接，可以让一个对象访问原型的属性和方法，就像是它自己的一样。如果 JavaScript 没有在某个对象中找到一个特定属性，它将在原型链上继续查找。如有必要，它会一路查找到 Object()（顶级父对象）。 对象如何查看对象的构造函数 –&gt; obj.constructor 属性 对象如何查看原型 –&gt; 隐式属性 __proto__ 修改原型 –&gt; obj.prototype.xxx = xxx (原型链的终端)绝大多数对象的最终原型: Object.prototype 为了更理解 原型 / 构造函数 / 实例 三者的关系，请看下面这张图： 123实例.__proto__ === 原型构造函数.prototype === 原型原型.constructorr === 构造函数 此外，我们还介绍了几个方法和属性，可以用于检查对象及其原型的来源和引用，即： hasOwnProperty() isPrototypeOf() Object.getPrototypeOf() constructor 在下一部分，我们将从子类化的角度来探索原型继承的另一方面。如果你想从一个对象中只继承几个属性，但是又想让这个对象具有其他专有属性，该怎么办呢？我们将在下一部分对原型继承进行更深入的探讨。 延伸 MDN 上的hasOwnProperty() MDN 上的isPropertyOf() MDN 上的Object.getPrototypeOf() MDN 上的constructor]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置自己的this]]></title>
    <url>%2F2019%2F02%2F28%2F%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[我们知道 根据函数的调用方式 this 会设成不同的值，Javascript 提供了几种设置 this值的方法: call() apply() bind() call 和 apply 作为方法在函数上被调用，会因为参数的传入方式不同而有所不同，bind 是返回新函数的方法. call call() 是一个直接调用到函数上的方法。我们传递给它一个单一的值，以设置为 this 的值，然后逐个传入该函数的任何参数，用逗号分隔。 请考虑以下函数 multiply()，它只会返回其两个参数的乘积： function multiply(n1, n2) { return n1 * n2; } 让我们在控制台中调用它： multiply(3, 4); // 12 这里没有任何惊喜！但现在，让我们使用 call() 方法来调用同一个函数： multiply.call(window, 3, 4); // 12 我们得到了相同的结果！这是怎么发生的？我们首先直接调用 call() 方法到 multiply() 函数上。请注意，.call(window, 3, 4) 之前的 multiply 后​​面没有任何括号！ call() 将会处理该调用 和 multiply() 函数的参数本身！ 这一步完成后，我们传递将设置为 this 的值作为 call() 的第一个参数：window。最后，我们逐个传递 multiply() 函数的参数，并用逗号分隔。 当 multiply.call(window, 3, 4); 执行后，该函数将以 this 的给定值被调用，我们所看到的结果就是 12。在严格模式之外，调用 multiply() 的这两种方式是等价的。 除了调用常规函数之外，我们如何调用附加到对象上的函数（即方法）呢？这是 call() 真正发挥强大功能的地方。使用 call() 来调用方法允许我们从对象中“借用”方法，然后将其用于另一个对象！请看以下对象 mockingbird： const mockingbird = { title: &apos;To Kill a Mockingbird&apos;, describe: function () { console.log(`${this.title} is a classic novel`); } }; 我们可以让 mockingbird 调用自己的 describe() 方法： mockingbird.describe(); // &apos;To Kill a Mockingbird is a classic novel&apos; 但是，借助 call()，以下 pride 对象可以使用 mockingbird 的 describe() 方法： const pride = { title: &apos;Pride and Prejudice&apos; }; mockingbird.describe.call(pride); // &apos;Pride and Prejudice is a classic novel&apos; 让我们来分析一下当 mockingbird.describe.call(pride); 被执行时，究竟发生了什么！首先，call() 方法被调用到 mockingbird.describe（它指向一个函数）上。然后，this 的值被传递给 call() 方法：pride。 由于 mockingbird 的 describe() 方法引用了 this.title，我们需要访问 this 所指向的对象的 title 属性。但是，由于我们已经设置了自己的 this 的值，this.title 的值将会从 pride 对象中被访问！结果，mockingbird.describe.call(pride); 被执行，我们在控制台中看到 &#39;Pride and Prejudice is a classic novel&#39;。 如果你打算在传递给它的第一个参数的作用域内调用一个函数，那么 call() 是非常有效的。同样，我们可以利用 apply() 方法达到相同的目的，尽管在参数传入的方式上有所不同。让我们来仔细看看！ apply 就像 call() 一样，apply() 在一个函数上被调用，不仅可以调用该函数，而且还可以为它关联一个特定的 this 值。但是，apply() 并不是逐个传递参数并用逗号分隔，而是将函数的参数放在一个_数组_中。请回想一下之前的 multiply() 函数： function multiply(n1, n2) { return n1 * n2; } 我们使用了 call()，并逐个传递参数： multiply.call(window, 3, 4); // 12 然而，使用 apply()，我们则是将 multiply() 函数的所有参数收集到一个数组中，然后再将这个数组传递给 apply()： 太棒了！那么，使用 apply() 来调用对象的方法，又会怎样呢？请回想一下之前的 mockingbird 和 pride 对象： const mockingbird = { title: &apos;To Kill a Mockingbird&apos;, describe: function () { console.log(`${this.title} is a classic novel`); } }; const pride = { title: &apos;Pride and Prejudice&apos; }; 之前，我们使用了 call() 来允许 pride 对象”借用” mockingbird 的 describe() 方法： mockingbird.describe.call(pride); // &apos;Pride and Prejudice is a classic novel&apos; 我们可以使用 apply() 来达到相同的结果！ mockingbird.describe.apply(pride); // &apos;Pride and Prejudice is a classic novel&apos; 请注意，传递给 call() 和 apply() 的第一个参数是相同的（即绑定 this 值的对象）。由于 describe() 方法不接受任何参数，因此 mockingbird.describe.call(pride); 和 mockingbird.describe.apply(pride); 唯一的区别就是方法！这两种方法都会产生相同的结果。 偏向选择其中一种方法 call() 和 apply() 都会在其传入的第一个参数（即作为 this 值的对象）的作用域内调用一个函数。那么，你什么时候会偏向于选择 call()，或偏向于选择 apply() 呢？ 如果你事先并不知道函数所需要的参数个数，那么 call() 的使用可能会受到限制。在这种情况下，apply() 是一个更好的选择，因为它只接受一个参数数组，然后将其解包并传递给函数。请记住，解包可能会略微影响性能，但这种影响并不显著。 小练习 请考虑以下 dave 对象和 sayHello() 函数： const dave = { name: &apos;Dave&apos; }; function sayHello(message) { console.log(`${message}, ${this.name}. You&apos;re looking well today.`); } 假设你想将消息 &#39;Hello, Dave. You&#39;re looking well today.&#39; 输出到控制台。你应该编写哪个表达式来达到这个目的？ 参考答案： sayHello.apply(dave, [‘Hello’]); 请考虑以下 Andrew 和 Richard 对象： const Andrew = { name: &apos;Andrew&apos;, introduce: function () { console.log(`Hi, my name is ${this.name}!`); } }; const Richard = { name: &apos;Richard&apos;, introduce: function () { console.log(`Hello there! I&apos;m ${this.name}.`); } }; 当 Richard.introduce.call(Andrew); 被执行时，什么会被记录到控制台？ 参考答案： &#39;Hello there! I&#39;m Andrew.&#39; 请考虑以下代码： const andrew = { name: &apos;Andrew&apos; }; function introduce(language) { console.log(`I&apos;m ${this.name} and my favorite programming language is ${language}.`); } 请编写一个表达式，使用 call() 方法产生以下消息：&#39;I&#39;m Andrew and my favorite programming language is JavaScript.&#39; 参考答案： introduce.call(andrew,&#39;JavaScript&#39;) 回调和 this 当涉及到回调函数时，this 的值有一些潜在的作用域问题，事情会变得比较棘手。接下来，让我们来看看这个问题。 function invokeTwice(cb) { cb(); cb(); } const dog = { age: 5, growOneYear: function () { this.age += 1; } }; 首先，调用 growOneYear() 按预期运作，将 dog 对象的 age 属性的值从 5 更新为 6： dog.growOneYear(); // undefined dog.age; // 6 但是，将 dog.growOneYear（一个函数）作为参数传递给 invokeTwice() 则会产生不希望的结果： invokeTwice(dog.growOneYear); // undefined dog.age; // 6 这是什么原因呢？事实证明，invokeTwice() 确实会调用 growOneYear，但它是被调用为一个 函数而不是一个方法！让我们回顾一下先前的 this 网格： Call Style new method function this {} object itself global object Example new Cat() bailey.sayName() introduce() 如果使用 new 运算符来调用构造函数，this 的值将被设置为新创建的对象，如果在对象上调用方法，this 将被设置为该对象本身，如果简单地调用一个函数，this 将被设置为全局对象: window 使用匿名闭包来保存 this 还记得吗，简单地调用一个普通函数会将 this 的值设置为全局对象（即 window）。我们如何解决这个问题呢？ 解决这个问题的一种方式就是使用一个匿名闭包来遮蔽 dog 对象： invokeTwice(function () { dog.growOneYear(); }); dog.age // 7 使用这种方式，调用 invokeTwice() 仍然会将 this 的值设置为 window。但是，这对闭包没有影响；在匿名函数中，growOneYear() 方法仍然会被直接调用到 dog 对象上。因此，dog 的 age 属性的值会从 5 更新为 7。 由于这是一种十分常见的模式，因此 JavaScript 提供了另一种比较简洁的方式：bind() 方法。 使用 bind() 来保存 this 与 call() 和 apply() 类似，bind() 方法也允许用户直接为 this 定义一个值。bind() 也是一个在函数上调用的方法，但不同于 call() 或 apply()，它们都会立即调用函数——bind() 会返回一个新的函数。当被调用时，该函数会将 this 设置为我们赋给它的值。 const dog = { age: 5, growOneYear: function () { this.age += 1; } } function invokeTwice(cb) { cb(); cb(); } invokeTwice(dog.growOneYear); // undefined 因为bind() 会返回一个新的函数，将其保存在新的变量中，称之为 myGrow const myGrow = dog.growOneYear.bind(dog); // undefined invokeTwice(myGrow); // undefined dog.age; // 7 小练习 请考虑以下 driver 和 car 对象： const driver = { name: &apos;Danica&apos;, displayName: function () { console.log(`Name: ${this.name}`); } }; const car = { name: &apos;Fusion&apos; }; 请使用 bind() 编写一个表达式，让我们可以从 driver 中”借用” displayName() 方法，以供 car 对象使用。 参考答案： driver.displayName.bind(car) 小结 JavaScript 提供了三种方法，让我们可以为一个给定的函数设置 this 的值： call() 会调用该函数，逐个传入参数，并用逗号分隔。 apply() 与 call() 类似；它会照样调用该函数，但它会将参数作为一个数组传入。 bind() 会返回一个新的函数，并将 this 绑定到一个特定对象，让我们可以按照函数的样式来调用它。如需进一步研究，我们建议你查看 Kyle Simpson 有关 this 的你不了解 JS 系列，链接已在下方提供。 到目前为止，你已经看到函数、对象和 this 关键字是如何相互关联的。你也看到了 JavaScript 中的几乎所有东西都是一个对象！你知道吗，你甚至可以将对象建立在其他对象上！这是原型继承背后的主要思想。通过实现它，对象可以接受其他对象的属性。接下来，我们将探索这一切，以及更多知识！ 延伸 你不知道的JavaScript（上卷） 你不知道的JavaScript（中卷） 你不知道的 JavaScript（下卷） MDN 上的call() MDN 上的apply() MDN 上的bind()]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 的 this 用法]]></title>
    <url>%2F2019%2F02%2F28%2FJavascript-%E7%9A%84-this-%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[this 是 JavaScript 语言的一个关键字。 构造函数中的 this 在上一部分，我们使用了方法中的 this 来访问该方法所属的 对象。让我们再来看一个例子： function Cat(name) { this.name = name this.lives = 9; this.sayName = function () { console.log( &apos;Meow! My name is &apos; + this.name); }; } const bailey = new Cat(); 在上面的 Cat() 构造函数中，sayName 所指向的函数引用了 this.name。之前，我们已经看到过在方法中使用 this，但在这里，this 是指什么呢？ 事实证明，当使用 new 运算符来调用构造函数时，this 会被设置为新创建的对象！让我们来看看新的 bailey 对象是什么样的： { name: Bailey, sayName: function () { console.log(&apos;Meow! My name is &apos; + this.name); } } 在以上代码段中，请注意 this 位于构造函数 外部。正如我们在上一篇文章中所看到的，当你说 this 时，你其实是在说“这个对象”或“当前对象”。因此，sayName() 方法可以使用 this 来访问该对象的 name 属性！这使得以下方法调用成为可能： bailey.sayName(); // Meow! My name is Bailey this 什么时候会被赋值？ 一个常见的误解是，this 指向定义它的对象。事实并非如此！直到某个对象调用使用 this 的方法，this 才会被赋值。换句话说，赋给 this 的值取决于 调用定义 this 的方法的对象。让我们来看一个例子： const dog = { bark: function () { console.log(&apos;Woof!&apos;); }, barkTwice: function () { this.bark(); this.bark(); } }; 让我们继续调用 dog 的两个方法： dog.bark(); // Woof! dog.barkTwice(); // Woof! // Woof! 我们知道，当我们调用 dog.bark() 或 dog.barkTwice() 时，变量 this 将被设置。由于 this 可以访问调用它的对象，因此 barkTwice 可以使用 this 来访问包含 bark 方法的 dog 对象。但是，如果我们在 barkTwice 中使用 bark()，而不是 this.bark()，将会怎样？该函数会先在 barkTwice 的作用域内查找一个名为 bark 的局部变量。如果没有找到 bark，则会沿着作用域链继续查找。综合来看：this.bark() 会告诉 barkTwice 查看 dog（调用该方法的对象）以查找 bark。 this 会被设置为什么？ 到目前为止，我们已经在许多不同的上下文中看到了 this，比如在方法中，或被构造函数引用。现在，让我们把它们放在一起来看一下！有四种方式可以调用函数，而每种方式都会不同地设置 this。 首先，使用 new 关键字来调用构造函数会将 this 设置为一个新创建的对象。还记得吗，在我们之前创建 Cat() 的实例时，this 被设置为新的 bailey 对象。 另一方面，调用属于一个对象的函数（即_方法_）会将 this 设置为该对象本身。回想一下前面的示例，dog 对象的 barkTwice 方法能够访问 dog 本身的属性。 第三，单独调用一个函数（即简单地调用一个常规函数）将把 this 设置为 window。如果主机环境是浏览器，则它将是全局对象。 function funFunction() { return this; } funFunction(); // (返回全局对象, `window`) 第四种调用函数的方式可以让我们自己设置 this！现在不用在意这一点，我们将在下一部分进行深入探讨。 Call Style new method function this {} object itself global object Example new Cat() bailey.sayName() introduce() 如果使用 new 运算符来调用构造函数，this 的值将被设置为新创建的对象，如果在对象上调用方法，this 将被设置为该对象本身，如果简单地调用一个函数，this 将被设置为全局对象: window 小练习 请考虑以下构造函数 City： function City(name, population) { this.name = name; this.population = population; this.identify = function () { console.log(`${this.name}&apos;s population is ${this.population}.`); }; } 当 const sanFrancisco = new City(&#39;San Francisco&#39;, 870000); 被执行时，this 的值是什么？ 答案： 新创建的对象，被 sanFrancisco 引用 请考虑以下对象 building： const building = { floors: 5, addFloor: function () { this.floors += 1; } }; building.addFloor(); 当 building.addFloor() 被执行时，this 的值是什么？ 答案： building 当以下函数被调用时，this 的值是多少？ function myFunction() { console.log(&quot;What is the value of &apos;this&apos;?&quot;); } 答案： window 小结 函数、对象和 this 彼此相互关联。当使用 new 运算符来调用构造函数时，this 变量会被设置为新创建的对象。当在对象上调用方法时，this 会被设置为该对象本身。当在浏览器环境中调用函数时，this 会被设置为 window，也被称为全局对象。 除此之外，还有一组方式可以调用函数：使用 apply() 和使用 call()。这两种方式有许多相似之处，每一种方式都允许我们指定如何设置 this。接下来，我们会对它们进行详细分析！]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数]]></title>
    <url>%2F2019%2F02%2F28%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[创建对象的一个重要方式是使用构造函数，构造函数以大写字母开头，构造函数必须始终使用特殊关键字 new 来调用，与普通函数的区别是：普通函数必须创建将返回的对象并直接修改该对象，而构造函数会自动创建对象，然后，为了向此对象中添加属性或方法，需要使用特殊的关键字 this。 要实例化（即 创建 ）一个新的对象，我们可以使用 new 运算符来调用这个函数：new SoftwareDeveloper(); 构造函数：结构和语法 function SoftwareDeveloper() { this.favoriteLanguage = &apos;JavaScript&apos;; } 首先，构造函数并不声明局部变量，而是使用 this 关键字来保存数据。以上函数将为所创建的任何对象添加一个 favoriteLanguage 属性，并为其分配一个默认值 ‘JavaScript’。现在不用太在意构造函数中的 this；只要知道 this 是指在构造函数前面使用 new 关键字创建的新对象即可。我们很快就会详细介绍这个 this！最后一点比较特别的是，这个函数似乎不会返回任何东西！JavaScript 中的构造函数不应该有一个显式的返回值（即使用 return 语句）。 创建一个新的对象 正如我们在上面看到的，让我们使用 new 运算符来创建一个新的对象： let developer = new SoftwareDeveloper(); 我们已经把这个调用的返回值保存到了变量 developer 中。让我们执行 console.log(developer); 将这个 SoftwareDeveloper 对象记录到控制台： console.log(developer); // SoftwareDeveloper {favoriteLanguage: &quot;JavaScript&quot;} 用对象字面量的方式来创建对象，看看有何不同 let orderDeveloper = { favoriteLanguage: &apos;JavaScript&apos; }; otherDeveloper; // { favoriteLanguage: &quot;JavaScript&quot; } 可以看出 与 developer 相比，创建对象的构造函数 SoftwareDeveloper 没有列在Chrome 开发者工具中；在 Chrome 开发者工具中 构造函数通常显示在 {} 前面；developer 的构造函数是 SoftwareDeveloper，而 orderDeveloper 的构造函数是 object 构造函数；比较之下，两者原型将有所不同。 构造函数可以有参数 与常规函数一样，使用构造函数的一个好处是它们也可以接受参数。让我们更新以上构造函数来接受一个参数，并为其分配 name 属性： function SoftwareDeveloper(name) { this.favoriteLanguage = &apos;JavaScript&apos;; this.name = name; } 在更新的 SoftwareDeveloper() 函数中，无论传入函数的值是什么，它都将是对象的 name 属性的值。让我们来看看： let instructor = new SoftwareDeveloper(&apos;Andrew&apos;); console.log(instructor); // SoftwareDeveloper { favoriteLanguage: &apos;JavaScript&apos;, name: &apos;Andrew&apos; } 正如我们在上面看到的，我们可以使用相同的构造函数来创建不同的对象： let teacher = new SoftwareDeveloper(&apos;Richard&apos;); console.log(teacher); // SoftwareDeveloper { favoriteLanguage: &apos;JavaScript&apos;, name: &apos;Richard&apos; } 构造函数的好处是，我们可以调用相同的构造函数，创建无数个实例或对象。 省略 new 运算符 如果你无意中 没有 使用 new 运算符来调用构造函数，会发生什么？ function SoftwareDeveloper(name) { this.favoriteLanguage = &apos;JavaScript&apos;; this.name = name; } let coder = SoftwareDeveloper(&apos;David&apos;); console.log(coder); // undefined 这是怎么回事？如果不使用 new 运算符，则不会创建对象。该函数会像任何其他常规函数一样被调用。由于该函数不会 _返回_ 任何东西（除了所有函数都会默认返回的 undefined 之外），因此 coder 变量最终会被分配给 undefined。 还有一点需要注意：由于这个函数作为一个常规函数被调用，因此 this 的值也会截然不同。现在不用太在意这一点，我们将在下一部分深入探讨 this 关键字！ 查看对象的构造函数(instanceof) 如果我们想查看某个对象是否是用构造函数创建的呢？我们可以使用 instanceof（它会返回一个布尔值）来窥见一些端倪。让我们来看看吧！ function Developer(name){ this.name = name; } const dev = new Developer(&apos;Veronkia&apos;); typeof dev; // &quot;object&quot; dev instanceof Developer; // true instanceof 和原型链 在以上示例中，instanceof 确认一个特定的构造函数确实创建了一个特定的对象。我们知道这一点，是因为我们在调用 Developer() 构造函数之后直接实例化了 dev 对象。 然而，很多时候并没有这么简单：instanceof 运算符实际上会测试构造函数是否出现在某个对象的原型链中。这意味着，虽然我们不是总能检查到底是 哪个构造函数 创建了该对象，但是它使我们能够洞察某个对象可能访问哪些其他的属性和方法。 小结 JavaScript 的类系统是直接使用函数和对象来构建的。使用 new 运算符来调用构造函数可以实例化一个新的对象。相同的构造函数可以用于创建不同的对象。 我们在整篇中广泛讨论了函数、对象和 this。事实证明，这三者是密切相关的！ 我们将在下一部分深入探讨 this 关键字，并仔细分析这三者之间的关系。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Constructor</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Multiple hexo personalization settingsMore info: settings]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
