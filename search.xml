<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设置自己的this]]></title>
    <url>%2F2019%2F02%2F28%2F%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[我们知道 根据函数的调用方式 this 会设成不同的值，Javascript 提供了几种设置 this值的方法: call() apply() bind() call 和 apply 作为方法在函数上被调用，会因为参数的传入方式不同而有所不同，bind 是返回新函数的方法， call call() 是一个直接调用到函数上的方法。我们传递给它一个单一的值，以设置为 this 的值，然后逐个传入该函数的任何参数，用逗号分隔。 请考虑以下函数 multiply()，它只会返回其两个参数的乘积： function multiply(n1, n2) { return n1 * n2; } 让我们在控制台中调用它： multiply(3, 4); // 12 这里没有任何惊喜！但现在，让我们使用 call() 方法来调用同一个函数： multiply.call(window, 3, 4); // 12 我们得到了相同的结果！这是怎么发生的？我们首先直接调用 call() 方法到 multiply() 函数上。请注意，.call(window, 3, 4) 之前的 multiply 后​​面没有任何括号！ call() 将会处理该调用 和 multiply() 函数的参数本身！ 这一步完成后，我们传递将设置为 this 的值作为 call() 的第一个参数：window。最后，我们逐个传递 multiply() 函数的参数，并用逗号分隔。 当 multiply.call(window, 3, 4); 执行后，该函数将以 this 的给定值被调用，我们所看到的结果就是 12。在严格模式之外，调用 multiply() 的这两种方式是等价的。 除了调用常规函数之外，我们如何调用附加到对象上的函数（即方法）呢？这是 call() 真正发挥强大功能的地方。使用 call() 来调用方法允许我们从对象中“借用”方法，然后将其用于另一个对象！请看以下对象 mockingbird： const mockingbird = { title: &apos;To Kill a Mockingbird&apos;, describe: function () { console.log(`${this.title} is a classic novel`); } }; 我们可以让 mockingbird 调用自己的 describe() 方法： mockingbird.describe(); // &apos;To Kill a Mockingbird is a classic novel&apos; 但是，借助 call()，以下 pride 对象可以使用 mockingbird 的 describe() 方法： const pride = { title: &apos;Pride and Prejudice&apos; }; mockingbird.describe.call(pride); // &apos;Pride and Prejudice is a classic novel&apos; 让我们来分析一下当 mockingbird.describe.call(pride); 被执行时，究竟发生了什么！首先，call() 方法被调用到 mockingbird.describe（它指向一个函数）上。然后，this 的值被传递给 call() 方法：pride。 由于 mockingbird 的 describe() 方法引用了 this.title，我们需要访问 this 所指向的对象的 title 属性。但是，由于我们已经设置了自己的 this 的值，this.title 的值将会从 pride 对象中被访问！结果，mockingbird.describe.call(pride); 被执行，我们在控制台中看到 &#39;Pride and Prejudice is a classic novel&#39;。 如果你打算在传递给它的第一个参数的作用域内调用一个函数，那么 call() 是非常有效的。同样，我们可以利用 apply() 方法达到相同的目的，尽管在参数传入的方式上有所不同。让我们来仔细看看！ apply 就像 call() 一样，apply() 在一个函数上被调用，不仅可以调用该函数，而且还可以为它关联一个特定的 this 值。但是，apply() 并不是逐个传递参数并用逗号分隔，而是将函数的参数放在一个_数组_中。请回想一下之前的 multiply() 函数： function multiply(n1, n2) { return n1 * n2; } 我们使用了 call()，并逐个传递参数： multiply.call(window, 3, 4); // 12 然而，使用 apply()，我们则是将 multiply() 函数的所有参数收集到一个数组中，然后再将这个数组传递给 apply()： 太棒了！那么，使用 apply() 来调用对象的方法，又会怎样呢？请回想一下之前的 mockingbird 和 pride 对象： const mockingbird = { title: &apos;To Kill a Mockingbird&apos;, describe: function () { console.log(`${this.title} is a classic novel`); } }; const pride = { title: &apos;Pride and Prejudice&apos; }; 之前，我们使用了 call() 来允许 pride 对象”借用” mockingbird 的 describe() 方法： mockingbird.describe.call(pride); // &apos;Pride and Prejudice is a classic novel&apos; 我们可以使用 apply() 来达到相同的结果！ mockingbird.describe.apply(pride); // &apos;Pride and Prejudice is a classic novel&apos; 请注意，传递给 call() 和 apply() 的第一个参数是相同的（即绑定 this 值的对象）。由于 describe() 方法不接受任何参数，因此 mockingbird.describe.call(pride); 和 mockingbird.describe.apply(pride); 唯一的区别就是方法！这两种方法都会产生相同的结果。 偏向选择其中一种方法 call() 和 apply() 都会在其传入的第一个参数（即作为 this 值的对象）的作用域内调用一个函数。那么，你什么时候会偏向于选择 call()，或偏向于选择 apply() 呢？ 如果你事先并不知道函数所需要的参数个数，那么 call() 的使用可能会受到限制。在这种情况下，apply() 是一个更好的选择，因为它只接受一个参数数组，然后将其解包并传递给函数。请记住，解包可能会略微影响性能，但这种影响并不显著。 小练习 请考虑以下 dave 对象和 sayHello() 函数： const dave = { name: &apos;Dave&apos; }; function sayHello(message) { console.log(`${message}, ${this.name}. You&apos;re looking well today.`); } 假设你想将消息 &#39;Hello, Dave. You&#39;re looking well today.&#39; 输出到控制台。你应该编写哪个表达式来达到这个目的？ 参考答案： sayHello.apply(dave, [‘Hello’]); 请考虑以下 Andrew 和 Richard 对象： const Andrew = { name: &apos;Andrew&apos;, introduce: function () { console.log(`Hi, my name is ${this.name}!`); } }; const Richard = { name: &apos;Richard&apos;, introduce: function () { console.log(`Hello there! I&apos;m ${this.name}.`); } }; 当 Richard.introduce.call(Andrew); 被执行时，什么会被记录到控制台？ 参考答案： &#39;Hello there! I&#39;m Andrew.&#39; 请考虑以下代码： const andrew = { name: &apos;Andrew&apos; }; function introduce(language) { console.log(`I&apos;m ${this.name} and my favorite programming language is ${language}.`); } 请编写一个表达式，使用 call() 方法产生以下消息：&#39;I&#39;m Andrew and my favorite programming language is JavaScript.&#39; 参考答案： introduce.call(andrew,&#39;JavaScript&#39;) 回调和 this 当涉及到回调函数时，this 的值有一些潜在的作用域问题，事情会变得比较棘手。接下来，让我们来看看这个问题。 function invokeTwice(cb) { cb(); cb(); } const dog = { age: 5, growOneYear: function () { this.age += 1; } }; 首先，调用 growOneYear() 按预期运作，将 dog 对象的 age 属性的值从 5 更新为 6： dog.growOneYear(); // undefined dog.age; // 6 但是，将 dog.growOneYear（一个函数）作为参数传递给 invokeTwice() 则会产生不希望的结果： invokeTwice(dog.growOneYear); // undefined dog.age; // 6 这是什么原因呢？事实证明，invokeTwice() 确实会调用 growOneYear，但它是被调用为一个 函数而不是一个方法！让我们回顾一下先前的 this 网格： Call Style new method function this {} object itself global object Example new Cat() bailey.sayName() introduce() 如果使用 new 运算符来调用构造函数，this 的值将被设置为新创建的对象，如果在对象上调用方法，this 将被设置为该对象本身，如果简单地调用一个函数，this 将被设置为全局对象: window 使用匿名闭包来保存 this 还记得吗，简单地调用一个普通函数会将 this 的值设置为全局对象（即 window）。我们如何解决这个问题呢？ 解决这个问题的一种方式就是使用一个匿名闭包来遮蔽 dog 对象： invokeTwice(function () { dog.growOneYear(); }); dog.age // 7 使用这种方式，调用 invokeTwice() 仍然会将 this 的值设置为 window。但是，这对闭包没有影响；在匿名函数中，growOneYear() 方法仍然会被直接调用到 dog 对象上。因此，dog 的 age 属性的值会从 5 更新为 7。 由于这是一种十分常见的模式，因此 JavaScript 提供了另一种比较简洁的方式：bind() 方法。 使用 bind() 来保存 this 与 call() 和 apply() 类似，bind() 方法也允许用户直接为 this 定义一个值。bind() 也是一个在函数上调用的方法，但不同于 call() 或 apply()，它们都会立即调用函数——bind() 会返回一个新的函数。当被调用时，该函数会将 this 设置为我们赋给它的值。 const dog = { age: 5, growOneYear: function () { this.age += 1; } } function invokeTwice(cb) { cb(); cb(); } invokeTwice(dog.growOneYear); // undefined 因为bind() 会返回一个新的函数，将其保存在新的变量中，称之为 myGrow const myGrow = dog.growOneYear.bind(dog); // undefined invokeTwice(myGrow); // undefined dog.age; // 7 小练习 请考虑以下 driver 和 car 对象： const driver = { name: &apos;Danica&apos;, displayName: function () { console.log(`Name: ${this.name}`); } }; const car = { name: &apos;Fusion&apos; }; 请使用 bind() 编写一个表达式，让我们可以从 driver 中”借用” displayName() 方法，以供 car 对象使用。 参考答案： driver.displayName.bind(car) 小结 JavaScript 提供了三种方法，让我们可以为一个给定的函数设置 this 的值： call() 会调用该函数，逐个传入参数，并用逗号分隔。 apply() 与 call() 类似；它会照样调用该函数，但它会将参数作为一个数组传入。 bind() 会返回一个新的函数，并将 this 绑定到一个特定对象，让我们可以按照函数的样式来调用它。如需进一步研究，我们建议你查看 Kyle Simpson 有关 this 的你不了解 JS 系列，链接已在下方提供。 到目前为止，你已经看到函数、对象和 this 关键字是如何相互关联的。你也看到了 JavaScript 中的几乎所有东西都是一个对象！你知道吗，你甚至可以将对象建立在其他对象上！这是原型继承背后的主要思想。通过实现它，对象可以接受其他对象的属性。接下来，我们将探索这一切，以及更多知识！ 友情链接 你不知道的JavaScript（上卷） 你不知道的JavaScript（中卷） 你不知道的 JavaScript（下卷） MDN 上的call() MDN 上的apply() MDN 上的bind()]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 的 this 用法]]></title>
    <url>%2F2019%2F02%2F28%2FJavascript-%E7%9A%84-this-%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[this 是 JavaScript 语言的一个关键字。 构造函数中的 this 在上一部分，我们使用了方法中的 this 来访问该方法所属的 对象。让我们再来看一个例子： function Cat(name) { this.name = name this.lives = 9; this.sayName = function () { console.log( &apos;Meow! My name is &apos; + this.name); }; } const bailey = new Cat(); 在上面的 Cat() 构造函数中，sayName 所指向的函数引用了 this.name。之前，我们已经看到过在方法中使用 this，但在这里，this 是指什么呢？ 事实证明，当使用 new 运算符来调用构造函数时，this 会被设置为新创建的对象！让我们来看看新的 bailey 对象是什么样的： { name: Bailey, sayName: function () { console.log(&apos;Meow! My name is &apos; + this.name); } } 在以上代码段中，请注意 this 位于构造函数 外部。正如我们在上一篇文章中所看到的，当你说 this 时，你其实是在说“这个对象”或“当前对象”。因此，sayName() 方法可以使用 this 来访问该对象的 name 属性！这使得以下方法调用成为可能： bailey.sayName(); // Meow! My name is Bailey this 什么时候会被赋值？ 一个常见的误解是，this 指向定义它的对象。事实并非如此！直到某个对象调用使用 this 的方法，this 才会被赋值。换句话说，赋给 this 的值取决于 调用定义 this 的方法的对象。让我们来看一个例子： const dog = { bark: function () { console.log(&apos;Woof!&apos;); }, barkTwice: function () { this.bark(); this.bark(); } }; 让我们继续调用 dog 的两个方法： dog.bark(); // Woof! dog.barkTwice(); // Woof! // Woof! 我们知道，当我们调用 dog.bark() 或 dog.barkTwice() 时，变量 this 将被设置。由于 this 可以访问调用它的对象，因此 barkTwice 可以使用 this 来访问包含 bark 方法的 dog 对象。但是，如果我们在 barkTwice 中使用 bark()，而不是 this.bark()，将会怎样？该函数会先在 barkTwice 的作用域内查找一个名为 bark 的局部变量。如果没有找到 bark，则会沿着作用域链继续查找。综合来看：this.bark() 会告诉 barkTwice 查看 dog（调用该方法的对象）以查找 bark。 this 会被设置为什么？ 到目前为止，我们已经在许多不同的上下文中看到了 this，比如在方法中，或被构造函数引用。现在，让我们把它们放在一起来看一下！有四种方式可以调用函数，而每种方式都会不同地设置 this。 首先，使用 new 关键字来调用构造函数会将 this 设置为一个新创建的对象。还记得吗，在我们之前创建 Cat() 的实例时，this 被设置为新的 bailey 对象。 另一方面，调用属于一个对象的函数（即_方法_）会将 this 设置为该对象本身。回想一下前面的示例，dog 对象的 barkTwice 方法能够访问 dog 本身的属性。 第三，单独调用一个函数（即简单地调用一个常规函数）将把 this 设置为 window。如果主机环境是浏览器，则它将是全局对象。 function funFunction() { return this; } funFunction(); // (返回全局对象, `window`) 第四种调用函数的方式可以让我们自己设置 this！现在不用在意这一点，我们将在下一部分进行深入探讨。 Call Style new method function this {} object itself global object Example new Cat() bailey.sayName() introduce() 如果使用 new 运算符来调用构造函数，this 的值将被设置为新创建的对象，如果在对象上调用方法，this 将被设置为该对象本身，如果简单地调用一个函数，this 将被设置为全局对象: window 小练习 请考虑以下构造函数 City： function City(name, population) { this.name = name; this.population = population; this.identify = function () { console.log(`${this.name}&apos;s population is ${this.population}.`); }; } 当 const sanFrancisco = new City(&#39;San Francisco&#39;, 870000); 被执行时，this 的值是什么？ 答案： 新创建的对象，被 sanFrancisco 引用 请考虑以下对象 building： const building = { floors: 5, addFloor: function () { this.floors += 1; } }; building.addFloor(); 当 building.addFloor() 被执行时，this 的值是什么？ 答案： building 当以下函数被调用时，this 的值是多少？ function myFunction() { console.log(&quot;What is the value of &apos;this&apos;?&quot;); } 答案： window 小结 函数、对象和 this 彼此相互关联。当使用 new 运算符来调用构造函数时，this 变量会被设置为新创建的对象。当在对象上调用方法时，this 会被设置为该对象本身。当在浏览器环境中调用函数时，this 会被设置为 window，也被称为全局对象。 除此之外，还有一组方式可以调用函数：使用 apply() 和使用 call()。这两种方式有许多相似之处，每一种方式都允许我们指定如何设置 this。接下来，我们会对它们进行详细分析！]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数]]></title>
    <url>%2F2019%2F02%2F28%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[创建对象的一个重要方式是使用构造函数，构造函数以大写字母开头，构造函数必须始终使用特殊关键字 new 来调用，与普通函数的区别是：普通函数必须创建将返回的对象并直接修改该对象，而构造函数会自动创建对象，然后，为了向此对象中添加属性或方法，需要使用特殊的关键字 this。 要实例化（即 创建 ）一个新的对象，我们可以使用 new 运算符来调用这个函数：new SoftwareDeveloper(); 构造函数：结构和语法 function SoftwareDeveloper() { this.favoriteLanguage = &apos;JavaScript&apos;; } 首先，构造函数并不声明局部变量，而是使用 this 关键字来保存数据。以上函数将为所创建的任何对象添加一个 favoriteLanguage 属性，并为其分配一个默认值 ‘JavaScript’。现在不用太在意构造函数中的 this；只要知道 this 是指在构造函数前面使用 new 关键字创建的新对象即可。我们很快就会详细介绍这个 this！最后一点比较特别的是，这个函数似乎不会返回任何东西！JavaScript 中的构造函数不应该有一个显式的返回值（即使用 return 语句）。 创建一个新的对象 正如我们在上面看到的，让我们使用 new 运算符来创建一个新的对象： let developer = new SoftwareDeveloper(); 我们已经把这个调用的返回值保存到了变量 developer 中。让我们执行 console.log(developer); 将这个 SoftwareDeveloper 对象记录到控制台： console.log(developer); // SoftwareDeveloper {favoriteLanguage: &quot;JavaScript&quot;} 用对象字面量的方式来创建对象，看看有何不同 let orderDeveloper = { favoriteLanguage: &apos;JavaScript&apos; }; otherDeveloper; // { favoriteLanguage: &quot;JavaScript&quot; } 可以看出 与 developer 相比，创建对象的构造函数 SoftwareDeveloper 没有列在Chrome 开发者工具中；在 Chrome 开发者工具中 构造函数通常显示在 {} 前面；developer 的构造函数是 SoftwareDeveloper，而 orderDeveloper 的构造函数是 object 构造函数；比较之下，两者原型将有所不同。 构造函数可以有参数 与常规函数一样，使用构造函数的一个好处是它们也可以接受参数。让我们更新以上构造函数来接受一个参数，并为其分配 name 属性： function SoftwareDeveloper(name) { this.favoriteLanguage = &apos;JavaScript&apos;; this.name = name; } 在更新的 SoftwareDeveloper() 函数中，无论传入函数的值是什么，它都将是对象的 name 属性的值。让我们来看看： let instructor = new SoftwareDeveloper(&apos;Andrew&apos;); console.log(instructor); // SoftwareDeveloper { favoriteLanguage: &apos;JavaScript&apos;, name: &apos;Andrew&apos; } 正如我们在上面看到的，我们可以使用相同的构造函数来创建不同的对象： let teacher = new SoftwareDeveloper(&apos;Richard&apos;); console.log(teacher); // SoftwareDeveloper { favoriteLanguage: &apos;JavaScript&apos;, name: &apos;Richard&apos; } 构造函数的好处是，我们可以调用相同的构造函数，创建无数个实例或对象。 省略 new 运算符 如果你无意中 没有 使用 new 运算符来调用构造函数，会发生什么？ function SoftwareDeveloper(name) { this.favoriteLanguage = &apos;JavaScript&apos;; this.name = name; } let coder = SoftwareDeveloper(&apos;David&apos;); console.log(coder); // undefined 这是怎么回事？如果不使用 new 运算符，则不会创建对象。该函数会像任何其他常规函数一样被调用。由于该函数不会 _返回_ 任何东西（除了所有函数都会默认返回的 undefined 之外），因此 coder 变量最终会被分配给 undefined。 还有一点需要注意：由于这个函数作为一个常规函数被调用，因此 this 的值也会截然不同。现在不用太在意这一点，我们将在下一部分深入探讨 this 关键字！ 查看对象的构造函数(instanceof) 如果我们想查看某个对象是否是用构造函数创建的呢？我们可以使用 instanceof（它会返回一个布尔值）来窥见一些端倪。让我们来看看吧！ function Developer(name){ this.name = name; } const dev = new Developer(&apos;Veronkia&apos;); typeof dev; // &quot;object&quot; dev instanceof Developer; // true instanceof 和原型链 在以上示例中，instanceof 确认一个特定的构造函数确实创建了一个特定的对象。我们知道这一点，是因为我们在调用 Developer() 构造函数之后直接实例化了 dev 对象。 然而，很多时候并没有这么简单：instanceof 运算符实际上会测试构造函数是否出现在某个对象的原型链中。这意味着，虽然我们不是总能检查到底是 哪个构造函数 创建了该对象，但是它使我们能够洞察某个对象可能访问哪些其他的属性和方法。 小结 JavaScript 的类系统是直接使用函数和对象来构建的。使用 new 运算符来调用构造函数可以实例化一个新的对象。相同的构造函数可以用于创建不同的对象。 我们在整篇中广泛讨论了函数、对象和 this。事实证明，这三者是密切相关的！ 我们将在下一部分深入探讨 this 关键字，并仔细分析这三者之间的关系。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Constructor</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Multiple hexo personalization settingsMore info: settings]]></content>
  </entry>
</search>
