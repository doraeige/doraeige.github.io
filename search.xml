<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Javascript 的 this 用法]]></title>
    <url>%2F2019%2F02%2F28%2FJavascript-%E7%9A%84-this-%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[this 是 JavaScript 语言的一个关键字。 构造函数中的 this 在上一部分，我们使用了方法中的 this 来访问该方法所属的 对象。让我们再来看一个例子： function Cat(name) { this.name = name this.lives = 9; this.sayName = function () { console.log( &apos;Meow! My name is &apos; + this.name); }; } const bailey = new Cat(); 在上面的 Cat() 构造函数中，sayName 所指向的函数引用了 this.name。之前，我们已经看到过在方法中使用 this，但在这里，this 是指什么呢？ 事实证明，当使用 new 运算符来调用构造函数时，this 会被设置为新创建的对象！让我们来看看新的 bailey 对象是什么样的： { name: Bailey, sayName: function () { console.log(&apos;Meow! My name is &apos; + this.name); } } 在以上代码段中，请注意 this 位于构造函数 外部。正如我们在上一篇文章中所看到的，当你说 this 时，你其实是在说“这个对象”或“当前对象”。因此，sayName() 方法可以使用 this 来访问该对象的 name 属性！这使得以下方法调用成为可能： bailey.sayName(); // Meow! My name is Bailey this 什么时候会被赋值？ 一个常见的误解是，this 指向定义它的对象。事实并非如此！直到某个对象调用使用 this 的方法，this 才会被赋值。换句话说，赋给 this 的值取决于 调用定义 this 的方法的对象。让我们来看一个例子： const dog = { bark: function () { console.log(&apos;Woof!&apos;); }, barkTwice: function () { this.bark(); this.bark(); } }; 让我们继续调用 dog 的两个方法： dog.bark(); // Woof! dog.barkTwice(); // Woof! // Woof! 我们知道，当我们调用 dog.bark() 或 dog.barkTwice() 时，变量 this 将被设置。由于 this 可以访问调用它的对象，因此 barkTwice 可以使用 this 来访问包含 bark 方法的 dog 对象。但是，如果我们在 barkTwice 中使用 bark()，而不是 this.bark()，将会怎样？该函数会先在 barkTwice 的作用域内查找一个名为 bark 的局部变量。如果没有找到 bark，则会沿着作用域链继续查找。综合来看：this.bark() 会告诉 barkTwice 查看 dog（调用该方法的对象）以查找 bark。 this 会被设置为什么？ 到目前为止，我们已经在许多不同的上下文中看到了 this，比如在方法中，或被构造函数引用。现在，让我们把它们放在一起来看一下！有四种方式可以调用函数，而每种方式都会不同地设置 this。 首先，使用 new 关键字来调用构造函数会将 this 设置为一个新创建的对象。还记得吗，在我们之前创建 Cat() 的实例时，this 被设置为新的 bailey 对象。 另一方面，调用属于一个对象的函数（即_方法_）会将 this 设置为该对象本身。回想一下前面的示例，dog 对象的 barkTwice 方法能够访问 dog 本身的属性。 第三，单独调用一个函数（即简单地调用一个常规函数）将把 this 设置为 window。如果主机环境是浏览器，则它将是全局对象。 function funFunction() { return this; } funFunction(); // (返回全局对象, `window`) 第四种调用函数的方式可以让我们自己设置 this！现在不用在意这一点，我们将在下一部分进行深入探讨。 Call Style new method function this {} object itself global object Example new Cat() bailey.sayName() introduce() 如果使用 new 运算符来调用构造函数，this 的值将被设置为新创建的对象，如果在对象上调用方法，this 将被设置为该对象本身，如果简单地调用一个函数，this 将被设置为全局对象: window 小练习 请考虑以下构造函数 City： function City(name, population) { this.name = name; this.population = population; this.identify = function () { console.log(`${this.name}&apos;s population is ${this.population}.`); }; } 当 const sanFrancisco = new City(&#39;San Francisco&#39;, 870000); 被执行时，this 的值是什么？ 答案： 新创建的对象，被 sanFrancisco 引用 请考虑以下对象 building： const building = { floors: 5, addFloor: function () { this.floors += 1; } }; building.addFloor(); 当 building.addFloor() 被执行时，this 的值是什么？ 答案： building 当以下函数被调用时，this 的值是多少？ function myFunction() { console.log(“What is the value of ‘this’?”); } 答案： window 小结 函数、对象和 this 彼此相互关联。当使用 new 运算符来调用构造函数时，this 变量会被设置为新创建的对象。当在对象上调用方法时，this 会被设置为该对象本身。当在浏览器环境中调用函数时，this 会被设置为 window，也被称为全局对象。 除此之外，还有一组方式可以调用函数：使用 apply() 和使用 call()。这两种方式有许多相似之处，每一种方式都允许我们指定如何设置 this。接下来，我们会对它们进行详细分析！]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数]]></title>
    <url>%2F2019%2F02%2F28%2F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[创建对象的一个重要方式是使用构造函数，构造函数以大写字母开头，构造函数必须始终使用特殊关键字 new 来调用，与普通函数的区别是：普通函数必须创建将返回的对象并直接修改该对象，而构造函数会自动创建对象，然后，为了向此对象中添加属性或方法，需要使用特殊的关键字 this。 要实例化（即 创建 ）一个新的对象，我们可以使用 new 运算符来调用这个函数：new SoftwareDeveloper(); 构造函数：结构和语法 function SoftwareDeveloper() { this.favoriteLanguage = &apos;JavaScript&apos;; } 首先，构造函数并不声明局部变量，而是使用 this 关键字来保存数据。以上函数将为所创建的任何对象添加一个 favoriteLanguage 属性，并为其分配一个默认值 ‘JavaScript’。现在不用太在意构造函数中的 this；只要知道 this 是指在构造函数前面使用 new 关键字创建的新对象即可。我们很快就会详细介绍这个 this！最后一点比较特别的是，这个函数似乎不会返回任何东西！JavaScript 中的构造函数不应该有一个显式的返回值（即使用 return 语句）。 创建一个新的对象 正如我们在上面看到的，让我们使用 new 运算符来创建一个新的对象： let developer = new SoftwareDeveloper(); 我们已经把这个调用的返回值保存到了变量 developer 中。让我们执行 console.log(developer); 将这个 SoftwareDeveloper 对象记录到控制台： console.log(developer); // SoftwareDeveloper {favoriteLanguage: &quot;JavaScript&quot;} 用对象字面量的方式来创建对象，看看有何不同 let orderDeveloper = { favoriteLanguage: &apos;JavaScript&apos; }; otherDeveloper; // { favoriteLanguage: &quot;JavaScript&quot; } 可以看出 与 developer 相比，创建对象的构造函数 SoftwareDeveloper 没有列在Chrome 开发者工具中；在 Chrome 开发者工具中 构造函数通常显示在 {} 前面；developer 的构造函数是 SoftwareDeveloper，而 orderDeveloper 的构造函数是 object 构造函数；比较之下，两者原型将有所不同。 构造函数可以有参数 与常规函数一样，使用构造函数的一个好处是它们也可以接受参数。让我们更新以上构造函数来接受一个参数，并为其分配 name 属性： function SoftwareDeveloper(name) { this.favoriteLanguage = &apos;JavaScript&apos;; this.name = name; } 在更新的 SoftwareDeveloper() 函数中，无论传入函数的值是什么，它都将是对象的 name 属性的值。让我们来看看： let instructor = new SoftwareDeveloper(&apos;Andrew&apos;); console.log(instructor); // SoftwareDeveloper { favoriteLanguage: &apos;JavaScript&apos;, name: &apos;Andrew&apos; } 正如我们在上面看到的，我们可以使用相同的构造函数来创建不同的对象： let teacher = new SoftwareDeveloper(&apos;Richard&apos;); console.log(teacher); // SoftwareDeveloper { favoriteLanguage: &apos;JavaScript&apos;, name: &apos;Richard&apos; } 构造函数的好处是，我们可以调用相同的构造函数，创建无数个实例或对象。 省略 new 运算符 如果你无意中 _没有_ 使用 new 运算符来调用构造函数，会发生什么？ function SoftwareDeveloper(name) { this.favoriteLanguage = &apos;JavaScript&apos;; this.name = name; } let coder = SoftwareDeveloper(&apos;David&apos;); console.log(coder); // undefined 这是怎么回事？如果不使用 new 运算符，则不会创建对象。该函数会像任何其他常规函数一样被调用。由于该函数不会 _返回_ 任何东西（除了所有函数都会默认返回的 undefined 之外），因此 coder 变量最终会被分配给 undefined。 还有一点需要注意：由于这个函数作为一个常规函数被调用，因此 this 的值也会截然不同。现在不用太在意这一点，我们将在下一部分深入探讨 this 关键字！ 查看对象的构造函数(instanceof) 如果我们想查看某个对象是否是用构造函数创建的呢？我们可以使用 instanceof（它会返回一个布尔值）来窥见一些端倪。让我们来看看吧！ function Developer(name){ this.name = name; } const dev = new Developer(&apos;Veronkia&apos;); typeof dev; // &quot;object&quot; dev instanceof Developer; // true instanceof 和原型链 在以上示例中，instanceof 确认一个特定的构造函数确实创建了一个特定的对象。我们知道这一点，是因为我们在调用 Developer() 构造函数之后直接实例化了 dev 对象。 然而，很多时候并没有这么简单：instanceof 运算符实际上会测试构造函数是否出现在某个对象的原型链中。这意味着，虽然我们不是总能检查到底是 哪个构造函数 创建了该对象，但是它使我们能够洞察某个对象可能访问哪些其他的属性和方法。 小结 JavaScript 的类系统是直接使用函数和对象来构建的。使用 new 运算符来调用构造函数可以实例化一个新的对象。相同的构造函数可以用于创建不同的对象。 我们在整篇中广泛讨论了函数、对象和 this。事实证明，这三者是密切相关的！ 我们将在下一部分深入探讨 this 关键字，并仔细分析这三者之间的关系。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Constructor</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Multiple hexo personalization settingsMore info: settings]]></content>
  </entry>
</search>
