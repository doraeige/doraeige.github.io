<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hey,Sophia!</title>
  
  <subtitle>胡诌乱编，沆瀣一气</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-04T04:40:36.544Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xiaoyaliu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>响应式设计(三)</title>
    <link href="http://yoursite.com/2019/03/04/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1-%E4%B8%89/"/>
    <id>http://yoursite.com/2019/03/04/响应式设计-三/</id>
    <published>2019-03-04T02:39:45.000Z</published>
    <updated>2019-03-04T04:40:36.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="响应模式"><a href="#响应模式" class="headerlink" title="响应模式"></a>响应模式</h2><hr><p>响应模式的变化是快的，但是也有一些确定的模式，能在几乎任何设备上都有不错的表现。</p><p>响应式网页布局可以大致分为四种模式：</p><ul><li>大体流动模型(Mostly Fluid)</li><li>掉落列模型(Column Drop)</li><li>活动布局模型(Layout Shifter)</li><li>画布溢出模型(Off Canvas)</li></ul><p>有时，一个网页同时结合几种模式，例如 掉落列和画布溢出模型。以下部分将会讲解每种模式是怎样工作的，然后你就可以运用所学的 <code>flexbox</code> 和 <code>媒体查询</code> 技术来实现它们了。</p><h2 id="掉落列模型-Column-Drop"><a href="#掉落列模型-Column-Drop" class="headerlink" title="掉落列模型(Column Drop)"></a>掉落列模型(Column Drop)</h2><hr><p>掉落列模型(Column Drop) 可能是最简单的。</p><p>在视窗最窄的时候，每个元素都纵向堆放，一个接着一个；当视窗变宽，元素也随之延展，直到到达第一个断点，在第一个断点，所有元素不再竖直堆放，而是前两个元素并排显示，第三个元素在它们下面，这些元素会继续随着视窗而延展，直至到达下一个断点，接着，它们会重排成一个三列布局，通常，当视窗到达最大宽度，列也到达最大宽度，然后它们便不再随视窗而延展，而是在两侧添加外边距。</p><p><img src="/images/css5.png" alt="掉落列模型"></p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><hr><p><img src="/images/css6.png" alt="掉落列模型"></p><h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>从最小的视图开始，我们现在有三个 <code>div</code> 标签，包含在一个 <code>container</code> 标签里</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box dark_blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box light_blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box green"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加相应的 <code>css</code> 属性:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h4><p>因为这是个例子，我就随机的将断点设为 <code>450px</code>。</p><p>我想让这个 <strong>深蓝的div</strong> 占据视窗宽度的 <strong>25%</strong>，这个 <strong>浅蓝色的div</strong> 占据 <strong>75%</strong>，然后我将 <strong>绿色的div</strong> 占据整个视窗。</p><p>为了实现这些，我需要添加一个新的 <strong>媒体查询</strong> 来检查，视窗宽度是否大于等于 <code>450px</code>，然后将 <strong>深蓝的div</strong> 的宽度 设为 <strong>25%</strong>，<strong>浅蓝色的div</strong> 的宽度 设为 <strong>75%</strong>。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">450px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.dark_blue</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.light_blue</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">75%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h4><p>我要在 550px 添加第二个断点，然后让 <strong>深蓝的div</strong> 为 <strong>25%</strong>，<strong>浅蓝色的div</strong> 为 <strong>50%</strong>， <strong>绿色的div</strong> 为 <strong>25%</strong>，为了实现这些，我需要添加一个新的 <strong>媒体查询</strong> 来检查是否屏幕媒体且最小宽度为 <code>550px</code>。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">550px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.dark_blue</span>, <span class="selector-class">.green</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.light_blue</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;响应模式&quot;&gt;&lt;a href=&quot;#响应模式&quot; class=&quot;headerlink&quot; title=&quot;响应模式&quot;&gt;&lt;/a&gt;响应模式&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;响应模式的变化是快的，但是也有一些确定的模式，能在几乎任何设备上都有不错的表现。&lt;/p&gt;
&lt;p&gt;响应式网页布局可以
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="响应式" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>响应式设计(二)</title>
    <link href="http://yoursite.com/2019/03/03/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1-%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/03/03/响应式设计-二/</id>
    <published>2019-03-03T06:22:40.000Z</published>
    <updated>2019-03-03T07:42:26.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><hr><p>响应式网页会基于设备的特征而变化。也就是说，你的响应式网页，需要在不同的设备上应用不同的样式。有几种办法可以有选择性的应用CSS代码，最简单的是 使用 <strong>媒体查询</strong>。</p><p><strong>媒体查询</strong> 提供了简单的逻辑方法，来根据不同的设备特征应用不同的样式，比如设备的宽度、高度或者像素比。你可以修改所有内容，从背景图片到页面布局，甚至其他的任何东西。</p><p>添加响应式样式很简单，在需要在你的页面里添加另外的样式表，并附上 <strong>媒体查询</strong> :</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"screen and (min-width:300px)"</span> <span class="attr">href</span>=<span class="string">"patterns.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* patterns.css */</span></span><br><span class="line"><span class="comment">/* 屏幕宽带 大于300px 时应用下面这个样式 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除了利用样式表链接的媒体查询属性，还有两种方式可以应用媒体查询，你可以在 <code>@media</code> 标签嵌入 或者在 <code>@import</code> 标签嵌入</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">500px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(<span class="string">"patterns.css"</span>) only screen and (min-width: <span class="number">500px</span>);</span><br></pre></td></tr></table></figure><blockquote><p>因为性能原因，你应该绝对避免使用 <code>@import</code>; 它是一个代价和优先级都非常高的标签</p></blockquote><p>你需要权衡 CSS链接 和 <code>@media</code> 的代价:</p><ul><li>如果使用 CSS链接，你会有很多小文件，但是很多 HTTP 请求</li><li>如果使用 <code>@media</code>，HTTP 请求 会少一些，但是文件都会变大</li></ul><p>响应式网页设计中，最常用的媒体查询变量是 <code>min-width</code> 和 <code>max-width</code>；<code>max-width</code> 的规则是在视窗宽度小于其赋值时生效。<code>min-width</code>的规则是在视窗宽度大于其赋值时生效。</p><p>你还可以创建基于 <code>min-device-width</code> 或者 <code>max-device-width</code> 的媒体查询，但是这十分不推荐，它们的区别很细微，但却很重要。</p><p><code>min-width</code> 是基于浏览器窗口大小的；<code>min-device-width</code> 是基于屏幕大小的；额外添加 <code>device-width</code> 变量可以防止在电脑或其他桌面设备上的网页内容 随窗口大小 而变化，因为这样的媒体查询是基于真实设备的尺寸的，而非浏览器窗口；另外一个原因是 一些浏览器 比如 Legacy 安卓浏览器可能返回错误的设备值。</p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><hr><blockquote><p>页面改变布局的那个点叫断点</p></blockquote><h3 id="要在哪设置断点？"><a href="#要在哪设置断点？" class="headerlink" title="要在哪设置断点？"></a>要在哪设置断点？</h3><blockquote><p>根据你的内容来设置断点</p></blockquote><p>一开始设置断点时，先在电脑浏览器上将窗口尺寸设置到最小，顺便打开 Chrome 的开发者工具，因为当改变窗口时，它会在右上角显示当前窗口的分辨率。接下来慢慢拉大窗口，仔细观察内容，看它什么时候需要断点</p><h2 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout" target="_blank" rel="noopener">网格布局的基本概念</a></p><p>动态网格系统中，有一些动态调整的纵列，当窗口变小时，它们会自动顺延到下一行，有很多不错的范例可供使用，比如 <code>Bootstrap</code> 或者 <code>960px 网格布局系统</code>，它们都非常易于使用，并且已经为你做好了一切准备工作。</p><h2 id="弹性框-–-Flexbox"><a href="#弹性框-–-Flexbox" class="headerlink" title="弹性框 – Flexbox"></a>弹性框 – Flexbox</h2><p><code>Flexbox</code> 是最好用的布局工具之一。</p><p>之所以功能强大，是因为它能够自动填充空白区域。如果一个元素周围出现了空白，它会自动填补上，而如果空间变得拥挤，它会缩小，直至占据最小空间</p><h3 id="怎样用-Flexbox-实现设计？"><a href="#怎样用-Flexbox-实现设计？" class="headerlink" title="怎样用 Flexbox 实现设计？"></a>怎样用 Flexbox 实现设计？</h3><ul><li><p><code>display: flex</code><br>  flex 的默认堆放方式为 横向堆放；默认情况下 flex 项目会自动填充在一行内，所以无论将元素的宽度设为多少，它们都不会换行。相反，浏览器将其大小适应在视窗内，要改变这些，可以为元素添加 <code>flex-wrap:wrap</code> 语句，这是在告诉浏览器，可以允许内部的元素换行。</p></li><li><p><code>flexbox</code> 另外一个很有用的特性，是 <strong>能够改变元素的次序，利用 CSS  order 属性</strong>。比如以下 5个div 在浏览器窗口宽度大于 700px 时会根据 order 属性从小到大的顺序排列</p></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">700px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.dark_blue</span> &#123; <span class="attribute">order</span>: <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="selector-class">.light_blue</span> &#123; <span class="attribute">order</span>: <span class="number">5</span>; &#125;</span><br><span class="line">    <span class="selector-class">.green</span> &#123; <span class="attribute">order</span>: <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="selector-class">.orange</span> &#123; <span class="attribute">order</span>: <span class="number">3</span>; &#125;</span><br><span class="line">    <span class="selector-class">.red</span> &#123; <span class="attribute">order</span>: <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><hr><blockquote><p>看以下图片，从左图设置成右图的布局</p></blockquote><p><img src="/images/css1.png" alt="flex"></p><p><strong>答案：</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &#123; <span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">order</span>:<span class="number">1</span>; &#125;</span><br><span class="line"><span class="selector-class">.red</span> &#123; <span class="attribute">width</span>: <span class="number">50%</span>; <span class="attribute">order</span>: <span class="number">2</span>; &#125;</span><br><span class="line"><span class="selector-class">.orange</span> &#123; <span class="attribute">width</span>: <span class="number">50%</span>; <span class="attribute">order</span>: <span class="number">3</span>; &#125;</span><br><span class="line"><span class="selector-tag">footer</span> &#123; <span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">order</span>:<span class="number">4</span> &#125;</span><br><span class="line"><span class="selector-class">.light_blue</span> &#123; <span class="attribute">width</span>: <span class="number">20%</span>; <span class="attribute">order</span>: <span class="number">5</span>; &#125;</span><br><span class="line"><span class="selector-class">.dark_blue</span> &#123; <span class="attribute">width</span>: <span class="number">60%</span>; <span class="attribute">order</span>: <span class="number">6</span>; &#125;</span><br><span class="line"><span class="selector-class">.green</span> &#123; <span class="attribute">width</span>: <span class="number">20%</span>; <span class="attribute">order</span>: <span class="number">7</span>; &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>请为图片上你看到所有不同颜色的元素，写出它们的宽度和和每个元素在这个布局中所需要的次序。Width (宽度） Order （次序）</p></blockquote><p><img src="/images/css2.png" alt="flex"></p><p><strong>参考答案：</strong></p><p><img src="/images/css3.png" alt="flex"></p><p>或者：</p><p><img src="/images/css4.png" alt="flex"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>flexbox</code> 和 <strong>动态网格</strong> 看起来都是响应式设计中很棒的通用策略。</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><p><a href="http://zh.learnlayout.com/" target="_blank" rel="noopener">学习CSS布局</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;媒体查询&quot;&gt;&lt;a href=&quot;#媒体查询&quot; class=&quot;headerlink&quot; title=&quot;媒体查询&quot;&gt;&lt;/a&gt;媒体查询&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;响应式网页会基于设备的特征而变化。也就是说，你的响应式网页，需要在不同的设备上应用不同的样式。有几种办法可以有选择
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="响应式" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>响应式设计(一)</title>
    <link href="http://yoursite.com/2019/03/02/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1-%E4%B8%80/"/>
    <id>http://yoursite.com/2019/03/02/响应式设计-一/</id>
    <published>2019-03-02T07:43:44.000Z</published>
    <updated>2019-03-03T06:27:41.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视窗"><a href="#视窗" class="headerlink" title="视窗"></a>视窗</h2><hr><blockquote><p>视窗是指浏览器能够显示内容的区域。</p></blockquote><p>举个例子，在我的电脑上，我把浏览器窗口设置为 <strong>800px</strong> 宽，这让我的可视部分也为 <strong>800px</strong> 宽。如果我拉宽显示窗口，可视部分的宽度也随之变化。</p><p>Chromebook 显示器的像素是 宽度 <strong>2560px</strong>, 高度为 <strong>1700px</strong>；但是当我把浏览器全屏显示，然后查看显示窗口宽度的话，他显示的宽度只有 <strong>1280px</strong>。</p><blockquote><p>为什么显示的宽度不是 <strong>2560px</strong> 呢？</p></blockquote><p>浏览器并不是根据 <strong>物理硬件的像素宽度(Hardware Pixels,这里指 2560px)</strong> 而工作的，而是根据 <strong>DIPs(Device Independent Pixels)宽度</strong>，也就是 设备独立像素值。</p><p>一如其名，<strong>DIP</strong> 是一种计量单位，它将像素值与实际距离联系起来，同一 <strong>DIP</strong> 值表示的是 屏幕上同样大小的空间，而不论显示器的像素密度是多少。</p><p>所以说，如果物理硬件的实际像素值 是 浏览器像素的两倍的话，那么 Chromebook 的像素比就是 <strong>2</strong>；</p><p>所以，浏览器视图的宽度是 <strong>1280</strong> dips， <strong>1280</strong> dips 在实际显示的时候，其实是被硬件扩展到了 <strong>2560</strong> 的硬件像素宽度。</p><blockquote><p>如果没有设定视图端口，浏览器会怎么做呢？</p></blockquote><p>除非你告诉浏览器，你的网页会在更小的屏幕上显示，否则它不会知道。</p><blockquote><p>以 <strong>Nexus 5</strong> 手机为例，<strong>1080px</strong> hw pixels 物理硬件的像素宽度, 像素比 <strong>deviec pixel radio: 3</strong>，既是 <strong>360 dips</strong></p></blockquote><p>在渲染网页的时候，如果它原本是显示在宽 980 DIPs 的屏幕上的，能够放在一个宽度仅有 <strong>360 DIPs</strong> 的手机屏幕，被压缩了一半还多，显示的效果如下图所见：</p><p><img src="/images/viewport.png" alt="viewport"></p><p>然后它为了让内容看上去好一些，会开启字体改善机制，浏览器会试图挑出页面上的首要内容，并把他们放大。也就是说有的字体会变大，易于阅读，但是其他字体还是会一样小，非常难看清。用户必须花好多时间放大屏幕，才能看清或者与内容互动。</p><p><img src="/images/viewport2.png" alt="viewport2"></p><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><hr><blockquote><p>假设你在查看一个手机屏幕技术规格，其分辨率是 <strong>1920 * 1080 px</strong>， 这里的像素是指以下哪一种像素呢？</p></blockquote><ul><li>DIPs （设备独立像素）</li><li>硬件像素</li><li>CSS 像素</li></ul><p><strong>参考答案：</strong> 硬件像素</p><blockquote><p>以下四个图中，哪个图能代表像素比为 <strong>2</strong> 的设备呢？<br>要知道，像素比是一维数字比，请从一维空间思考。</p></blockquote><p><img src="/images/viewport3.png" alt="viewport3"></p><p><strong>参考答案：</strong> 右边第一幅图  </p><blockquote><p>为什么同样的文字会在两个分辨率相同的屏幕上表现不同呢？</p></blockquote><p><img src="/images/viewport5.png" alt="viewport5"></p><ul><li>CSS 样式没有按预设渲染</li><li>两个设备的像素比不同</li><li><code>&lt;meta&gt;</code> 的 <code>initial- scale</code> 导致在不同设备上缩放比例不一致</li><li>没有设置好视图端口</li></ul><p><strong>参考答案：</strong> 两个设备的像素比不同、没有设置好视图端口</p><blockquote><p>计算 CSS 像素<br>已知一个屏幕的分辨率是 <strong>1920 ＊ 1080px</strong>，像素比为 2，那么它横屏放置时，最大视窗宽度是多少 CSS 像素呢？</p></blockquote><p><strong>参考答案：</strong> <strong>960pixels</strong>  1920/2 = 960</p><blockquote><p>计算视窗宽度:请计算以下这四个设备的视窗宽度 (dips)</p></blockquote><p><img src="/images/viewport6.png" alt="viewport6"></p><p><strong>参考答案：</strong></p><p><img src="/images/viewport7.png" alt="viewport7"></p><p>第二个答案，有时候设备的制造商会模糊处理一些数字，所以任何接近 <strong>300</strong> 的数字都可以。<br>第四个注意：笔记本屏幕的总宽度是大于浏览器宽度的，但是这个视窗只跟浏览器有关，与整个屏幕宽度无关，所以它只是 <strong>800px</strong>。</p><h2 id="设置窗口"><a href="#设置窗口" class="headerlink" title="设置窗口"></a>设置窗口</h2><hr><blockquote><p>为 head 元素添加 viewport 标签</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以让浏览器知道我们的意图，我们需要在视窗值后面设置页面宽度，来指导页面针对具体设备进行宽度调整，这使页面内容可以匹配不同屏幕尺寸，不论在较小的手机还是笔记本上；</li><li>添加初始缩放比例属性<code>initial-scale</code>，并赋值为1，告诉浏览器相对像素与CSS像素的比例是一比一。</li><li>CSS 像素值曾经是我们调整最多的属性，也是唯一需要担心的，如果不把初始缩放比例设为1的话，有的浏览器会在切换到横屏模式时，依旧保持之前的页面宽度；而且它们还会使内容进行缩放，而无法自动调整布局</li></ul><h2 id="元素的最大宽度"><a href="#元素的最大宽度" class="headerlink" title="元素的最大宽度"></a>元素的最大宽度</h2><hr><blockquote><p>内容需要适应视窗宽度，这样才能避免左右滚动</p></blockquote><p>在定义元素宽度时，应采用 <strong>相对宽度</strong>，来防止元素溢出视窗。</p><blockquote><p>CSS 是允许内容溢出其容器的，所以如果你没有定义边长，当某一元素，例如图片，其尺寸大于其容器时，它就会溢出。你完全可以避免这一困扰，只需要将最大宽度设为 100%。</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，我推荐你添加一个多类选择器，将 image、embed、object、video元素的属性一次性都设好。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>,<span class="selector-tag">embed</span>,</span><br><span class="line"><span class="selector-tag">object</span>, <span class="selector-tag">video</span>&#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小练习-1"><a href="#小练习-1" class="headerlink" title="小练习"></a>小练习</h3><hr><blockquote><p>以下选项中，哪段代码是响应式的？请选出所有适用项。</p></blockquote><p><img src="/images/viewport8.png" alt="viewport8"></p><p><strong>答案：</strong></p><p><img src="/images/viewport9.png" alt="viewport9"></p><blockquote><p>因为 125px 比任何设备都小得多，所以它符合响应式要求；350px 在一些小的设备视窗宽度可能低至320px的来说会溢出。</p></blockquote><h2 id="触控目标"><a href="#触控目标" class="headerlink" title="触控目标"></a>触控目标</h2><blockquote><p>敲击目标，也就是任何用户可能会点击或者输入的控件，都应该足够大，以便于触击，还要留足空隙，以避免不小心同时按到两个按钮。如果是鼠标，用户可以精准的点击，而如果用我们的手指，操作的精确度会很糟糕。</p></blockquote><blockquote><p>我们的手指大约有 10mm宽，也就是半英尺，差不多就等于40 CSS像素，与其把按钮尺寸设为 <strong>40*40px</strong>，你更应该把按钮尺寸设为 <strong>48*48px</strong>。这样确保元素之间有足够的距离，但是，请确保任何两个敲击目标之间 至少有 <strong>40px</strong> 的距离，这样能防止用户同时点击到两个按钮，或者完全看不到按钮。</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span>, <span class="selector-tag">a</span>, <span class="selector-tag">button</span>&#123;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">48px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">48px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="响应式页面的概念和过程"><a href="#响应式页面的概念和过程" class="headerlink" title="响应式页面的概念和过程"></a>响应式页面的概念和过程</h3><p>设计响应式网页的概念和过程，和非响应式是一样的，除了不只是画一种宽度的设计稿，而是要多画几种来适应不同屏幕尺寸。</p><p>我的设计是从最小的屏幕开始做起，通常是手机设备，做完一个，我会接着做下一个更大一点的，当所有的设计都完成，我会问我自己，还需要为更宽的屏幕做设计吗？有时候，真的不需要做更宽的设计了。</p><blockquote><p>从最小的屏幕做起，我就必须优先考虑什么是对用户最重要的，什么事情是用户最想做的，或者什么是用户最希望在屏幕上看到的。</p></blockquote><blockquote><p>如果是从最大的屏幕开始设计，一些重要的信息很可能会被轻易删掉，相反，明确内容的优先级，然后最小到大的实际，最重要的内容永远都会留在页面上，用户也能得到最完整的体验，无论使用什么样的设备。</p></blockquote><blockquote><p>比如一个硬件商店的设计，优先考虑的信息是商店的地址，营业时间和联系方式。把这些信息放在页面的顶部可以让我更好的看到。</p></blockquote><p>除了从小到大的设计，我的代码编写也是从小到大的，这样我就能知道主要风格和布局是否能兼容任何设备，甚至是古老的不支持媒体查询浏览器，但是我最喜欢的理由是性能，如果从小的视图开始设计，我必须一开始就去思考性能的问题，我需要有意识的去做一些决定，来确定内容优先级以及要为用户提供多少信息。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr><p>本篇，你已经学习了响应式设计的各个部分，比如，视图端口、元素尺寸以及触控目标</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><hr><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Mobile/Viewport_meta_tag" target="_blank" rel="noopener">在移动浏览器中使用viewport元标签控制布局</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;视窗&quot;&gt;&lt;a href=&quot;#视窗&quot; class=&quot;headerlink&quot; title=&quot;视窗&quot;&gt;&lt;/a&gt;视窗&lt;/h2&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;视窗是指浏览器能够显示内容的区域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个例子，在我的电脑上，我
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="响应式" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>远程调试</title>
    <link href="http://yoursite.com/2019/03/02/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    <id>http://yoursite.com/2019/03/02/远程调试/</id>
    <published>2019-03-02T07:21:39.000Z</published>
    <updated>2019-03-02T08:32:54.149Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在真实设备上测试非常重要，所以你需要确保随时能进行测试</p></blockquote><h2 id="如何在-Chrome-中对-Android-进行远程调试"><a href="#如何在-Chrome-中对-Android-进行远程调试" class="headerlink" title="如何在 Chrome 中对 Android 进行远程调试"></a>如何在 Chrome 中对 Android 进行远程调试</h2><ul><li><p><a href="https://www.google.com/chrome/browser/canary.html" target="_blank" rel="noopener">下载Chrome Canary版</a>（它不会影响现有的Chrome安装）</p></li><li><p><a href="https://developers.google.cn/web/tools/chrome-devtools/remote-debugging/?hl=zh" target="_blank" rel="noopener">在装有 Chrome 的 Android 上远程调试</a></p></li></ul><blockquote><p>什么是 Chrome Canary版 ，我为什么要使用它呢？</p></blockquote><p>Chrome Canary版 是Chrome浏览器的开发版本。它的外观和行为与常规的Chrome浏览器类似，但它包含那些尚未公布的新的试验性功能。我们建议你使用最新的 Canary 来分析网站。然而，需要注意的一点是，Canary 不能保证稳定，因此可能会有崩溃和偶尔出错的情况。</p><h2 id="用-iOS-网页调试代理-配合移动端的-Safari"><a href="#用-iOS-网页调试代理-配合移动端的-Safari" class="headerlink" title="用 iOS 网页调试代理 配合移动端的 Safari"></a>用 iOS 网页调试代理 配合移动端的 Safari</h2><ul><li><p><a href="https://github.com/google/ios-webkit-debug-proxy" target="_blank" rel="noopener">iOS WebKit 调试代理(英)</a></p></li><li><p><a href="https://www.smashingmagazine.com/2014/09/testing-mobile-emulators-simulators-remote-debugging/" target="_blank" rel="noopener">Testing Mobile: Emulators, Simulators And Remote Debugging(英)</a></p></li><li><p><a href="https://sebastianblade.com/debug-ios-safari-with-chrome-devtools/" target="_blank" rel="noopener">如何用 Chrome DevTools 调试 iOS Safari</a></p></li></ul><blockquote><p>想要使用云中的不同浏览器测试,尝试 <a href="https://www.browserstack.com/" target="_blank" rel="noopener">BrowserStack</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在真实设备上测试非常重要，所以你需要确保随时能进行测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;如何在-Chrome-中对-Android-进行远程调试&quot;&gt;&lt;a href=&quot;#如何在-Chrome-中对-Android-进行远程调试&quot; 
      
    
    </summary>
    
      <category term="调试" scheme="http://yoursite.com/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="移动设备" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87/"/>
    
      <category term="调试" scheme="http://yoursite.com/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试官问你&quot;有什么问题问我吗?&quot;，该如何回答？</title>
    <link href="http://yoursite.com/2019/03/02/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E4%BD%A0%E2%80%9C%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E9%97%AE%E6%88%91%E5%90%97%EF%BC%9F%E2%80%9D%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/03/02/面试官问你“有什么问题问我吗？”，该如何回答？/</id>
    <published>2019-03-01T17:13:32.000Z</published>
    <updated>2019-03-01T17:31:29.828Z</updated>
    
    <content type="html"><![CDATA[<p>面试官总会在面试结束时问我:”问了你这么多问题了，你有什么问题问我吗?”。</p><h2 id="有哪些有价值的问题值得问"><a href="#有哪些有价值的问题值得问" class="headerlink" title="有哪些有价值的问题值得问?"></a>有哪些有价值的问题值得问?</h2><h3 id="面对HR或者其他Level比较低的面试官时"><a href="#面对HR或者其他Level比较低的面试官时" class="headerlink" title="面对HR或者其他Level比较低的面试官时"></a>面对HR或者其他Level比较低的面试官时</h3><hr><ul><li><p><strong>能不能谈谈你作为一个公司老员工对公司的感受?</strong><br>(这个问题比较容易回答，不会让面试官陷入无话可说的尴尬境地。另外，从面试官的回答中你可以加深对这个公司的了解，让你更加清楚这个公司到底是不是你想的那样或者说你是否能适应这个公司的文化。除此之外，这样的问题在某种程度上还可以拉进你与面试官的距离)</p></li><li><p><strong>能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你?有什么地方你觉得还不太好或者可以继续完善吗？</strong><br>（类似第一个问题，都是问面试官个人对于公司的看法）</p></li><li><p><strong>我觉得我这次表现的不是太好，你有什么建议或者评价给我吗？</strong><br>(这个是我常问的。我觉得说自己表现不好只是这个语境需要这样来说，这样可以显的你比较谦虚好学上进)</p></li><li><p><strong>如果我有幸被贵公司录取，有什么需要在入职前注意或学习的吗？</strong><br>（体现出你对工作比较上心，自助学习意识比较强）</p></li><li><p><strong>这个岗位为什么还在招人？</strong><br>（岗位真实性和价值咨询）</p></li><li><p><strong>大概什么时候能给我回复呢？</strong><br>（终面的时候，如果面试官没有说的话，可以问一下）</p></li></ul><h3 id="面对部门领导"><a href="#面对部门领导" class="headerlink" title="面对部门领导"></a>面对部门领导</h3><hr><ul><li><p><strong>部门的主要人员分配以及对应的主要工作能简单介绍一下吗？</strong></p></li><li><p><strong>未来如果我要加入这个团队，你对我的期望是什么？</strong><br>（部门领导一般情况下是你的直属上级了，你以后和他打交道的机会应该是最多的。你问这个问题，会让他感觉你是一个对他的部门比较上心，比较有团体意识，并且愿意倾听的候选人。）</p></li><li><p><strong>公司对新入职的员工的培养机制是什么样的呢？</strong><br>（正规的公司一般都有培养机制，提前问一下是对你自己的负责也会显的你比较上心）</p></li><li><p><strong>以您来看，这个岗位未来在公司内部的发展如何？</strong><br>（在我看来，问这个问题也是对你自己的负责吧，谁不想发展前景更好的岗位呢？）</p></li><li><p><strong>团队现在面临的最大挑战是什么？</strong><br>（这样的问题不会暴露你对公司的不了解，并且也能让你对未来工作的挑战或困难有一个提前的预期）</p></li></ul><h3 id="面对Level比较高的-比如总裁-老板"><a href="#面对Level比较高的-比如总裁-老板" class="headerlink" title="面对Level比较高的(比如总裁,老板)"></a>面对Level比较高的(比如总裁,老板)</h3><hr><ul><li><p><strong>贵公司的发展目标和方向是什么？</strong><br>（看下公司的发展是否满足自己的期望）</p></li><li><p><strong>与同行业的竞争者相比，贵公司的核心竞争优势在什么地方？</strong><br>（充分了解自己的优势和劣势）</p></li><li><p><strong>公司现在面临的最大挑战是什么？</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面试官总会在面试结束时问我:”问了你这么多问题了，你有什么问题问我吗?”。&lt;/p&gt;
&lt;h2 id=&quot;有哪些有价值的问题值得问&quot;&gt;&lt;a href=&quot;#有哪些有价值的问题值得问&quot; class=&quot;headerlink&quot; title=&quot;有哪些有价值的问题值得问?&quot;&gt;&lt;/a&gt;有哪些有
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试问题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试-前端编程思路</title>
    <link href="http://yoursite.com/2019/03/02/%E9%9D%A2%E8%AF%95-%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A8%8B%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2019/03/02/面试-前端编程思路/</id>
    <published>2019-03-01T16:42:32.000Z</published>
    <updated>2019-03-02T08:52:59.382Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>编写一个js函数，该函数有一个n（数字类型），其返回值是一个数组，该数组内是n个随机且不重复的整数，且整数取值范围是[2,32] </p></blockquote><hr><h4 id="题目解读"><a href="#题目解读" class="headerlink" title="题目解读"></a>题目解读</h4><hr><p>输入一个数字类型的参数n，会返回一个包含2到32的数字的数组，数组长度是n(比如你输入数字是2，就会返回数组长度为2的数组); 数组里面的数字用 随机函数 生成，然后还要检查数字是否会重复，也要考虑负数情况等边界条件</p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><hr><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil();   <span class="comment">//向上取整。</span></span><br><span class="line"><span class="built_in">Math</span>.floor();  <span class="comment">//向下取整。</span></span><br><span class="line"><span class="built_in">Math</span>.round();  <span class="comment">//四舍五入。</span></span><br><span class="line"><span class="built_in">Math</span>.random(); <span class="comment">//0.0 ~ 1.0 之间的一个伪随机数。【包含0不包含1) 比如0.8647578968666494</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">10</span>); <span class="comment">// 获取从1到10的随机整数 ，取0的概率极小。</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random());   <span class="comment">//可均衡获取0到1的随机整数。</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">10</span>);  <span class="comment">//可均衡获取0到9的随机整数。</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random()*<span class="number">10</span>);  <span class="comment">//基本均衡获取0到10的随机整数，其中获取最小值0和最大值10的几率少一半。</span></span><br></pre></td></tr></table></figure><blockquote><p>直接使用 parseInt，parseFloat 或 Number 将一个非数字的值转化为数字时，表达式返回 NaN </p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'abc'</span> - <span class="number">3</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'abc'</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'abc'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'abc'</span>)    <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><blockquote><p>isNaN() 是一个全局方法，它的作用是检查一个值是否能被 Number() 成功转换 。 如果能转换成功，就返回 false，否则返回 true </p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>)    <span class="comment">// true 不能转换</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'123'</span>)   <span class="comment">// false 能转换</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'abc'</span>)    <span class="comment">// true 不能转换</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'123ab'</span>)   <span class="comment">// true 不能转换</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'123.45abc'</span>) <span class="comment">// true 不能转换</span></span><br></pre></td></tr></table></figure><h4 id="生成随机数方法总结"><a href="#生成随机数方法总结" class="headerlink" title="生成随机数方法总结"></a>生成随机数方法总结</h4><hr><blockquote><p>生成[1,max]的随机数，公式如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// max - 期望的最大值</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*max,<span class="number">10</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*max)+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*max);</span><br></pre></td></tr></table></figure><blockquote><p>生成[0,max]到任意数的随机数，公式如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// max - 期望的最大值</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*(max+<span class="number">1</span>),<span class="number">10</span>);</span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(max+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><blockquote><p>生成[min,max]的随机数，公式如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// max - 期望的最大值</span></span><br><span class="line"><span class="comment">// min - 期望的最小值</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*(max-min+<span class="number">1</span>)+min,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(max-min+<span class="number">1</span>)+min);</span><br></pre></td></tr></table></figure><h4 id="编程思维："><a href="#编程思维：" class="headerlink" title="编程思维："></a>编程思维：</h4><hr><p>可用 —&gt; 健壮 —&gt; 可靠 —&gt; 宽容</p><p>健壮：</p><ul><li>最基本的兼容性处理、边界处理、异常处理、用户输入校验</li><li>对n的取值范围进行校验；对n是否为数字进行校验；对n是否存在进行校验</li></ul><p>宽容：</p><ul><li>n是一个字符串数字，是否允许进入处理流程？是的话，经验系数*1.1</li><li>n是一个含有小数的数字，是否允许进入处理流程？是的话，经验系数*1.1</li><li>代码是否有足够多且清晰的注释？是的话，经验系数*1.2</li><li>调整[2，32]的范围，你的代码是否可以快速调整甚至不用调整？是的话，经验系数*1.2</li></ul><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成一个随机数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRand</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>) + min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去重校验</span></span><br><span class="line"><span class="comment">// function checkArrIn(rand,array)&#123;</span></span><br><span class="line"><span class="comment">//     if(array.indexof(rand) &gt; -1)&#123;</span></span><br><span class="line"><span class="comment">//         return true;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return false;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断n是不是一个数字，包含字符串类型的数字</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNotNum</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isNaN</span>(<span class="built_in">Number</span>(n)) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断n是不是在范围内</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRandOk</span>(<span class="params">n, min, max</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt;= min &amp;&amp; n &lt;= max ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断n是不是含有小数的数字</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isXiaoShu</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(n).indexOf(<span class="string">"."</span>) &gt; <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去重检验 arr.includes(e) includes 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个容器保存结果</span></span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="comment">// 将整数取值范围用变量保存起来</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (isNotNum(n)) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">if</span> (!isRandOk(n,min,max)) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">if</span> (isXiaoShu(n)) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> rand = getRand(min, max);</span><br><span class="line">        <span class="keyword">if</span> (arr.includes(rand)) &#123; </span><br><span class="line">            i--; <span class="comment">// 减一是因为如果第i次循环的时候如果数组有了该值，就重新走一遍</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr.push(rand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">2</span>); <span class="comment">// (2) [15, 11] 随机</span></span><br><span class="line">fn(<span class="string">'5'</span>); <span class="comment">// (5) [13, 2, 11, 27, 12] 随机</span></span><br><span class="line">fn(<span class="string">'3.33'</span>); <span class="comment">// []</span></span><br><span class="line">fn(<span class="number">5.5</span>); <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h4 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h4><p><a href="https://mp.weixin.qq.com/s/tj8PQXk3CpACYUknE0TpyA" target="_blank" rel="noopener">程序员！为什么你的前端工作经验不值钱？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;编写一个js函数，该函数有一个n（数字类型），其返回值是一个数组，该数组内是n个随机且不重复的整数，且整数取值范围是[2,32] &lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h4 id=&quot;题目解读&quot;&gt;&lt;a href=&quot;#题目解读&quot; class
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="编程逻辑" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>程序猿必备英语单词</title>
    <link href="http://yoursite.com/2019/03/02/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%BF%85%E5%A4%87%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"/>
    <id>http://yoursite.com/2019/03/02/程序猿必备英语单词/</id>
    <published>2019-03-01T16:15:58.000Z</published>
    <updated>2019-03-01T16:23:00.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>abstract 抽象的<br>abstract base class (ABC)抽象基类<br>abstract class 抽象类<br>abstraction 抽象、抽象物、抽象性<br>access 存取、访问<br>access function 访问函数<br>access level访问级别<br>account 账户<br>action 动作<br>activate 激活<br>active 活动的<br>actual parameter 实参<br>adapter 适配器<br>add-in 插件<br>address 地址<br>address space 地址空间<br>ADO(ActiveX Data Object)ActiveX数据对象<br>advanced 高级的<br>aggregation 聚合、聚集<br>algorithm 算法<br>alias 别名<br>align 排列、对齐<br>allocate 分配、配置<br>allocator分配器、配置器<br>angle bracket 尖括号<br>annotation 注解、评注<br>API (Application Programming Interface) 应用(程序)编程接口<br>appearance 外观<br>append 附加<br>application 应用、应用程序<br>application framework 应用程序框架<br>Approximate String Matching 模糊匹配<br>architecture 架构、体系结构<br>archive file 归档文件、存档文件<br>argument参数。<br>array 数组<br>arrow operator 箭头操作符<br>assert(ion) 断言<br>assign 赋值<br>assignment 赋值、分配<br>assignment operator 赋值操作符<br>associated 相关的、相关联的<br>asynchronous 异步的<br>attribute 特性、属性<br>authentication service 验证服务<br>authorization 授权</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>background 背景、后台(进程)<br>backup 备份<br>backup device备份设备<br>backup file 备份文件<br>backward compatible 向后兼容、向下兼容<br>base class 基类<br>base type 基类型<br>batch 批处理<br>BCL (base class library)基类库<br>Bin Packing 装箱问题<br>binary 二进制<br>binding 绑定<br>bit 位<br>bitmap 位图<br>block 块、区块、语句块<br>boolean 布林值(真假值，true或false)<br>border 边框<br>bounds checking 边界检查<br>boxing 装箱、装箱转换<br>brace (curly brace) 大括号、花括号<br>bracket (square brakcet) 中括号、方括号<br>breakpoint 断点<br>browser applications 浏览器应用(程序)<br>browser-accessible application 可经由浏览器访问的应用程序<br>bug 缺陷错误<br>build 编连(专指编译和连接)<br>built-in 内建、内置<br>bus 总线<br>business 业务、商务(看场合)<br>business Logic 业务逻辑<br>business rules 业务规则<br>buttons 按钮<br>by/through 通过<br>byte 位元组(由8 bits组成)</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>cache 高速缓存<br>calendar 日历<br>Calendrical Calculations 日期<br>call 调用<br>call operator 调用操作符<br>callback 回调<br>candidate key 候选键 (for database)<br>cascading delete 级联删除 (for database)<br>cascading update 级联更新 (for database)<br>casting 转型、造型转换<br>catalog 目录<br>chain 链(function calls)<br>character 字符<br>character format 字符格式<br>character set 字符集<br>check box 复选框<br>check button 复选按钮<br>CHECK constraints CHECK约束 (for database)<br>checkpoint 检查点 (for database)<br>child class 子类<br>CIL (common intermediate language)通用中间语言、通用中介语言<br>class 类<br>class declaration 类声明<br>class definition 类定义<br>class derivation list 类继承列表<br>class factory 类厂<br>class hierarchy 类层次结构<br>class library 类库<br>class loader 类装载器<br>class template 类模板<br>class template partial specializations 类模板部分特化<br>class template specializations 类模板特化<br>classification 分类<br>clause 子句<br>cleanup 清理、清除<br>CLI (Common Language Infrastructure) 通用语言基础设施<br>client 客户、客户端<br>client application 客户端应用程序<br>client area 客户区<br>client cursor 客户端游标 (for database)<br>client-server 客户机/服务器、客户端/服务器<br>clipboard 剪贴板<br>clone 克隆<br>CLS (common language specification) 通用语言规范<br>code access security 代码访问安全<br>code page 代码页<br>COFF (Common Object File Format) 通用对象文件格式<br>collection 集合<br>COM (Component Object Model) 组件对象模型<br>combo box 组合框<br>command line 命令行<br>comment 注释<br>commit 提交 (for database)<br>communication 通讯<br>compatible 兼容<br>compile time 编译期、编译时<br>compiler 编译器<br>component组件<br>composite index 复合索引、组合索引 (for database)<br>composite key 复合键、组合键 (for database)<br>composition 复合、组合<br>concept 概念<br>concrete具体的<br>concrete class 具体类<br>concurrency 并发、并发机制<br>configuration 配置、组态<br>Connected Components 连通分支<br>connection 连接 (for database)<br>connection pooling 连接池<br>console 控制台<br>constant 常量<br>Constrained and Unconstrained Optimization 最值问题<br>constraint 约束 (for database)<br>construct 构件、成分、概念、构造（for language）<br>constructor (ctor) 构造函数、构造器<br>container 容器<br>containment包容<br>context 环境、上下文<br>control 控件<br>cookie<br>copy 拷贝<br>CORBA 通用对象请求中介架构(Common Object Request Broker Architecture)<br>cover 覆盖、涵盖<br>create/creation 创建、生成<br>crosstab query 交叉表查询 (for database)<br>Cryptography 密码<br>CTS (common type system)通用类型系统<br>cube 多维数据集 (for database)<br>cursor 光标<br>cursor 游标 (for database)<br>custom 定制、自定义</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><p>data 数据<br>data connection 数据连接 (for database)<br>data dictionary 数据字典 (for database)<br>data file 数据文件 (for database)<br>data integrity 数据完整性 (for database)<br>data manipulation language (DML)数据操作语言(DML) (for database)<br>data member 数据成员、成员变量<br>data source 数据源 (for database)<br>Data source name (DSN) 数据源名称(DSN) (for database)<br>data structure数据结构<br>Data Structures 基本数据结构<br>data table 数据表 (for database)<br>data-bound 数据绑定 (for database)<br>database 数据库 (for database)<br>database catalog 数据库目录 (for database)<br>database diagram 数据关系图 (for database)<br>database file 数据库文件 (for database)<br>database object 数据库对象 (for database)<br>database owner 数据库所有者 (for database)<br>database project 数据库工程 (for database)<br>database role 数据库角色 (for database)<br>database schema 数据库模式、数据库架构 (for database)<br>database script 数据库脚本 (for database)<br>datagram 数据报文<br>dataset 数据集 (for database)<br>dataset 数据集 (for database)<br>DBMS (database management system)数据库管理系统 (for database)<br>DCOM (distributed COM)分布式COM<br>dead lock 死锁 (for database)<br>deallocate 归还<br>debug 调试<br>debugger 调试器<br>decay 退化<br>declaration 声明<br>default 缺省、默认值<br>DEFAULT constraint默认约束 (for database)<br>default database 默认数据库 (for database)<br>default instance 默认实例 (for database)<br>default result set 默认结果集 (for database)<br>defer 推迟<br>definition 定义<br>delegate 委托<br>delegation 委托<br>deploy 部署<br>derived class 派生类<br>design pattern 设计模式<br>destroy 销毁<br>destructor(dtor)析构函数、析构器<br>device 设备<br>DHTML (dynamic HyperText Markup Language)动态超文本标记语言<br>dialog 对话框<br>Dictionaries 字典<br>digest 摘要<br>digital 数字的<br>directive (编译)指示符<br>directory 目录<br>disassembler 反汇编器<br>DISCO (Discovery of Web Services)Web Services的查找<br>dispatch 调度、分派、派发<br>distributed computing 分布式计算<br>distributed query 分布式查询 (for database)<br>DNA (Distributed interNet Application) 分布式网间应用程序<br>document 文档<br>DOM (Document Object Model)文档对象模型<br>dot operator (圆)点操作符<br>double-byte character set (DBCS)双字节字符集(DBCS)<br>driver 驱动(程序)<br>DTD (document type definition) 文档类型定义<br>dump 转储<br>dump file 转储文件</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>e-business 电子商务<br>efficiency 效率<br>efficient 高效<br>encapsulation 封装<br>end user 最终用户<br>end-to-end authentication 端对端身份验证<br>engine 引擎<br>entity 实体<br>enum (enumeration) 枚举<br>enumerators 枚举成员、枚举器<br>equal 相等<br>equality 相等性<br>equality operator 等号操作符<br>error log 错误日志 (for database)<br>escape character 转义符、转义字符<br>escape code 转义码<br>evaluate 评估<br>event 事件<br>event driven 事件驱动的<br>event handler 事件处理器<br>evidence 证据<br>exception 异常<br>exception declaration 异常声明<br>exception handling 异常处理、异常处理机制<br>exception specification 异常规范<br>exception-safe 异常安全的<br>exit 退出<br>explicit 显式<br>explicit specialization 显式特化<br>explicit transaction 显式事务 (for database)<br>export 导出<br>expression 表达式</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p>fat client 胖客户端<br>feature 特性、特征<br>fetch 提取<br>field 字段 (for database)<br>field 字段(java)<br>field length 字段长度 (for database)<br>file 文件<br>filter 筛选 (for database)<br>finalization 终结<br>finalizer 终结器<br>firewall 防火墙<br>flag 标记<br>flash memory 闪存<br>flush 刷新<br>font 字体<br>foreign key (FK) 外键(FK) (for database)<br>form 窗体<br>formal parameter 形参<br>forward declaration 前置声明<br>forward-only 只向前的<br>forward-only cursor 只向前游标 (for database)<br>framework 框架<br>full specialization 完全特化<br>function 函数<br>function call operator (即operator ()) 函数调用操作符<br>function object 函数对象<br>function template函数模板<br>functionality 功能<br>functor 仿函数</p><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><hr><p>GC (Garbage collection) 垃圾回收(机制)、垃圾收集(机制)<br>generate 生成<br>generic 泛化的、一般化的、通用的<br>generic algorithm通用算法<br>genericity 泛型<br>getter (相对于 setter)取值函数<br>global 全局的<br>global object 全局对象<br>grant 授权 (for database)<br>group 组、群<br>group box 分组框<br>GUI 图形界面<br>GUID (Globally Unique Identifier) 全球唯一标识符</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><hr><p>handle 句柄<br>handler 处理器<br>hard disk 硬盘<br>hard-coded 硬编码的<br>hard-copy 截屏图<br>hardware 硬件<br>hash table 散列表、哈希表<br>header file头文件<br>heap 堆<br>help file 帮助文件<br>hierarchical data 阶层式数据、层次式数据<br>hierarchy 层次结构、继承体系<br>high level 高阶、高层<br>hook 钩子<br>Host (application)宿主(应用程序)<br>hot key 热键<br>HTML (HyperText Markup Language) 超文本标记语言<br>HTTP (HyperText Transfer Protocol) 超文本传输协议<br>HTTP pipeline HTTP管道<br>hyperlink 超链接</p><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><hr><p>icon 图标<br>IDE (Integrated Development Environment)集成开发环境<br>identifier 标识符<br>IDL (Interface Definition Language) 接口定义语言<br>idle time 空闲时间<br>if and only if当且仅当<br>IL (Intermediate Language) 中间语言、中介语言<br>image 图象<br>IME 输入法<br>immediate base 直接基类<br>immediate derived 直接派生类<br>immediate updating 即时更新 (for database)<br>implement 实现<br>implementation 实现、实现品<br>implicit 隐式<br>implicit transaction隐式事务 (for database)<br>import 导入<br>incremental update 增量更新 (for database)<br>Independent Set 独立集<br>index 索引 (for database)<br>infinite loop 无限循环<br>infinite recursive 无限递归<br>information 信息<br>inheritance 继承、继承机制<br>initialization 初始化<br>initialization list 初始化列表、初始值列表<br>initialize 初始化<br>inline 内联<br>inline expansion 内联展开<br>inner join 内联接 (for database)<br>instance 实例<br>instantiated 具现化、实体化(常应用于template)<br>instantiation 具现体、具现化实体(常应用于template)<br>integrate 集成、整合<br>integrity 完整性、一致性<br>integrity constraint完整性约束 (for database)<br>interacts 交互<br>interface 接口<br>interoperability 互操作性、互操作能力<br>interpreter 解释器<br>introspection 自省<br>invariants 不变性<br>invoke 调用<br>isolation level 隔离级别 (for database)<br>item 项、条款、项目<br>iterate 迭代<br>iteration 迭代(回圈每次轮回称为一个iteration)<br>iterative 反复的、迭代的<br>iterator 迭代器</p><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><hr><p>JIT compilation JIT编译即时编译<br>Job Scheduling 工程安排</p><h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><hr><p>key 键 (for database)<br>key column 键列 (for database)</p><h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><hr><p>left outer join 左向外联接 (for database)<br>level 阶、层例<br>library 库<br>lifetime 生命期、寿命<br>Linear Programming 线性规划<br>link 连接、链接<br>linkage 连接、链接<br>linker 连接器、链接器<br>list 列表、表、链表<br>list box 列表框<br>literal constant 字面常数<br>livelock 活锁 (for database)<br>load 装载、加载<br>load balancing 负载平衡<br>loader 装载器、载入器<br>local 局部的<br>local object 局部对象<br>lock 锁<br>log 日志<br>login 登录<br>login security mode登录安全模式 (for database)<br>lookup table 查找表 (for database)<br>loop 循环<br>loose coupling 松散耦合<br>lvalue 左值</p><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><hr><p>machine code 机器码、机器代码<br>macro 宏<br>maintain 维护<br>managed code 受控代码、托管代码<br>Managed Extensions 受控扩充件、托管扩展<br>managed object 受控对象、托管对象<br>manifest 清单<br>many-to-many relationship 多对多关系 (for database)<br>many-to-one relationship 多对一关系 (for database)<br>marshal 列集<br>Matching 匹配<br>member 成员<br>member access operator 成员取用运算子(有dot和arrow两种)<br>member function 成员函数<br>member initialization list成员初始值列表<br>memory 内存<br>memory leak 内存泄漏<br>menu 菜单<br>message 消息<br>message based 基于消息的<br>message loop 消息环<br>message queuing消息队列<br>metadata 元数据<br>metaprogramming元编程<br>method 方法<br>micro 微<br>middle tier 中间层<br>middleware 中间件<br>modeling 建模<br>modeling language 建模语言<br>modem 调制解调器<br>modifier 修饰字、修饰符<br>module 模块<br>most derived class最底层的派生类<br>mouse 鼠标<br>multi-tasking 多任务<br>multi-thread 多线程<br>multicast delegate 组播委托、多点委托<br>multithreaded server application 多线程服务器应用程序<br>multiuser 多用户<br>mutable 可变的<br>mutex 互斥元、互斥体</p><h2 id="N"><a href="#N" class="headerlink" title="N"></a>N</h2><hr><p>named parameter 命名参数<br>named pipe 命名管道<br>namespace 名字空间、命名空间<br>native 原生的、本地的<br>native code 本地码、本机码<br>nested class 嵌套类<br>nested query 嵌套查询 (for database)<br>nested table 嵌套表 (for database)<br>network 网络<br>network card 网卡<br>Network Flow 网络流</p><h2 id="O"><a href="#O" class="headerlink" title="O"></a>O</h2><hr><p>object 对象<br>object based 基于对象的<br>object model 对象模型<br>object oriented 面向对象的<br>ODBC data source ODBC数据源 (for database)<br>ODBC driver ODBC驱动程序 (for database)<br>one-to-many relationship 一对多关系 (for database)<br>one-to-one relationship 一对一关系 (for database)<br>operating system (OS) 操作系统<br>operation 操作<br>operator 操作符、运算符<br>option 选项<br>outer join 外联接 (for database)<br>overflow 上限溢位(相对于underflow)<br>overload 重载<br>override 覆写、重载、重新定义</p><h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><hr><p>package 包<br>packaging 打包<br>palette 调色板<br>parallel 并行<br>parameter 参数、形式参数、形参<br>parameter list 参数列表<br>parameterize 参数化<br>parent class 父类<br>parentheses 圆括弧、圆括号<br>parse 解析<br>parser 解析器<br>part 零件、部件<br>partial specialization 局部特化<br>pass by reference 引用传递<br>pass by value 值传递<br>pattern 模式<br>persistence 持久性<br>pixel 像素<br>placeholder 占位符<br>platform 平台<br>Point Location 位置查询<br>pointer 指针<br>polymorphism 多态<br>pooling 池化<br>pop up 弹出式<br>port 端口<br>postfix 后缀<br>precedence 优先序(通常用于运算子的优先执行次序)<br>prefix 前缀<br>preprocessor 预处理器<br>primary key (PK)主键(PK) (for database)<br>primary table 主表 (for database)<br>primitive type 原始类型<br>print 打印<br>printer 打印机<br>procedure 过程<br>process 进程<br>program 程序<br>programmer 程序员<br>programming编程、程序设计<br>progress bar 进度指示器<br>project 项目、工程<br>property 属性<br>protocol 协议<br>pseudo code伪码</p><h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><hr><p>qualified 合格的<br>qualifier 修饰符<br>quality 质量<br>queue 队列</p><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><hr><p>radio button 单选按钮<br>random number 随机数<br>Random Number Generation 随机数生成<br>range 范围、区间<br>rank 等级<br>raw 未经处理的<br>re-direction 重定向<br>readOnly只读<br>record 记录 (for database)<br>recordset 记录集 (for database<br>recursion —— 递归<br>recursive 递归<br>refactoring 重构<br>refer 引用、参考<br>reference 引用、参考<br>reflection 反射<br>refresh data 刷新数据 (for database)<br>register 寄存器<br>regular expression 正则表达式<br>relational database 关系数据库<br>remote 远程<br>remote request 远程请求<br>represent 表述，表现<br>resolution 解析过程<br>resolve 解析、决议<br>result set 结果集 (for database)<br>retrieve data 检索数据<br>return 返回<br>return type 返回类型<br>return value 返回值<br>revoke 撤销<br>right outer join 右向外联接 (for database)<br>robust 健壮<br>robustness 健壮性<br>roll back 回滚 (for database)<br>roll forward 前滚 (for database)<br>routine 例程<br>row 行 (for database)<br>rowset 行集 (for database)<br>RPC (remote procedure call)RPC(远程过程调用)<br>runtime 执行期、运行期、执行时、运行时<br>rvalue 右值</p><h2 id="S"><a href="#S" class="headerlink" title="S"></a>S</h2><hr><p>Satisfiability 可满足性<br>save 保存<br>savepoint 保存点 (for database)<br>SAX (Simple API for XML)<br>scalable 可伸缩的、可扩展的<br>schedule 调度<br>scheduler 调度程序<br>schema 模式、纲目结构<br>scope 作用域、生存空间<br>screen 屏幕<br>scroll bar滚动条<br>SDK (Software Development Kit)软件开发包<br>sealed class 密封类<br>search 查找<br>Searching 查找<br>semantics 语义<br>sequential container序列式容器<br>serial 串行<br>serialization/serialize 序列化<br>server 服务器、服务端<br>session 会话 (for database)<br>Set and String Problems 集合与串的问题<br>Set Cover 集合覆盖<br>Set Data Structures 集合<br>Set Packing 集合配置<br>setter 设值函数<br>side effect 副作用<br>signature 签名<br>single-threaded 单线程<br>slider滑块<br>slot 槽<br>SMTP (Simple Mail Transfer Protocol) 简单邮件传输协议<br>snapshot 截屏图<br>snapshot 快照 (for database)<br>SOAP (simple object access protocol) 简单对象访问协议<br>software 软件<br>Sorting 排序<br>source code 源码、源代码<br>specialization 特化<br>specification 规范、规格<br>splitter 切分窗口<br>SQL (Structured Query Language) 结构化查询语言 (for database)<br>stack 栈、堆栈<br>standard library 标准库<br>standard template library 标准模板库<br>stateless 无状态的<br>statement 语句、声明<br>static cursor 静态游标 (for database)<br>static SQL statements 静态SQL语句 (for database)<br>status bar 状态条<br>stored procedure 存储过程 (for database)<br>stream 流<br>string 字符串<br>String Matching 模式匹配<br>stub 存根<br>subobject子对象<br>subquery 子查询 (for database)<br>subscript operator 下标操作符<br>support 支持<br>suspend 挂起<br>symbol 记号<br>syntax 语法<br>system databases 系统数据库 (for database)<br>system tables 系统表 (for database)</p><h2 id="T"><a href="#T" class="headerlink" title="T"></a>T</h2><hr><p>table 表 (for database)<br>table-level constraint 表级约束 (for database)<br>target 标的,目标<br>task switch 工作切换<br>TCP (Transport Control Protocol) 传输控制协议<br>template 模板<br>temporary object 临时对象<br>temporary table 临时表 (for database)<br>text 文本<br>Text Compression 压缩<br>text file 文本文件<br>thin client 瘦客户端<br>third-party 第三方<br>thread 线程<br>thread-safe 线程安全的<br>throw 抛出、引发(常指发出一个exception)<br>trace 跟踪<br>transaction 事务 (for database)<br>transaction log 事务日志 (for database)<br>transaction rollback 事务回滚 (for database)<br>traverse 遍历<br>trigger 触发器 (for database)<br>type 类型</p><h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><hr><p>UDDI(Universary Description, Discovery and Integration)统一描述、查询与集成<br>UML (unified modeling language)统一建模语言<br>unary function 单参函数<br>unary operator 一元操作符<br>unboxing 拆箱、拆箱转换<br>underflow 下限溢位(相对于overflow)<br>Unicode 统一字符编码标准，采用双字节对字符进行编码<br>Union query 联合查询 (for database)<br>UNIQUE constraints UNIQUE约束 (for database)<br>unique index 唯一索引 (for database)<br>unmanaged code 非受控代码、非托管代码<br>unmarshal 散集<br>unqualified 未经限定的、未经修饰的<br>URI (Uniform Resource identifier) 统一资源标识符<br>URL (Uniform Resource Locator) 统一资源定位器<br>user 用户<br>user interface 用户界面</p><h2 id="V"><a href="#V" class="headerlink" title="V"></a>V</h2><hr><p>value types 值类型<br>variable 变量<br>vector 向量(一种容器，有点类似array)<br>vendor 厂商<br>viable 可行的<br>video 视频<br>view 视图 (for database)<br>view 视图<br>virtual function 虚函数<br>virtual machine 虚拟机<br>virtual memory 虚拟内存</p><h2 id="W"><a href="#W" class="headerlink" title="W"></a>W</h2><hr><p>Web Services web服务<br>WHERE clause WHERE子句 (for database)<br>wildcard characters 通配符字符 (for database)<br>wildcard search 通配符搜索 (for database)<br>window 窗口<br>window function 窗口函数<br>window procedure 窗口过程<br>Windows authentication Windows身份验证<br>wizard 向导<br>word 单词<br>write enable 写启用 (for database)<br>write-only 只写<br>WSDL (Web Service Description Language)Web Service描述语言</p><h2 id="X"><a href="#X" class="headerlink" title="X"></a>X</h2><hr><p>XML (eXtensible Markup Language) 可扩展标记语言<br>XML Message Interface (XMI) XML消息接口<br>XSD (XML Schema Definition) XML模式定义语言<br>XSL (eXtensible Stylesheet Language) 可扩展样式表语言<br>XSLT (eXtensible Stylesheet Language Transformation)可扩展样式表语言转换<br>xxx based 基于xxx的<br>xxx oriented 面向xxx</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;A&quot;&gt;&lt;a href=&quot;#A&quot; class=&quot;headerlink&quot; title=&quot;A&quot;&gt;&lt;/a&gt;A&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;abstract 抽象的&lt;br&gt;abstract base class (ABC)抽象基类&lt;br&gt;abstract class 抽象类&lt;b
      
    
    </summary>
    
      <category term="English" scheme="http://yoursite.com/categories/English/"/>
    
    
      <category term="word" scheme="http://yoursite.com/tags/word/"/>
    
  </entry>
  
  <entry>
    <title>原型继承:子类</title>
    <link href="http://yoursite.com/2019/03/01/%E5%AD%90%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/03/01/子类/</id>
    <published>2019-03-01T10:05:25.000Z</published>
    <updated>2019-03-02T08:42:44.161Z</updated>
    
    <content type="html"><![CDATA[<h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><hr><p>实现继承的好处之一就是它允许你重用现有代码。通过建立继承，我们可以子类化，也就是让一个“子”对象接受“父”对象的大部分或全部属性和方法，同时保留它自己独特的方法。</p><p>假设我们有一个父 <code>Animal</code> 对象（即构造函数），其中包含诸如 <code>age</code> 和 <code>weight</code> 等属性。同一个 <code>Animal</code> 对象还可以访问 <code>eat</code> 和 <code>sleep</code> 等方法。</p><p>现在，再假设我们要创建一个 <code>Cat</code> 子对象。与描述其他动物一样，你也可以通过 <code>age</code> 或 <code>weight</code> 来描述一只猫，而且你也可以确定猫会 <code>eat</code> 和 <code>sleep</code>。因此，在创建这个 <code>Cat</code> 对象的时候，我们可以简单地重写和重新实现 <code>Animal</code> 中的所有方法和属性——或者，我们也可以让 <code>Cat</code> 从 <code>Animal</code> <strong>继承</strong> 这些现有的属性和方法，从而节省时间并防止重复代码！</p><p>我们不仅可以让 <code>Cat</code> 接受 <code>Animal</code> 的属性和方法，还可以赋予 <code>Cat</code> 独特的属性和方法！也许一只 <code>Cat</code> 具有独特的 <code>lives</code> 属性为 9，或有一个专门的 <code>meow()</code> 方法，是其他 <code>Animal</code> 所没有的。使用原型继承，<code>Cat</code> 只需要实现 <code>Cat</code> 的独特功能，并重用 <code>Animal</code> 的现有功能即可。</p><h2 id="通过原型继承"><a href="#通过原型继承" class="headerlink" title="通过原型继承"></a>通过原型继承</h2><hr><p>回想一下上一部分的原型链：</p><p><img src="/images/prototype.png" alt="原型链"></p><p>当在任何对象上调用任何属性时，JavaScript 引擎将首先在该对象中查找该属性（即该对象自己的、非继承的属性）。如果没有找到该属性，JavaScript 将查看该对象的原型。如果在对象原型中 <strong>仍然</strong> 找不到该属性，则 JavaScript 将在原型链上继续搜索。</p><p><strong>JavaScript 中的继承重点就是建立原型链。</strong></p><h2 id="秘密链接"><a href="#秘密链接" class="headerlink" title="秘密链接"></a>秘密链接</h2><hr><p>如你所知，在尝试搜索一个不存在于某个对象中的属性时，该对象的构造函数的原型是被首先搜索的。请考虑以下具有两个属性 <code>claws</code> 和 <code>diet</code> 的 <code>bear</code> 对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bear = &#123;</span><br><span class="line">    claws: <span class="literal">true</span>,</span><br><span class="line">    diet: <span class="string">'carnivore'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>让我们将以下 <code>PolarBear()</code> 构造函数的 <code>prototype</code> 属性赋为 <code>bear</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PolarBear</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PolarBear.prototype = bear;</span><br></pre></td></tr></table></figure><p>现在，让我们调用 PolarBear() 构造函数来创建一个新的对象，然后给它两个属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> snowball = <span class="keyword">new</span> PolarBear();</span><br><span class="line"></span><br><span class="line">snowball.color = <span class="string">'white'</span>;</span><br><span class="line"></span><br><span class="line">snowball.favoriteDrink = <span class="string">'cola'</span>;</span><br></pre></td></tr></table></figure><p><code>snowball</code> 对象目前看起来像这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    color: <span class="string">'white'</span>,</span><br><span class="line">    favoriteDrink: <span class="string">'cola'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>snowball</code> 只有两个自己的属性：<code>color</code> 和 <code>favoriteDrink</code>。但是，<code>snowball</code> 也可以访问自身并不具有的属性：<code>claws</code> 和 <code>diet</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(snowball.claws);</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(snowball.diet);</span><br><span class="line"><span class="comment">//'carnivore'</span></span><br></pre></td></tr></table></figure><p>由于 claw 和 diet 都作为 <code>prototype</code> 对象中的属性存在，因此它们会被查找，因为对象被秘密链接到其构造函数的 <code>prototype</code> 属性。</p><p>太棒了！但你可能会想：这个通向 <code>prototype</code> 对象的秘密链接到底是什么呢？当从 <code>PolarBear()</code> 构造函数构造对象之后（如 <code>snowball</code>），这些对象可以立即访问 <code>PolarBear()</code> 的原型中的属性。这究竟是怎么做到的呢？</p><p>事实证明，这个秘密链接是 <code>snowball</code> 的 <code>__proto__</code> 属性（注意每一端有两个下划线）。</p><p><code>__proto__</code> 是构造函数所创建的所有对象（即实例）的一个属性，并直接指向该构造函数的 <code>prototype</code> 对象。让我们来看看它是什么样的！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(snowball.__proto__);</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123; claws: true, diet: 'carnivore' &#125;</span></span><br></pre></td></tr></table></figure><p>由于 <code>__proto__</code> 属性所指向的对象与 <code>PolarBear</code> 的原型 <code>bear</code> 相同，因此将它们进行比较会返回 <code>true</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(snowball.__proto__ === bear);</span><br><span class="line"></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>强烈建议不要重新分配 <strong>proto</strong> 属性，甚至不要在你编写的任何代码中使用它。</strong></p></blockquote><hr><p>首先，会有跨浏览器的兼容性问题。<br>更重要的是：由于 JavaScript 引擎会在原型链上搜索和访问属性，因此更改对象的原型可能会导致性能问题。<br>有关 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="noopener">proto</a> 的 MDN 文章甚至警告，不要在页面顶部的红色文本中使用此属性！</p><p>我们有必要知道这个秘密链接，以了解函数和对象是如何相互关联的，但你不应该使用 <code>__proto__</code> 来管理继承。如果你只是需要查看对象的原型，则仍然可以使用 <code>Object.getPrototypeOf()</code> 来达到目的。</p><hr><blockquote><p><strong>如果只继承原型呢？</strong></p></blockquote><hr><blockquote><p>假设我们希望一个 <code>Child</code> 对象从一个 <code>Parent</code> 对象继承。为什么不应该只设置 <code>Child.prototype = Parent.prototype</code> 呢？</p></blockquote><blockquote><p>首先，还记得吗，对象是通过<em>引用来传递的。这意味着，由于 <code>Child.prototype</code> 对象和 <code>Parent.prototype</code> 对象引用的是同一个对象</em>，因此你对 <code>Child</code> 的原型所作的任何更改也会被应用于 <code>Parent</code> 的原型！我们可不希望子对象能够修改其父对象的属性！</p></blockquote><blockquote><p>最重要的是，这样做不会创建原型链。如果我们想让一个对象从我们想要的任何对象进行继承，而不仅仅是它的原型呢？</p></blockquote><blockquote><p>我们仍然需要一种方式来有效地管理继承，同时又完全不会改变原型。</p></blockquote><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><hr><blockquote><p>请考虑以下代码:</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuineaPig</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.isCute = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> waffle = <span class="keyword">new</span> GuineaPig(<span class="string">'Waffle'</span>);</span><br></pre></td></tr></table></figure><p><code>waffle.__proto__</code>指向什么？</p><p><strong>参考答案：</strong> <code>GuineaPig.prototype</code></p><blockquote><p>请考虑以下代码:</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params">color, year</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">    <span class="keyword">this</span>.year = year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype.drive = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Vroom vroom!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> Car(<span class="string">'silver'</span>, <span class="number">1988</span>);</span><br></pre></td></tr></table></figure><p>当 <code>car.drive()</code> 被调用时，会发生什么？</p><p><strong>参考答案：</strong></p><table><thead><tr><th style="text-align:center">顺序</th><th style="text-align:center">事件</th></tr></thead><tbody><tr><td style="text-align:center">第一</td><td style="text-align:center">JavaScript引擎在<code>car</code>对象内搜索名为<code>drive</code>的属性</td></tr><tr><td style="text-align:center">第二</td><td style="text-align:center">JavaScript引擎在<code>car</code>对象中找不到<code>drive</code>属性</td></tr><tr><td style="text-align:center">第三</td><td style="text-align:center">然后，JavaScript引擎会访问<code>car.__proto__</code>属性</td></tr><tr><td style="text-align:center">第四</td><td style="text-align:center">由于<code>car.__proto__</code>指向<code>Car.prototype</code>,因此JavaScript引擎会在该原型中搜索<code>drive</code></td></tr><tr><td style="text-align:center">第五</td><td style="text-align:center">由于<code>Car.prototype.drive</code>是一个已定义的属性，因此它会被返回</td></tr><tr><td style="text-align:center">第六</td><td style="text-align:center">最后，由于<code>drive</code>作为一个方法在<code>car</code>上被调用，因此<code>this</code>的值会被设置为<code>car</code></td></tr></tbody></table><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><hr><p>到目前为止，我们在继承方面遇到了一些问题。首先，虽然 <code>__proto__</code> 可以访问被调用的对象的原型，但是在你编写的代码中使用它并不是好习惯。</p><p>另一方面，我们也不应该_只_继承原型；这样做不会创建原型链，而且我们对子对象所作的任何更改也会反映在父对象中。</p><p>那么，我们应该如何继续往前呢？</p><p>实际上，我们可以借助一种方式来自己设置对象的原型：使用 <code>Object.create()</code>。而且最棒的是，这种方式既可以让我们管理继承，同时又 <strong>不会</strong> 改变原型！</p><p><code>Object.create()</code> 会接受一个对象作为参数，并返回一个新的对象，其 <code>__proto__</code> 属性会被设置为传递给它的参数。然后，你只需要将所返回的对象设置为子对象构造函数的原型即可。让我们来看一个例子！</p><p>首先，假设我们有一个 <code>mammal</code> 对象，它有两个属性：<code>vertebrate</code> 和 <code>earBones</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mammal = &#123;</span><br><span class="line">    vertebrate: <span class="literal">true</span>,</span><br><span class="line">    earBones: <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还记得吗，<code>Object.create()</code> 会接受一个对象作为参数，并返回一个 <strong>新的</strong> 对象。这个新对象的 <code>__proto__</code> 属性会被设置为最初传递给 <code>Object.create()</code> 的参数。让我们把这个返回值保存到变量 <code>rabbit</code> 中：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rabbit = <span class="built_in">Object</span>.create(mammal);</span><br></pre></td></tr></table></figure><p>我们预期这个新的 <code>rabbit</code> 对象是空白的，没有自己的属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(rabbit);</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>但是，<code>rabbit</code> 现在应该已被秘密链接到 <code>mammal</code>。也就是说，它的 <code>__proto__</code> 属性应该指向 <code>mammal</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(rabbit.__proto__ === mammal);</span><br><span class="line"></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>太棒了！这意味着，现在 <code>rabbit</code> 扩展了 <code>mammal</code>（即 <code>rabbit</code> 继承自 <code>mammal</code>），而且 <code>rabbit</code> 可以将 <code>mammal</code> 的属性当作自己的属性一样进行访问！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(rabbit.vertebrate);</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(rabbit.earBones);</span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure><p><code>Object.create()</code> 给了我们一个在 JavaScript 中建立原型继承的简洁方法。我们可以通过这种方式轻松扩展原型链，而且可以让对象从我们想要的任何对象进行继承！</p><p>下面让我们来看一个更复杂的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.walk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> walks!`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.lives = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个 Animal 构造函数，以及一个在 Animal 的原型上直接定义的 walk 方法，此外，还有一个 Cat 构造函数，你可能注意到，我们在 Cat 构造函数中使用了 call 方法，并且直接在 Animal 构造函数 中调用它。</p><p>我们使用 call 而不是关键字 new ，因为我们不想构造一个全新的 animal 对象。我们只关心 cat 实例或 cat 对象上的 animal 初始化逻辑，call 方法的作用是调用 Animal 并将 this 设为 cat 实例，否则 <code>this.name</code> 将是 <code>undefined</code>。</p><p>现在，有了这个继承自 Animal 的 Cat:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Cat.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line"><span class="comment">// Animal&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>我们还需要更改构造函数, 否则所有的 cat 对象的构造函数将设为 animal：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f Cat(name)&#123;</span></span><br><span class="line"><span class="comment">//     Animal.call(this, name);</span></span><br><span class="line"><span class="comment">//     this.lives = 9; </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>现在，我们向 cat 的原型添加一个 使所有 cat 对象都能共享的方法: Meow</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Cat.prototype.meow = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Meow!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f () &#123;</span></span><br><span class="line"><span class="comment">//    console.log('Meow!');</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>使用关键字 new 调用 cat 构造函数，并初始化新的 cat 对象 称之为 Bambi：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bambi = <span class="keyword">new</span> Cat(<span class="string">'Bambi'</span>);</span><br><span class="line"></span><br><span class="line">bambi.meow(); <span class="comment">// Meow!</span></span><br><span class="line">bambi.walk(); <span class="comment">// Bambi walks!</span></span><br><span class="line"></span><br><span class="line">bambi.name; <span class="comment">// "Bambi"</span></span><br></pre></td></tr></table></figure><blockquote><p>总结下，为了在JavaScript 中有效地管理继承,一个很好的方式是避免完全更改原型   ，为此，我们可以使用 <code>object.create</code></p></blockquote><h3 id="小练习-1"><a href="#小练习-1" class="headerlink" title="小练习"></a>小练习</h3><hr><blockquote><p>请考虑以下代码：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child();</span><br></pre></td></tr></table></figure><p>当 <code>child instanceof Parent;</code> 被执行时，什么会被输出到控制台？</p><p><strong>参考答案：</strong> <code>true</code></p><blockquote><p>以下哪一项有关 <code>Object.create()</code> 的说法是正确的？请选择所有适用项：</p></blockquote><ul><li>它会返回一个新的对象，其 <code>__proto__</code> 属性会被设置为传递给 <code>Object.create()</code> 的对象</li><li>使用 <code>Object.create()</code> ，我们可以让对象从我们想要的任何对象进行继承(即不仅是<code>prototype</code>)</li><li><code>Object.create()</code>让我们既可以实现原型继承，又不会改变原型</li><li>该方法直接在一个对象上被调用</li></ul><p><strong>参考答案：</strong> <code>1、2、3</code></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr><p>JavaScript 中的继承重点就是建立原型链。这让我们可以子类化，也就是创建一个“子”对象，让它继承“父”对象的大部分或全部属性和方法。然后，我们可以分别实现任何子对象的独特属性和方法，同时仍然保留其父对象的数据和功能。</p><p>对象（实例）通过该实例的 <code>__proto__</code> 属性被秘密链接到其构造函数的原型对象。 你不应该在你编写的任何代码中使用 <code>__proto__</code>。在任何代码中使用 <code>__proto__</code>，或者只继承原型，将会直接导致某些不必要的问题。要在 JavaScript 中高效地管理继承，一个有效的方式就是避免完全改变原型。</p><p><code>Object.create()</code> 可以帮助我们做到这一点，它可以接受一个父对象，返回一个 <strong>新的</strong> 对象，并将其 <code>__proto__</code> 属性设置为该父对象。</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><hr><ul><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">继承和原型链</a></p></li><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">Object.create()</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;子类&quot;&gt;&lt;a href=&quot;#子类&quot; class=&quot;headerlink&quot; title=&quot;子类&quot;&gt;&lt;/a&gt;子类&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;实现继承的好处之一就是它允许你重用现有代码。通过建立继承，我们可以子类化，也就是让一个“子”对象接受“父”对象的大部分或全部属性和
      
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="prototype" scheme="http://yoursite.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>原型继承</title>
    <link href="http://yoursite.com/2019/03/01/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2019/03/01/原型继承/</id>
    <published>2019-03-01T08:16:59.000Z</published>
    <updated>2019-03-02T08:49:29.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型、原型链"><a href="#原型、原型链" class="headerlink" title="原型、原型链"></a>原型、原型链</h2><hr><blockquote><p>JavaScript 常被描述为一种基于原型的语言 (prototype-based language)。每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p></blockquote><p>准确地说，这些属性和方法定义在 Object的构造器函数(constructor functions)之上的 <code>prototype</code> 属性上，而非对象实例本身。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr><p>我的父母是黑色头发，我也是黑色的头发。可以看出，我从我父母那里遗传了黑头发基因。</p><p>在 JavaScript 中 继承是指一个对象基于另一个对象。</p><blockquote><p>假设有一个新建的 car 对象的构造函数，每个 car 对象都具有不同的颜色属性值，例如 红色、蓝色和绿色；对象不仅具有自己的属性，而且与通用对象秘密关联，这种通用对象称之为原型；我们可以向原型中添加 car 对象都能共享的方法 drive方法 ，因此在每次新建一个 car 时，它们可以共享相同的 drive 方法，而不是创建新的 drive 方法。</p></blockquote><p>和其他语言不同，JavaScript 利用原型来管理继承。</p><h2 id="添加方法到原型"><a href="#添加方法到原型" class="headerlink" title="添加方法到原型"></a>添加方法到原型</h2><hr><p>还记得吗，对象包含数据（即属性）和操纵数据的手段（即方法）。在此之前，我们都是将方法直接添加到构造函数本身：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lives = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Meow! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过将一个函数保存到新创建的 <code>Cat</code> 对象的 <code>sayName</code> 属性中，可以将 <code>sayName()</code> 方法添加到所有 <code>Cat</code> 对象上。这样做没问题，但是如果我们想用这个构造函数实例化更多的 <code>Cat</code> 对象呢？你每一次都要为这个 <code>Cat</code> 对象的 <code>sayName</code> 创建一个新的函数！更重要的是：如果你想对方法进行更改，则必须<em>逐个更新所有对象。在这种情况下，最好是让同一个 <code>Cat</code> 构造函数所创建的所有对象共享</em>一个 <code>sayName</code> 方法。</p><p>为了节省内存并保持简洁，我们可以在构造函数的 <code>prototype</code> 属性中添加方法。原型只是一个对象，构造函数所创建的所有对象都会保持对原型的引用。这些对象甚至可以将       <code>prototype</code> 的属性当作自身属性来使用！</p><p>JavaScript 利用对象与其原型之间的这个秘密链接来实现继承。请考虑以下原型链：</p><p><img src="/images/prototype.png" alt="原型链"></p><p>还记得吗，每个函数都有一个 <code>prototype</code> 属性，它其实只是一个对象。当使用 new 运算符将该函数作为构造函数来调用时，它会创建并返回一个新的对象。该对象被秘密地链接到其构造函数的 <code>prototype</code>，而这个秘密链接让该对象可以访问 <code>prototype</code> 的属性和方法，就像它自己的一样！</p><p>由于我们知道 <code>prototype</code> 属性仅仅指向一个普通对象，因此<em>这个对象本身也有一个秘密链接指向它的原型。而且，这个原型对象也有引用指向它自己的</em>原型，以此类推。原型链就是这样形成的。</p><p>无论你是访问属性（例如 <code>bailey.lives</code>）还是调用方法（即 <code>bailey.meow()</code>），JavaScript 解释器都会按照特定的顺序在原型链中查找它们：</p><ul><li>首先，JavaScript 引擎将查看对象自身的属性。这意味着，直接在该对象中定义的任何属性和方法将优先于其他位置的任何同名属性和方法（类似于作用域链中的变量阴影）。</li><li>如果找不到目标属性，它将搜索对象的构造函数的原型，以寻找匹配。</li><li>如果原型中不存在该属性，则 JavaScript 引擎将沿着该链继续查找。</li><li>该链的最顶端是 Object() 对象，也就是顶级父对象。如果 <strong>仍然</strong> 找不到该属性，则该属性为未定义。</li></ul><p>之前，我们都是直接在构造函数中定义方法。让我们来看看，如果我们转而在构造函数的 prototype 中定义方法，情况又会如何！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">age, weight, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.bark = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> says woof!`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这是 Dog 构造函数，我们可以调用它来创建一个具有以下四种属性的对象：age, weight, name 和 bark， 可以在构造器中定义 bark 方法，我们也可以将 bark 方法移到 dog 的原型中，直接使用点记法来定义 bark，像这样:</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Dog.prototype.bark = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> says woof!`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>函数就变为:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">age, weight, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype.bark = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> says woof!`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们将调用 dog 的构造函数来创建一个新的对象, 并调用这个新的 dog 的 bark方法:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dog1 = <span class="keyword">new</span> Dog(<span class="number">2</span>, <span class="number">60</span>, <span class="string">'Java'</span>);</span><br><span class="line"></span><br><span class="line">dog2 = <span class="keyword">new</span> Dog(<span class="number">4</span>, <span class="number">55</span>, <span class="string">'Jodi'</span>);</span><br><span class="line"></span><br><span class="line">dog1.bark();  <span class="comment">// Java says woof!</span></span><br><span class="line"></span><br><span class="line">dog2.bark();  <span class="comment">// Jodi says woof!</span></span><br></pre></td></tr></table></figure><p>让我们回顾一下，发生了什么？</p><blockquote><p>当我们在新建的 dog 对象中调用 bark 方法时，JavaScript 引擎会查看自己的属性，尝试找到与 bark 方法相匹配的名称，由于 bark 没有直接定义在这个 dog 上，它会看看 bark 方法的原型，最后，我们不需要调用 <code>dog.prototype.bark()</code>，我们只需要调用 <code>dog.bark()</code> 就会起作用，因为这个 dog 对象已经通过它的原型与 bark 方法联系起来了。</p></blockquote><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><hr><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (A)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dalmatian</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.bark = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> barks!`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (B)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dalmatian</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dalmatian.prototype.bark = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> barks!`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>假设我们想定义一个可以在 Dalmatian 构造函数的实例（对象）上调用的方法（我们将会实例化至少 101 个对象！）。前面两种方式中的哪一种是最佳选择？</p></blockquote><p><strong>参考答案：</strong> <code>(B)是最佳选择，因为每次创建 Dalmatian 的实例时，将不需要重新创建 bark 所指向的函数。</code></p><h2 id="替换-prototype-对象"><a href="#替换-prototype-对象" class="headerlink" title="替换 prototype 对象"></a>替换 <code>prototype</code> 对象</h2><hr><p>如果完全替换某个函数的 prototype 对象，结果会怎样？这将如何影响该函数所创建的对象？让我们来看一个简单的 Hamster 构造函数，并实例化一些对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hamster</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.hasFur = <span class="literal">true</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> waffle = <span class="keyword">new</span> Hamster(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pancake = <span class="keyword">new</span> Hamster();</span><br></pre></td></tr></table></figure><p>首先要注意的是，在创建新的对象 waffle 和 pancake 之后，我们仍然可以为 Hamster 的原型添加属性，而且它仍然可以访问这些新的属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Hamster.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Chomp chomp chomp!'</span>); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">waffle.eat(); <span class="comment">// 'Chomp chomp chomp!'</span></span><br><span class="line"></span><br><span class="line">pancake.eat(); <span class="comment">// 'Chomp chomp chomp!'</span></span><br></pre></td></tr></table></figure><p>现在，让我们将 <code>Hamster</code> 的 <code>prototype</code> 对象完全替换为其他内容：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Hamster.prototype = &#123;</span><br><span class="line">    isHungry: <span class="literal">false</span>,</span><br><span class="line">    color: <span class="string">'brown'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先前的对象无法访问更新后的原型的属性；它们只会保留与旧原型的秘密链接：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(waffle.color); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">waffle.eat(); <span class="comment">// 'Chomp chomp chomp!'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pancake.isHungry); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>事实证明，此后创建的任何新的 <code>Hamster</code> 对象都会使用更新后的原型：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> muffin = <span class="keyword">new</span> Hamster();</span><br><span class="line"></span><br><span class="line">muffin.eat(); <span class="comment">// TypeError: muffin.eat is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(muffin.isHungry); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(muffin.color); <span class="comment">// 'brown'</span></span><br></pre></td></tr></table></figure><h2 id="检查对象的属性"><a href="#检查对象的属性" class="headerlink" title="检查对象的属性"></a>检查对象的属性</h2><hr><p>正如我们刚刚所看到的，如果一个对象本身没有某个特定属性，它可以访问原型链中某个这样的属性（当然，假设它是存在的）。由于选择很多，有时可能会不好判断某个特定的属性究竟来自哪里！这里有一些有用的方法可以帮助你进行判断。</p><h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h3><hr><p><code>hasOwnProperty()</code> 可以帮助你找到某个特定属性的来源。在向其传入你要查找的属性名称的字符串后，该方法会返回一个布尔值，指示该属性是否属于该对象本身（即该属性 <strong>不是</strong> 被继承的）。请考虑在函数中直接定义一个属性的 <code>Phone</code> 构造函数，以及它的 <code>prototype</code> 对象的另一个属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.operatingSystem = <span class="string">'Android'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Phone.prototype.screenSize = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>现在，让我们创建一个新的对象 myPhone，并检查 operatingSystem 是否为其本身的属性，也就是说，它不是从该对象的原型（或原型链上的其他地方）继承来的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPhone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> own = myPhone.hasOwnProperty(<span class="string">'operatingSystem'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(own);</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>它确实返回为真！那么，Phone 对象的 prototype 上的 screenSize 属性又如何呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inherited = myPhone.hasOwnProperty(<span class="string">'screenSize'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(inherited);</span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>使用 <code>hasOwnProperty()</code>，我们可以洞察某个属性的来源。</p><h3 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a>isPrototypeOf()</h3><hr><p>对象还可以访问 <code>isPrototypeOf()</code> 方法，该方法可以检查某个对象是否存在于另一个对象的原型链中。 使用这种方法，你可以确认某个特定的对象是否是另一个对象的原型。请看以下 <code>rodent</code> 对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rodent = &#123;</span><br><span class="line">    favoriteFood: <span class="string">'cheese'</span>,</span><br><span class="line">    hasTail: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，让我们来构建一个 <code>Mouse()</code> 构造函数，并将它的 <code>prototype</code> 赋给 <code>rodent</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mouse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.favoriteFood = <span class="string">'cheese'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mouse.prototype = rodent;</span><br></pre></td></tr></table></figure><p>如果我们创建一个新的 <code>Mouse</code> 对象，它的原型应该是 <code>rodent</code> 对象。让我们来确认一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ralph = <span class="keyword">new</span> Mouse();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = rodent.isPrototypeOf(ralph)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>太棒了！<code>isPrototypeOf()</code> 是确认某个对象是否存在于另一个对象的原型链中的好办法。</p><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><hr><p><code>isPrototypeOf()</code> 很有用处，但要记住，要想使用它，你必须首先掌握原型对象！如果你不确定某个对象的原型是什么呢？<code>Object.getPrototypeOf()</code> 可以帮助你解决这个问题。</p><p>使用前面的例子，让我们将 <code>Object.getPrototypeOf()</code> 的返回值存储在变量 <code>myPrototype</code> 中，然后检查它是什么：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPrototype = <span class="built_in">Object</span>.getPrototypeOf(ralph);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myPrototype);</span><br><span class="line"><span class="comment">//&#123; favoriteFood: "cheese", hasTail: true &#125;</span></span><br></pre></td></tr></table></figure><p>太棒了！<code>ralph</code> 的原型 <code>rodent</code> 对象 与 返回的结果 具有相同的属性，因为它们就是同一个对象。 <code>Object.getPrototypeOf()</code> 很适合检索给定对象的原型。</p><h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><hr><p>每次创建一个对象时，都会有一个特殊的属性被暗中分配给它：<code>constructor</code>。</p><p>访问一个对象的 <code>constructor</code> 属性会返回一个对创建该对象的构造函数的引用！</p><p>以下是一个简单的 <code>Longboard</code> 构造函数。我们还会继续创建一个新的对象，然后将其保存到一个 <code>board</code> 变量中：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Longboard</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.material = <span class="string">'bamboo'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> board = <span class="keyword">new</span> Longboard();</span><br></pre></td></tr></table></figure><p>如果我们访问 <code>board</code> 的 <code>constructor</code> 属性，我们应该会看到原来的构造函数本身：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(board.constructor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// function Longboard() &#123;</span></span><br><span class="line"><span class="comment">//    this.material = 'bamboo';</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>好极了！请记住，如果某个对象是使用字面量表示法创建的，那么它的构造函数就是内置的 <code>Object()</code> 构造函数！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rodent = &#123;</span><br><span class="line">    teeth: <span class="string">'incisors'</span>,</span><br><span class="line">    hasTail: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(rodent.constructor);</span><br><span class="line"><span class="comment">//function Object() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><h3 id="小练习-1"><a href="#小练习-1" class="headerlink" title="小练习"></a>小练习</h3><hr><blockquote><p>以下哪一项有关 <code>hasOwnProperty()</code> 的说法是正确的？请选择所有适用项：</p></blockquote><ul><li>一个对象会作为参数传递给 <code>hasOwnProperty</code></li><li>它会返回一个布尔值，指示对象是否具有所指定的属性作为其本身属性(即该属性不是被继承的)</li><li>一个字符串不能作为参数传递给 <code>hasOwnProperty()</code></li><li><code>hasOwnProperty()</code> 作为一个方法被调用到一个对象</li></ul><p><strong>参考答案：</strong> 2、4</p><blockquote><p>以下哪一项有关 <code>isProtypeOf()</code> 或 <code>getPrototypeOf()</code> 的说法是正确的？请选择所有适用项：</p></blockquote><ul><li><code>isProtypeOf()</code> 可以检查某个对象是否存在于另一个对象的原型链中</li><li><code>isProtypeOf()</code> 会接受一个参数：一个原型链将被搜索的对象</li><li><code>getProtypeOf()</code> 在构造函数的一个实例(即单个对象本身)上被调用</li><li><code>getProtypeOf()</code> 会返回传递给它的对象的原型</li></ul><p><strong>参考答案：</strong> 2、4</p><blockquote><p>以下哪一项有关 <code>constructor</code> 属性的说法是正确的？请选择所有适用项：</p></blockquote><ul><li>访问一个对象的 <code>constructor</code> 属性会返回一个对创建该对象(实例)的构造函数的引用</li><li><code>constructor</code> 属性的值只是构造函数名称的一个字符串，而不是该函数本身</li><li>每个对象都有一个 <code>constructor</code> 属性</li><li>使用字面量表示法创建的对象是用 <code>Object()</code> 构造函数构建的</li></ul><p><strong>参考答案：</strong> 1、3、4</p><blockquote><p>假设我们使用常规的对象字面量表示法来创建以下对象 <code>capitals</code>：<br>当 Object.getPrototypeOf(capitals); 被执行时，会返回什么？</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> capitals = &#123;</span><br><span class="line">    California: <span class="string">'Sacramento'</span>,</span><br><span class="line">    Washington: <span class="string">'Olympia'</span>,</span><br><span class="line">    Oregon: <span class="string">'Salem'</span>,</span><br><span class="line">    Texas: <span class="string">'Austin'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>参考答案：</strong> 对 <code>Object()</code> 原型的引用</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr><p>JavaScript 中的继承是指一个对象基于另一个对象。继承让我们可以重用现有的代码，使对象具有其他对象的属性。</p><p>当使用 new 运算符将一个函数作为构造函数来调用时，该函数会创建并返回一个新的对象。这个对象会被秘密链接到其构造函数的 <code>prototype</code>，而它只是另一个对象。使用这个秘密链接，可以让一个对象访问原型的属性和方法，就像是它自己的一样。如果 JavaScript 没有在某个对象中找到一个特定属性，它将在原型链上继续查找。如有必要，它会一路查找到 <code>Object()</code>（顶级父对象）。</p><ul><li>对象如何查看对象的构造函数 –&gt; <code>obj.constructor</code> 属性</li><li>对象如何查看原型 –&gt; 隐式属性 <code>__proto__</code></li><li>修改原型 –&gt; <code>obj.prototype.xxx = xxx</code></li><li>(原型链的终端)绝大多数对象的最终原型: <code>Object.prototype</code></li></ul><p>为了更理解 原型 / 构造函数 / 实例 三者的关系，请看下面这张图：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实例.__proto__ === 原型</span><br><span class="line">构造函数.prototype === 原型</span><br><span class="line">原型.constructorr === 构造函数</span><br></pre></td></tr></table></figure><p><img src="/images/prototype1.png" alt="原型 / 构造函数 / 实例"></p><p>此外，我们还介绍了几个方法和属性，可以用于检查对象及其原型的来源和引用，即：</p><ul><li>hasOwnProperty()</li><li>isPrototypeOf()</li><li>Object.getPrototypeOf()</li><li>constructor</li></ul><p>在下一部分，我们将从子类化的角度来探索原型继承的另一方面。如果你想从一个对象中只继承几个属性，但是又想让这个对象具有其他专有属性，该怎么办呢？我们将在下一部分对原型继承进行更深入的探讨。</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><hr><ul><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="noopener">hasOwnProperty()</a></p></li><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf" target="_blank" rel="noopener">isPropertyOf()</a></p></li><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noopener">Object.getPrototypeOf()</a></p></li><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="noopener">constructor</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原型、原型链&quot;&gt;&lt;a href=&quot;#原型、原型链&quot; class=&quot;headerlink&quot; title=&quot;原型、原型链&quot;&gt;&lt;/a&gt;原型、原型链&lt;/h2&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript 常被描述为一种基于原型的语言 (prototype
      
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="prototype" scheme="http://yoursite.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>设置自己的this</title>
    <link href="http://yoursite.com/2019/02/28/%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84this/"/>
    <id>http://yoursite.com/2019/02/28/设置自己的this/</id>
    <published>2019-02-28T10:10:35.000Z</published>
    <updated>2019-03-02T08:46:50.096Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道 根据函数的调用方式 <code>this</code> 会设成不同的值，<code>Javascript</code> 提供了几种设置 <code>this</code>值的方法:</p><ul><li>call()</li><li>apply()</li><li>bind()</li></ul><blockquote><p><code>call</code> 和 <code>apply</code> 作为方法在函数上被调用，会因为参数的传入方式不同而有所不同，<code>bind</code> 是返回新函数的方法.</p></blockquote><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><hr><p><code>call()</code> 是一个直接调用到函数上的方法。我们传递给它一个单一的值，以设置为 this 的值，然后逐个传入该函数的任何参数，用逗号分隔。</p><p>请考虑以下函数 multiply()，它只会返回其两个参数的乘积：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1 * n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们在控制台中调用它：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">multiply(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>这里没有任何惊喜！但现在，让我们使用 <code>call()</code> 方法来调用同一个函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">multiply.call(<span class="built_in">window</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>我们得到了相同的结果！这是怎么发生的？我们首先直接调用 <code>call()</code> 方法到 <code>multiply()</code> 函数上。请注意，<code>.call(window, 3, 4)</code> 之前的 <code>multiply</code> 后​​面没有任何括号！ <code>call()</code> 将会处理该调用 和 <code>multiply()</code> 函数的参数本身！</p><p>这一步完成后，我们传递将设置为 <code>this</code> 的值作为 <code>call()</code> 的第一个参数：<code>window</code>。最后，我们逐个传递 <code>multiply()</code> 函数的参数，并用逗号分隔。</p><p>当 <code>multiply.call(window, 3, 4)</code>; 执行后，该函数将以 <code>this</code> 的给定值被调用，我们所看到的结果就是 12。在严格模式之外，调用 <code>multiply()</code> 的这两种方式是等价的。</p><p>除了调用常规函数之外，我们如何调用附加到对象上的函数（即方法）呢？这是 <code>call()</code> 真正发挥强大功能的地方。使用 <code>call()</code> 来调用方法允许我们从对象中“借用”方法，然后将其用于另一个对象！请看以下对象 <code>mockingbird</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mockingbird = &#123;</span><br><span class="line">    title: <span class="string">'To Kill a Mockingbird'</span>,</span><br><span class="line">    describe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.title&#125;</span> is a classic novel`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以让 <code>mockingbird</code> 调用自己的 <code>describe()</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mockingbird.describe();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'To Kill a Mockingbird is a classic novel'</span></span><br></pre></td></tr></table></figure><p>但是，借助 <code>call()</code>，以下 <code>pride</code> 对象可以使用 <code>mockingbird</code> 的 <code>describe()</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pride = &#123;</span><br><span class="line">    title: <span class="string">'Pride and Prejudice'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mockingbird.describe.call(pride);</span><br><span class="line"><span class="comment">// 'Pride and Prejudice is a classic novel'</span></span><br></pre></td></tr></table></figure><p>让我们来分析一下当 <code>mockingbird.describe.call(pride)</code>; 被执行时，究竟发生了什么！首先，<code>call()</code> 方法被调用到 <code>mockingbird.describe</code>（它指向一个函数）上。然后，<code>this</code> 的值被传递给 <code>call()</code> 方法：<code>pride</code>。</p><p>由于 <code>mockingbird</code> 的 <code>describe()</code> 方法引用了 <code>this.title</code>，我们需要访问 this 所指向的对象的 <code>title</code> 属性。但是，由于我们已经设置了自己的 <code>this</code> 的值，<code>this.title</code> 的值将会从 <code>pride</code> 对象中被访问！结果，<code>mockingbird.describe.call(pride)</code>; 被执行，我们在控制台中看到 <code>&#39;Pride and Prejudice is a classic novel&#39;</code>。</p><p>如果你打算在传递给它的第一个参数的作用域内调用一个函数，那么 <code>call()</code> 是非常有效的。同样，我们可以利用 <code>apply()</code> 方法达到相同的目的，尽管在参数传入的方式上有所不同。让我们来仔细看看！</p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><hr><p>就像 <code>call()</code> 一样，<code>apply()</code> 在一个函数上被调用，不仅可以调用该函数，而且还可以为它关联一个特定的 this 值。但是，<code>apply()</code> 并不是逐个传递参数并用逗号分隔，而是将函数的参数放在一个_数组_中。请回想一下之前的 <code>multiply()</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1 * n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用了 <code>call()</code>，并逐个传递参数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">multiply.call(<span class="built_in">window</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>然而，使用 <code>apply()</code>，我们则是将 <code>multiply()</code> 函数的所有参数收集到一个数组中，然后再将这个数组传递给 <code>apply()</code>：</p><p>太棒了！那么，使用 <code>apply()</code> 来调用对象的方法，又会怎样呢？请回想一下之前的 <code>mockingbird</code> 和 <code>pride</code> 对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mockingbird = &#123;</span><br><span class="line">    title: <span class="string">'To Kill a Mockingbird'</span>,</span><br><span class="line">    describe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.title&#125;</span> is a classic novel`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pride = &#123;</span><br><span class="line">    title: <span class="string">'Pride and Prejudice'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之前，我们使用了 <code>call()</code> 来允许 <code>pride</code> 对象”借用” <code>mockingbird</code> 的 <code>describe()</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mockingbird.describe.call(pride);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'Pride and Prejudice is a classic novel'</span></span><br></pre></td></tr></table></figure><p>我们可以使用 apply() 来达到相同的结果！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mockingbird.describe.apply(pride);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'Pride and Prejudice is a classic novel'</span></span><br></pre></td></tr></table></figure><p>请注意，传递给 <code>call()</code> 和 <code>apply()</code> 的第一个参数是相同的（即绑定 this 值的对象）。由于 <code>describe()</code> 方法不接受任何参数，因此 <code>mockingbird.describe.call(pride)</code>; 和 <code>mockingbird.describe.apply(pride)</code>; 唯一的区别就是方法！这两种方法都会产生相同的结果。</p><h2 id="偏向选择其中一种方法"><a href="#偏向选择其中一种方法" class="headerlink" title="偏向选择其中一种方法"></a>偏向选择其中一种方法</h2><hr><p><code>call()</code> 和 <code>apply()</code> 都会在其传入的第一个参数（即作为 this 值的对象）的作用域内调用一个函数。那么，你什么时候会偏向于选择 <code>call()</code>，或偏向于选择 <code>apply()</code> 呢？</p><p>如果你事先并不知道函数所需要的参数个数，那么 <code>call()</code> 的使用可能会受到限制。在这种情况下，<code>apply()</code> 是一个更好的选择，因为它只接受一个参数数组，然后将其解包并传递给函数。请记住，解包可能会略微影响性能，但这种影响并不显著。</p><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><blockquote><p>请考虑以下 dave 对象和 sayHello() 函数：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dave = &#123;</span><br><span class="line">    name: <span class="string">'Dave'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;message&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>. You're looking well today.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设你想将消息 <code>&#39;Hello, Dave. You&#39;re looking well today.&#39;</code> 输出到控制台。你应该编写哪个表达式来达到这个目的？</p><p><strong>参考答案：</strong> sayHello.apply(dave, [‘Hello’]);</p><blockquote><p>请考虑以下 Andrew 和 Richard 对象：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Andrew = &#123;</span><br><span class="line">    name: <span class="string">'Andrew'</span>,</span><br><span class="line">    introduce: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Richard = &#123;</span><br><span class="line">    name: <span class="string">'Richard'</span>,</span><br><span class="line">    introduce: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Hello there! I'm <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 <code>Richard.introduce.call(Andrew)</code>; 被执行时，什么会被记录到控制台？</p><p><strong>参考答案：</strong> <code>&#39;Hello there! I&#39;m Andrew.&#39;</code></p><blockquote><p>请考虑以下代码：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> andrew = &#123;</span><br><span class="line">    name: <span class="string">'Andrew'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">introduce</span>(<span class="params">language</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I'm <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and my favorite programming language is <span class="subst">$&#123;language&#125;</span>.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请编写一个表达式，使用 call() 方法产生以下消息：<br><code>&#39;I&#39;m Andrew and my favorite programming language is JavaScript.&#39;</code></p><p><strong>参考答案：</strong> <code>introduce.call(andrew,&#39;JavaScript&#39;)</code></p><h2 id="回调和-this"><a href="#回调和-this" class="headerlink" title="回调和 this"></a>回调和 <code>this</code></h2><hr><p>当涉及到回调函数时，this 的值有一些潜在的作用域问题，事情会变得比较棘手。接下来，让我们来看看这个问题。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeTwice</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">    age: <span class="number">5</span>,</span><br><span class="line">    growOneYear: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先，调用 <code>growOneYear()</code> 按预期运作，将 <code>dog</code> 对象的 <code>age</code> 属性的值从 <code>5</code> 更新为 <code>6</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dog.growOneYear();</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">dog.age; </span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>但是，将 <code>dog.growOneYear</code>（一个函数）作为参数传递给 <code>invokeTwice()</code> 则会产生不希望的结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">invokeTwice(dog.growOneYear);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">dog.age; </span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>这是什么原因呢？事实证明，invokeTwice() 确实会调用 growOneYear，但它是被调用为一个 <strong>函数而不是一个方法</strong>！让我们回顾一下先前的 this 网格：</p><table><thead><tr><th style="text-align:center">Call Style</th><th style="text-align:center"><code>new</code></th><th style="text-align:center">method</th><th style="text-align:center">function</th></tr></thead><tbody><tr><td style="text-align:center"><code>this</code></td><td style="text-align:center">{}</td><td style="text-align:center">object itself</td><td style="text-align:center">global object</td></tr><tr><td style="text-align:center">Example</td><td style="text-align:center">new Cat()</td><td style="text-align:center">bailey.sayName()</td><td style="text-align:center">introduce()</td></tr></tbody></table><blockquote><p>如果使用 <code>new</code> 运算符来调用构造函数，<code>this</code> 的值将被设置为新创建的对象，如果在对象上调用方法，<code>this</code> 将被设置为该对象本身，如果简单地调用一个函数，<code>this</code> 将被设置为全局对象: <code>window</code></p></blockquote><h2 id="使用匿名闭包来保存-this"><a href="#使用匿名闭包来保存-this" class="headerlink" title="使用匿名闭包来保存 this"></a>使用匿名闭包来保存 this</h2><hr><p>还记得吗，简单地调用一个普通函数会将 <code>this</code> 的值设置为全局对象（即 <code>window</code>）。我们如何解决这个问题呢？</p><p>解决这个问题的一种方式就是使用一个匿名闭包来遮蔽 <code>dog</code> 对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">invokeTwice(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    dog.growOneYear(); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dog.age</span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>使用这种方式，调用 <code>invokeTwice()</code> 仍然会将 <code>this</code> 的值设置为 <code>window</code>。但是，这对闭包没有影响；在匿名函数中，<code>growOneYear()</code> 方法仍然会被直接调用到 <code>dog</code> 对象上。因此，<code>dog</code> 的 age 属性的值会从 5 更新为 7。</p><p>由于这是一种十分常见的模式，因此 JavaScript 提供了另一种比较简洁的方式：<code>bind()</code> 方法。</p><h2 id="使用-bind-来保存-this"><a href="#使用-bind-来保存-this" class="headerlink" title="使用 bind() 来保存 this"></a>使用 bind() 来保存 this</h2><hr><p>与 <code>call()</code> 和 <code>apply()</code> 类似，<code>bind()</code> 方法也允许用户直接为 <code>this</code> 定义一个值。<code>bind()</code> 也是一个在函数上调用的方法，但不同于 <code>call()</code> 或 <code>apply()</code>，它们都会立即调用函数——<code>bind()</code> 会返回一个新的函数。当被调用时，该函数会将 <code>this</code> 设置为我们赋给它的值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">    age: <span class="number">5</span>,</span><br><span class="line">    growOneYear: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeTwice</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">invokeTwice(dog.growOneYear);</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>因为<code>bind()</code> 会返回一个新的函数，将其保存在新的变量中，称之为 <code>myGrow</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myGrow = dog.growOneYear.bind(dog);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">invokeTwice(myGrow);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">dog.age;</span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h3 id="小练习-1"><a href="#小练习-1" class="headerlink" title="小练习"></a>小练习</h3><blockquote><p>请考虑以下 <code>driver</code> 和 <code>car</code> 对象：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> driver = &#123;</span><br><span class="line">    name: <span class="string">'Danica'</span>,</span><br><span class="line">    displayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Name: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">    name: <span class="string">'Fusion'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>请使用 <code>bind()</code> 编写一个表达式，让我们可以从 <code>driver</code> 中”借用” <code>displayName()</code> 方法，以供 <code>car</code> 对象使用。</p><p><strong>参考答案：</strong> <code>driver.displayName.bind(car)</code></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr><p>JavaScript 提供了三种方法，让我们可以为一个给定的函数设置 <code>this</code> 的值：</p><ul><li><code>call()</code> 会调用该函数，逐个传入参数，并用逗号分隔。</li><li><code>apply()</code> 与 <code>call()</code> 类似；它会照样调用该函数，但它会将参数作为一个数组传入。</li><li><code>bind()</code> 会返回一个新的函数，并将 this 绑定到一个特定对象，让我们可以按照函数的样式来调用它。<br>如需进一步研究，我们建议你查看 Kyle Simpson 有关 this 的你不了解 JS 系列，链接已在下方提供。</li></ul><p>到目前为止，你已经看到函数、对象和 this 关键字是如何相互关联的。你也看到了 JavaScript 中的几乎所有东西都是一个对象！你知道吗，你甚至可以将<em>对象建立在其他对象上！这是原型继承背后的主要思想。通过实现它，对象可以接受其他对象</em>的属性。接下来，我们将探索这一切，以及更多知识！</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><hr><ul><li><p><a href="https://github.com/doraeige/document/blob/master/js/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8A%E5%8D%B7%EF%BC%89.pdf" target="_blank" rel="noopener">你不知道的JavaScript（上卷）</a></p></li><li><p><a href="https://github.com/doraeige/document/blob/master/js/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%AD%E5%8D%B7%EF%BC%89.pdf" target="_blank" rel="noopener">你不知道的JavaScript（中卷）</a></p></li><li><p><a href="https://github.com/doraeige/document/blob/master/js/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20JavaScript%EF%BC%88%E4%B8%8B%E5%8D%B7%EF%BC%89.pdf" target="_blank" rel="noopener">你不知道的 JavaScript（下卷）</a></p></li><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">call()</a></p></li><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">apply()</a></p></li><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">bind()</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道 根据函数的调用方式 &lt;code&gt;this&lt;/code&gt; 会设成不同的值，&lt;code&gt;Javascript&lt;/code&gt; 提供了几种设置 &lt;code&gt;this&lt;/code&gt;值的方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;call()&lt;/li&gt;
&lt;li&gt;apply()&lt;/li&gt;
      
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="this" scheme="http://yoursite.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 的 this 用法</title>
    <link href="http://yoursite.com/2019/02/28/Javascript-%E7%9A%84-this-%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/28/Javascript-的-this-用法/</id>
    <published>2019-02-28T09:40:13.000Z</published>
    <updated>2019-03-02T08:53:17.413Z</updated>
    
    <content type="html"><![CDATA[<p><code>this</code> 是 JavaScript 语言的一个关键字。</p><h3 id="构造函数中的-this"><a href="#构造函数中的-this" class="headerlink" title="构造函数中的 this"></a>构造函数中的 this</h3><hr><p>在上一部分，我们使用了方法中的 <code>this</code> 来访问该方法所属的 <strong>对象</strong>。让我们再来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.lives = <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'Meow! My name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bailey = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><p>在上面的 <code>Cat()</code> 构造函数中，<code>sayName</code> 所指向的函数引用了 <code>this.name</code>。之前，我们已经看到过在方法中使用 <code>this</code>，但在这里，<code>this</code> 是指什么呢？</p><p>事实证明，当使用 <code>new</code> 运算符来调用构造函数时，<code>this</code> 会被设置为新创建的对象！让我们来看看新的 <code>bailey</code> 对象是什么样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: Bailey,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Meow! My name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码段中，请注意 this 位于构造函数 <strong>外部</strong>。正如我们在上一篇文章中所看到的，当你说 this 时，你其实是在说“这个对象”或“当前对象”。因此，<code>sayName()</code> 方法可以使用 this 来访问该对象的 <code>name</code> 属性！这使得以下方法调用成为可能：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bailey.sayName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Meow! My name is Bailey</span></span><br></pre></td></tr></table></figure><h2 id="this-什么时候会被赋值？"><a href="#this-什么时候会被赋值？" class="headerlink" title="this 什么时候会被赋值？"></a>this 什么时候会被赋值？</h2><hr><p>一个常见的误解是，this 指向定义它的对象。事实并非如此！直到某个对象调用使用 this 的方法，this 才会被赋值。换句话说，赋给 this 的值取决于 调用定义 this 的方法的对象。让我们来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">  bark: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Woof!'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  barkTwice: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bark();</span><br><span class="line">    <span class="keyword">this</span>.bark();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>让我们继续调用 <code>dog</code> 的两个方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dog.bark();</span><br><span class="line"><span class="comment">// Woof!</span></span><br><span class="line"></span><br><span class="line">dog.barkTwice();</span><br><span class="line"><span class="comment">// Woof!</span></span><br><span class="line"><span class="comment">// Woof!</span></span><br></pre></td></tr></table></figure><p>我们知道，当我们调用 <code>dog.bark()</code> 或 <code>dog.barkTwice()</code> 时，变量 <code>this</code> 将被设置。由于 <code>this</code> 可以访问调用它的对象，因此 <code>barkTwice</code> 可以使用 this 来访问包含 <code>bark</code> 方法的 <code>dog</code> 对象。<br>但是，如果我们在 <code>barkTwice</code> 中使用 <code>bark()</code>，而不是 <code>this.bark()</code>，将会怎样？该函数会先在 <code>barkTwice</code> 的作用域内查找一个名为 <code>bark</code> 的局部变量。如果没有找到 <code>bark</code>，则会沿着作用域链继续查找。<br>综合来看：<code>this.bark()</code> 会告诉 <code>barkTwice</code> 查看 <code>dog</code>（调用该方法的对象）以查找 <code>bark</code>。</p><h2 id="this-会被设置为什么？"><a href="#this-会被设置为什么？" class="headerlink" title="this 会被设置为什么？"></a>this 会被设置为什么？</h2><hr><p>到目前为止，我们已经在许多不同的上下文中看到了 <code>this</code>，比如在方法中，或被构造函数引用。现在，让我们把它们放在一起来看一下！<br>有四种方式可以调用函数，而每种方式都会不同地设置 <code>this</code>。</p><ul><li>首先，使用 new 关键字来调用构造函数会将  <code>this</code> 设置为一个新创建的对象。还记得吗，在我们之前创建 <code>Cat()</code> 的实例时，this 被设置为新的 <code>bailey</code> 对象。</li><li>另一方面，调用属于一个对象的函数（即_方法_）会将 <code>this</code> 设置为该对象本身。回想一下前面的示例，<code>dog</code> 对象的 <code>barkTwice</code> 方法能够访问 <code>dog</code> 本身的属性。</li><li>第三，单独调用一个函数（即简单地调用一个常规函数）将把 <code>this</code> 设置为 <code>window</code>。如果主机环境是浏览器，则它将是全局对象。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funFunction();</span><br><span class="line"><span class="comment">// (返回全局对象, `window`)</span></span><br></pre></td></tr></table></figure><ul><li>第四种调用函数的方式可以让我们自己设置 this！现在不用在意这一点，我们将在下一部分进行深入探讨。</li></ul><table><thead><tr><th style="text-align:center">Call Style</th><th style="text-align:center"><code>new</code></th><th style="text-align:center">method</th><th style="text-align:center">function</th></tr></thead><tbody><tr><td style="text-align:center"><code>this</code></td><td style="text-align:center">{}</td><td style="text-align:center">object itself</td><td style="text-align:center">global object</td></tr><tr><td style="text-align:center">Example</td><td style="text-align:center">new Cat()</td><td style="text-align:center">bailey.sayName()</td><td style="text-align:center">introduce()</td></tr></tbody></table><blockquote><p>如果使用 <code>new</code> 运算符来调用构造函数，<code>this</code> 的值将被设置为新创建的对象，如果在对象上调用方法，<code>this</code> 将被设置为该对象本身，如果简单地调用一个函数，<code>this</code> 将被设置为全局对象: <code>window</code></p></blockquote><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><blockquote><p>请考虑以下构造函数 <code>City</code>：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">City</span>(<span class="params">name, population</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.population = population;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.identify = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>'s population is <span class="subst">$&#123;<span class="keyword">this</span>.population&#125;</span>.`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>const sanFrancisco = new City(&#39;San Francisco&#39;, 870000)</code>; 被执行时，<code>this</code> 的值是什么？</p><p><strong>答案：</strong> 新创建的对象，被 <code>sanFrancisco</code> 引用</p><blockquote><p>请考虑以下对象 <code>building</code>：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> building = &#123;</span><br><span class="line">    floors: <span class="number">5</span>,</span><br><span class="line">    addFloor: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.floors += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">building.addFloor();</span><br></pre></td></tr></table></figure><p>当 <code>building.addFloor()</code> 被执行时，<code>this</code> 的值是什么？</p><p><strong>答案：</strong> <code>building</code></p><blockquote><p>当以下函数被调用时，this 的值是多少？</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"What is the value of 'this'?"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案：</strong> <code>window</code></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>函数、对象和 <code>this</code> 彼此相互关联。当使用 <code>new</code> 运算符来调用构造函数时，<code>this</code> 变量会被设置为新创建的对象。当在对象上调用方法时，<code>this</code> 会被设置为该对象本身。当在浏览器环境中调用函数时，<code>this</code> 会被设置为 <code>window</code>，也被称为全局对象。</p><p>除此之外，还有一组方式可以调用函数：使用 <code>apply()</code> 和使用 <code>call()</code>。这两种方式有许多相似之处，每一种方式都允许我们指定如何设置 <code>this</code>。接下来，我们会对它们进行详细分析！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;this&lt;/code&gt; 是 JavaScript 语言的一个关键字。&lt;/p&gt;
&lt;h3 id=&quot;构造函数中的-this&quot;&gt;&lt;a href=&quot;#构造函数中的-this&quot; class=&quot;headerlink&quot; title=&quot;构造函数中的 this&quot;&gt;&lt;/a&gt;构造函数中
      
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="this" scheme="http://yoursite.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>构造函数</title>
    <link href="http://yoursite.com/2019/02/28/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/02/28/构造函数/</id>
    <published>2019-02-28T03:22:12.000Z</published>
    <updated>2019-03-02T08:44:18.150Z</updated>
    
    <content type="html"><![CDATA[<p>创建对象的一个重要方式是使用构造函数，构造函数以大写字母开头，构造函数必须始终使用特殊关键字 new 来调用，<br>与普通函数的区别是：普通函数必须创建将返回的对象并直接修改该对象，而构造函数会自动创建对象，<br>然后，为了向此对象中添加属性或方法，需要使用特殊的关键字 <code>this</code>。</p><ul><li>要实例化（即 创建 ）一个新的对象，我们可以使用 <code>new</code> 运算符来调用这个函数：<br><code>new SoftwareDeveloper()</code>;</li></ul><h1 id="构造函数：结构和语法"><a href="#构造函数：结构和语法" class="headerlink" title="构造函数：结构和语法"></a>构造函数：结构和语法</h1><hr><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SoftwareDeveloper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.favoriteLanguage = <span class="string">'JavaScript'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，构造函数并不声明局部变量，而是使用 <code>this</code> 关键字来保存数据。以上函数将为所创建的任何对象添加一个 <code>favoriteLanguage</code> 属性，并为其分配一个默认值 ‘JavaScript’。现在不用太在意构造函数中的 <code>this</code>；只要知道 <code>this</code> 是指在构造函数前面使用 <code>new</code> 关键字创建的新对象即可。我们很快就会详细介绍这个 <code>this</code>！<br>最后一点比较特别的是，这个函数似乎不会返回任何东西！<code>JavaScript</code> 中的构造函数不应该有一个显式的返回值（即使用 <code>return</code> 语句）。</p><h2 id="创建一个新的对象"><a href="#创建一个新的对象" class="headerlink" title="创建一个新的对象"></a>创建一个新的对象</h2><hr><p>正如我们在上面看到的，让我们使用 new 运算符来创建一个新的对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> developer = <span class="keyword">new</span> SoftwareDeveloper();</span><br></pre></td></tr></table></figure><p>我们已经把这个调用的返回值保存到了变量 <code>developer</code> 中。让我们执行 <code>console.log(developer)</code>; 将这个 <code>SoftwareDeveloper</code> 对象记录到控制台：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(developer); <span class="comment">// SoftwareDeveloper &#123;favoriteLanguage: "JavaScript"&#125;</span></span><br></pre></td></tr></table></figure><p>用对象字面量的方式来创建对象，看看有何不同</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> orderDeveloper = &#123; <span class="attr">favoriteLanguage</span>: <span class="string">'JavaScript'</span> &#125;;</span><br><span class="line"></span><br><span class="line">otherDeveloper; <span class="comment">// &#123; favoriteLanguage: "JavaScript" &#125;</span></span><br></pre></td></tr></table></figure><p>可以看出 与 <code>developer</code> 相比，创建对象的构造函数 <code>SoftwareDeveloper</code> 没有列在Chrome 开发者工具中；<br>在 Chrome 开发者工具中 构造函数通常显示在 {} 前面；<br><code>developer</code> 的构造函数是 <code>SoftwareDeveloper</code>，而 <code>orderDeveloper</code> 的构造函数是 <code>object</code> 构造函数；比较之下，两者原型将有所不同。</p><h2 id="构造函数可以有参数"><a href="#构造函数可以有参数" class="headerlink" title="构造函数可以有参数"></a>构造函数可以有参数</h2><hr><p>与常规函数一样，使用构造函数的一个好处是它们也可以接受参数。让我们更新以上构造函数来接受一个参数，并为其分配 name 属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SoftwareDeveloper</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.favoriteLanguage = <span class="string">'JavaScript'</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在更新的 <code>SoftwareDeveloper()</code> 函数中，无论传入函数的值是什么，它都将是对象的 <code>name</code> 属性的值。让我们来看看：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instructor = <span class="keyword">new</span> SoftwareDeveloper(<span class="string">'Andrew'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instructor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SoftwareDeveloper &#123; favoriteLanguage: 'JavaScript', name: 'Andrew' &#125;</span></span><br></pre></td></tr></table></figure><p>正如我们在上面看到的，我们可以使用相同的构造函数来创建不同的对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> teacher = <span class="keyword">new</span> SoftwareDeveloper(<span class="string">'Richard'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(teacher);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SoftwareDeveloper &#123; favoriteLanguage: 'JavaScript', name: 'Richard' &#125;</span></span><br></pre></td></tr></table></figure><p>构造函数的好处是，我们可以调用相同的构造函数，创建无数个实例或对象。</p><h2 id="省略-new-运算符"><a href="#省略-new-运算符" class="headerlink" title="省略 new 运算符"></a>省略 new 运算符</h2><hr><p>如果你无意中 <strong>没有</strong> 使用 <code>new</code> 运算符来调用构造函数，会发生什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SoftwareDeveloper</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.favoriteLanguage = <span class="string">'JavaScript'</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coder = SoftwareDeveloper(<span class="string">'David'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(coder);</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这是怎么回事？如果不使用 <code>new</code> 运算符，则不会创建对象。该函数会像任何其他常规函数一样被调用。由于该函数不会 _返回_ 任何东西（除了所有函数都会默认返回的 undefined 之外），因此 <code>coder</code> 变量最终会被分配给 <code>undefined</code>。</p><p>还有一点需要注意：由于这个函数作为一个常规函数被调用，因此 <code>this</code> 的值也会截然不同。现在不用太在意这一点，我们将在下一部分深入探讨 <code>this</code> 关键字！</p><h2 id="查看对象的构造函数-instanceof"><a href="#查看对象的构造函数-instanceof" class="headerlink" title="查看对象的构造函数(instanceof)"></a>查看对象的构造函数(instanceof)</h2><hr><p>如果我们想查看某个对象是否是用构造函数创建的呢？我们可以使用 <code>instanceof</code>（它会返回一个布尔值）来窥见一些端倪。让我们来看看吧！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Developer</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dev = <span class="keyword">new</span> Developer(<span class="string">'Veronkia'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> dev;  <span class="comment">// "object"</span></span><br><span class="line"></span><br><span class="line">dev <span class="keyword">instanceof</span> Developer;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="instanceof-和原型链"><a href="#instanceof-和原型链" class="headerlink" title="instanceof 和原型链"></a>instanceof 和原型链</h3><hr><p>在以上示例中，<code>instanceof</code> 确认一个特定的构造函数确实创建了一个特定的对象。我们知道这一点，是因为我们在调用 <code>Developer()</code> 构造函数之后直接实例化了 <code>dev</code> 对象。</p><p>然而，很多时候并没有这么简单：instanceof 运算符实际上会测试构造函数是否出现在某个对象的原型链中。这意味着，虽然我们不是总能检查到底是 <em>哪个构造函数</em> 创建了该对象，但是它使我们能够洞察某个对象可能访问哪些其他的属性和方法。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>JavaScript 的类系统是直接使用函数和对象来构建的。使用 new 运算符来调用构造函数可以实例化一个新的对象。相同的构造函数可以用于创建不同的对象。</p><p>我们在整篇中广泛讨论了函数、对象和 this。事实证明，这三者是密切相关的！ 我们将在下一部分深入探讨 this 关键字，并仔细分析这三者之间的关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;创建对象的一个重要方式是使用构造函数，构造函数以大写字母开头，构造函数必须始终使用特殊关键字 new 来调用，&lt;br&gt;与普通函数的区别是：普通函数必须创建将返回的对象并直接修改该对象，而构造函数会自动创建对象，&lt;br&gt;然后，为了向此对象中添加属性或方法，需要使用特殊的关键字
      
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="Constructor" scheme="http://yoursite.com/tags/Constructor/"/>
    
      <category term="Object" scheme="http://yoursite.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/02/26/hello-world/"/>
    <id>http://yoursite.com/2019/02/26/hello-world/</id>
    <published>2019-02-26T11:41:00.157Z</published>
    <updated>2019-03-01T08:12:04.569Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="Multiple-hexo-personalization-settings"><a href="#Multiple-hexo-personalization-settings" class="headerlink" title="Multiple hexo personalization settings"></a>Multiple hexo personalization settings</h3><p>More info: <a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">settings</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
