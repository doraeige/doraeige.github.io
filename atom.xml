<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hey,Sophia!</title>
  
  <subtitle>胡诌乱编，沆瀣一气</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-19T04:27:03.090Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xiaoyaliu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git管理 --- 常用Linux命令</title>
    <link href="http://yoursite.com/2019/03/18/git%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/18/git管理/</id>
    <published>2019-03-18T14:12:59.000Z</published>
    <updated>2019-03-19T04:27:03.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看本机git公匙和私匙"><a href="#查看本机git公匙和私匙" class="headerlink" title="查看本机git公匙和私匙"></a>查看本机git公匙和私匙</h2><hr><p>打开终端，先进入 ssh 配置目录</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd ~<span class="regexp">/.ssh/</span></span><br></pre></td></tr></table></figure><p>查看文件目录</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p>查看公匙</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><p>或者查看私匙</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cat id_rsa</span><br></pre></td></tr></table></figure><h2 id="建立公司专有公匙私匙"><a href="#建立公司专有公匙私匙" class="headerlink" title="建立公司专有公匙私匙"></a>建立公司专有公匙私匙</h2><hr><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -P <span class="string">""</span></span><br></pre></td></tr></table></figure><p>按提示输入公司名</p><p><img src="/images/ssh1.png" alt="ssh"></p><p>再打开ssh 配置目录，可以看到配置成功</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd ~<span class="regexp">/.ssh/</span></span><br></pre></td></tr></table></figure><p>查看文件目录</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p>查看配置的公司公匙</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cat xxxx.pub</span><br></pre></td></tr></table></figure><h2 id="GitLab-来管理git"><a href="#GitLab-来管理git" class="headerlink" title="GitLab 来管理git"></a>GitLab 来管理git</h2><hr><p>登录 <strong>GitLab</strong>，点击 <strong>Settings</strong>，左侧边栏 点击 <strong>SSH Keys</strong> 用户SSH密匙设置，把刚才创建的 <strong>公匙</strong> 粘贴到 <strong>KEY</strong> 一栏，<strong>Title</strong> 只是显示作用，默认就好，最后点 <strong>Add Key</strong></p><p>公司的仓库地址 <strong>SSH</strong> ：格式是：协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</p><p>例如： ssh:<a href="mailto://git@git.9xxxxxx.com" target="_blank" rel="noopener">//git@git.9xxxxxx.com</a>:22xxxx/frontend/xxxxxxxxx.git</p><ul><li>ssh 是协议，你可以类比为 http 或 https</li><li><a href="mailto:git@git.xxxxxxx.com" target="_blank" rel="noopener">git@git.xxxxxxx.com</a>  这个是服务器地址</li><li>22xxxx 是端口</li></ul><p>回到终端</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vim ~<span class="regexp">/.ssh/</span>config</span><br></pre></td></tr></table></figure><p>按 <code>i</code> (英文输入法) 编辑：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 公司名</span><br><span class="line">Host 服务器地址</span><br><span class="line">Port 端口</span><br><span class="line">User 用户名</span><br><span class="line">IdentityFile ~<span class="regexp">/.ssh/</span>公司名</span><br></pre></td></tr></table></figure><p>Host 就是服务器地址<br>Port 就是端口<br>User 就是你在Gitlab上的用户名<br>IdentityFile 是认证文件，对应的是你的私钥</p><p>你电脑本地保存的是 <strong>私钥</strong>，服务器上保存的是<strong>公钥</strong>，这两个秘钥不相同，通过 RSA 算法不对称加密，来验证你是不是本人</p><p>编辑好，按 <code>Esc</code> 退出编辑模式，最后输入 <code>:wq</code>，保存并退出。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>vim</code> 是一个终端编辑器，可以看做是 VSCode，按 <code>i</code> 进入编辑模式，按 <code>Esc</code> 退出编辑模式，<code>:w</code> 是保存，<code>:q</code> 是退出， <code>:wq</code> 是保存并退出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;查看本机git公匙和私匙&quot;&gt;&lt;a href=&quot;#查看本机git公匙和私匙&quot; class=&quot;headerlink&quot; title=&quot;查看本机git公匙和私匙&quot;&gt;&lt;/a&gt;查看本机git公匙和私匙&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;打开终端，先进入 ssh 配置目录&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>axios 请求改造封装</title>
    <link href="http://yoursite.com/2019/03/16/axios-%E8%AF%B7%E6%B1%82%E6%94%B9%E9%80%A0%E5%B0%81%E8%A3%85/"/>
    <id>http://yoursite.com/2019/03/16/axios-请求改造封装/</id>
    <published>2019-03-16T08:48:42.000Z</published>
    <updated>2019-03-16T09:20:36.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主要目标功能"><a href="#主要目标功能" class="headerlink" title="主要目标功能"></a>主要目标功能</h2><ul><li>快速请求，快速绑定</li><li>防止重复提交</li></ul><h2 id="模块梳理"><a href="#模块梳理" class="headerlink" title="模块梳理"></a>模块梳理</h2><ul><li>接口模块</li><li>工具模块</li><li>请求模块</li></ul><h2 id="架构设计要点"><a href="#架构设计要点" class="headerlink" title="架构设计要点"></a>架构设计要点</h2><ul><li>利用 es6 的模块化规范，作为一个封装模块</li><li>直接无new 化构建对象</li><li>注入vue原型中，让后面的组件可以直接拿到</li><li>功能添加采用 原型式与静态结合</li></ul><h2 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h2><ul><li>保证可扩展性，可维护性</li><li>常用的方式设为默认加快速度</li><li>灵活控制目标data，请求回来直接自动绑定数据</li></ul><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><hr><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src &gt; assets &gt; unit &gt; qs.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">qa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _iqaob = <span class="keyword">new</span> _iqa();</span><br><span class="line">        <span class="keyword">var</span> _urlarr = arr || [];</span><br><span class="line">        <span class="comment">// 只在新建对象里执行一次循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>,len = _urlarr.length; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> _name = qa.getPathName(_urlarr[i]);</span><br><span class="line">            (<span class="function"><span class="keyword">function</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">                _iqaob[_name] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    _iqaob.sendMes.call(_iqaob,url,ob);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)(_urlarr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无 new 化构造对象</span></span><br><span class="line">        <span class="comment">// 返回一个对象</span></span><br><span class="line">        <span class="keyword">return</span> _iqaob;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_iqa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 内部代码</span></span><br><span class="line">        <span class="keyword">this</span>._vueob = &#123;&#125;;</span><br><span class="line">        <span class="keyword">this</span>.statue = <span class="number">0</span>; <span class="comment">// 状态码思想</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求模块 原型链注入</span></span><br><span class="line">    _iqa.prototype.sendMes = <span class="function"><span class="keyword">function</span> (<span class="params">url, ob</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> _url = url || <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">var</span> _ob = ob || &#123;&#125;;</span><br><span class="line">        <span class="keyword">var</span> _type = _ob.type || <span class="string">'get'</span>; <span class="comment">// 百分之七八十的请求都是 get 请求</span></span><br><span class="line">        <span class="keyword">var</span> _data = _ob.data || &#123;&#125;; <span class="comment">// 请求参数</span></span><br><span class="line">        <span class="keyword">var</span> _suecc = ob.suecc || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">        <span class="keyword">var</span> _isblock = _ob.block || <span class="literal">true</span>; <span class="comment">// 默认需要阻塞</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 状态 模式</span></span><br><span class="line">        <span class="keyword">var</span> status = &#123;</span><br><span class="line">            <span class="keyword">get</span>: function()&#123;</span><br><span class="line">                <span class="keyword">var</span> _quary = qa.qs(_data);</span><br><span class="line">                axios.get(_url+_quary).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">                    self.statue = <span class="number">0</span>; <span class="comment">// 防止重复提交</span></span><br><span class="line">                    <span class="keyword">var</span> _result = _suecc.call(self._vueob, res);</span><br><span class="line">                    <span class="keyword">var</span> _name = qa.getPathName(_urlarr[i]);</span><br><span class="line">                    <span class="comment">// 用户是想数据处理之后加到 data 上面</span></span><br><span class="line">                    <span class="keyword">if</span> (_result) &#123;</span><br><span class="line">                        self._vueob[_name] = _result;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 没有_result返回值，只是拿 data 做其他事情</span></span><br><span class="line">                        self._vueob[_name] = res.data;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">            post: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">            put: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">            <span class="keyword">delete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(self.statue == <span class="number">0</span> || _isblock)&#123;</span><br><span class="line">            <span class="keyword">if</span> (_isblock)&#123;</span><br><span class="line">                self.statue = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            status[_type]();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _iqa.prototype.v = <span class="function"><span class="keyword">function</span>(<span class="params">vueob</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._vueob = vueob;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态</span></span><br><span class="line">    <span class="comment">// 拿到 文件名 './static/json1.json' 里的 json1</span></span><br><span class="line">    qa.getPathName = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _arr = url.split(<span class="string">'/'</span>); <span class="comment">// ['.','static','json1.json']</span></span><br><span class="line">        <span class="keyword">var</span> _name = _arr[_arr.length - <span class="number">1</span>]; <span class="comment">// ['json1.json']</span></span><br><span class="line">        <span class="keyword">var</span> _newname = _name.split(<span class="string">'.'</span>)[<span class="number">0</span>]; <span class="comment">// ['json1']</span></span><br><span class="line">        <span class="keyword">return</span> _newname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 请求参数 qs 然后拼接到 url </span></span><br><span class="line">    qa.qs = <span class="function"><span class="keyword">function</span>(<span class="params">ob</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">JSON</span>.stringify(ob) == <span class="string">'&#123;&#125;'</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            _str += <span class="string">"?"</span>;</span><br><span class="line">            <span class="keyword">var</span> _len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> ob) &#123;</span><br><span class="line">                <span class="keyword">if</span>(_len != <span class="number">0</span>)&#123;</span><br><span class="line">                    _str += <span class="string">"&amp;"</span></span><br><span class="line">                &#125;</span><br><span class="line">                _str += item;</span><br><span class="line">                _str += <span class="string">"="</span>;</span><br><span class="line">                _str += ob[item];</span><br><span class="line">                _len ++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qa;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>static 下新建 json1.json、json2.json文件 模拟一个接口数据<br>往 Vue 原型链中注入 qa 便于每个子组件都能拿到qa方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> qa <span class="keyword">from</span> <span class="string">'./assets/unit/qa'</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.qa = qa([<span class="string">'./static/json1.json'</span>, <span class="string">'./static/json2.json'</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HelloWorld.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;json1&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">'Helloworld'</span>,</span><br><span class="line">        data()&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                json1: <span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.qa.v(<span class="keyword">this</span>).json1(&#123;<span class="attr">data</span>: &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;, <span class="attr">suecc</span>:<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res);</span><br><span class="line">            &#125;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>设计思路： 功能确定 &gt; 模块梳理 &gt; 架构基础 &gt; 功能构建</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;主要目标功能&quot;&gt;&lt;a href=&quot;#主要目标功能&quot; class=&quot;headerlink&quot; title=&quot;主要目标功能&quot;&gt;&lt;/a&gt;主要目标功能&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;快速请求，快速绑定&lt;/li&gt;
&lt;li&gt;防止重复提交&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;模块梳
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="axios" scheme="http://yoursite.com/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>记一次面试</title>
    <link href="http://yoursite.com/2019/03/14/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/03/14/记一次面试/</id>
    <published>2019-03-14T06:44:42.000Z</published>
    <updated>2019-03-19T09:30:49.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>2019.3.13 某网络科技有限公司</p><table><thead><tr><th style="text-align:center">来源</th><th style="text-align:center">前端团队</th><th style="text-align:center">周工作时长</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">BOSS直聘</td><td style="text-align:center">2</td><td style="text-align:center">10:00am-6:50pm 周末双休</td><td style="text-align:center">过</td></tr></tbody></table><p><strong>未来上司面:</strong><br><strong>聊聊上司的那点事：</strong> </p><ul><li>小哥哥、温柔体贴、面试过程中端茶倒水、勤勤恳恳</li><li>问题由浅入深，耐心的给面试者解答，nice 盘他！</li></ul><p><img src="/images/interview.png" alt="面试题目大纲"></p><h3 id="面试中的主要瓶颈"><a href="#面试中的主要瓶颈" class="headerlink" title="面试中的主要瓶颈"></a>面试中的主要瓶颈</h3><ul><li>其中某些题，没有办法较为顺畅的表达出来，说明可能掌握的还不够，或者理解的不太顺畅，需要回去总结下，捋捋思路</li><li>对底层原理的实现了解的不多</li></ul><h3 id="反问面试官的问题"><a href="#反问面试官的问题" class="headerlink" title="反问面试官的问题"></a>反问面试官的问题</h3><p><a href="https://doraeige.github.io/2019/03/02/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E4%BD%A0%E2%80%9C%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E9%97%AE%E6%88%91%E5%90%97%EF%BC%9F%E2%80%9D%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%EF%BC%9F/" target="_blank" rel="noopener">问面试官的问题</a></p><h3 id="延展"><a href="#延展" class="headerlink" title="延展"></a>延展</h3><ul><li><p><a href="http://blog.poetries.top/FE-Interview-Questions" target="_blank" rel="noopener">前端面试题整理</a></p></li><li><p><a href="https://yuchengkai.cn/docs/" target="_blank" rel="noopener">InterviewMap面试图谱</a></p></li><li><p><a href="https://segmentfault.com/a/1190000017489663" target="_blank" rel="noopener">浅拷贝与深拷贝</a></p></li><li><p><a href="https://juejin.im/post/5b037b536fb9a07aa9260b39" target="_blank" rel="noopener">ES6核心特性</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;面试&quot;&gt;&lt;a href=&quot;#面试&quot; class=&quot;headerlink&quot; title=&quot;面试&quot;&gt;&lt;/a&gt;面试&lt;/h2&gt;&lt;p&gt;2019.3.13 某网络科技有限公司&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:cen
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试官问你&quot;有什么问题问我吗?&quot;，该如何回答？</title>
    <link href="http://yoursite.com/2019/03/02/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E4%BD%A0%E2%80%9C%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E9%97%AE%E6%88%91%E5%90%97%EF%BC%9F%E2%80%9D%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/03/02/面试官问你“有什么问题问我吗？”，该如何回答？/</id>
    <published>2019-03-01T17:13:32.000Z</published>
    <updated>2019-03-01T17:31:29.828Z</updated>
    
    <content type="html"><![CDATA[<p>面试官总会在面试结束时问我:”问了你这么多问题了，你有什么问题问我吗?”。</p><h2 id="有哪些有价值的问题值得问"><a href="#有哪些有价值的问题值得问" class="headerlink" title="有哪些有价值的问题值得问?"></a>有哪些有价值的问题值得问?</h2><h3 id="面对HR或者其他Level比较低的面试官时"><a href="#面对HR或者其他Level比较低的面试官时" class="headerlink" title="面对HR或者其他Level比较低的面试官时"></a>面对HR或者其他Level比较低的面试官时</h3><hr><ul><li><p><strong>能不能谈谈你作为一个公司老员工对公司的感受?</strong><br>(这个问题比较容易回答，不会让面试官陷入无话可说的尴尬境地。另外，从面试官的回答中你可以加深对这个公司的了解，让你更加清楚这个公司到底是不是你想的那样或者说你是否能适应这个公司的文化。除此之外，这样的问题在某种程度上还可以拉进你与面试官的距离)</p></li><li><p><strong>能不能问一下，你当时因为什么原因选择加入这家公司的呢或者说这家公司有哪些地方吸引你?有什么地方你觉得还不太好或者可以继续完善吗？</strong><br>（类似第一个问题，都是问面试官个人对于公司的看法）</p></li><li><p><strong>我觉得我这次表现的不是太好，你有什么建议或者评价给我吗？</strong><br>(这个是我常问的。我觉得说自己表现不好只是这个语境需要这样来说，这样可以显的你比较谦虚好学上进)</p></li><li><p><strong>如果我有幸被贵公司录取，有什么需要在入职前注意或学习的吗？</strong><br>（体现出你对工作比较上心，自助学习意识比较强）</p></li><li><p><strong>这个岗位为什么还在招人？</strong><br>（岗位真实性和价值咨询）</p></li><li><p><strong>大概什么时候能给我回复呢？</strong><br>（终面的时候，如果面试官没有说的话，可以问一下）</p></li></ul><h3 id="面对部门领导"><a href="#面对部门领导" class="headerlink" title="面对部门领导"></a>面对部门领导</h3><hr><ul><li><p><strong>部门的主要人员分配以及对应的主要工作能简单介绍一下吗？</strong></p></li><li><p><strong>未来如果我要加入这个团队，你对我的期望是什么？</strong><br>（部门领导一般情况下是你的直属上级了，你以后和他打交道的机会应该是最多的。你问这个问题，会让他感觉你是一个对他的部门比较上心，比较有团体意识，并且愿意倾听的候选人。）</p></li><li><p><strong>公司对新入职的员工的培养机制是什么样的呢？</strong><br>（正规的公司一般都有培养机制，提前问一下是对你自己的负责也会显的你比较上心）</p></li><li><p><strong>以您来看，这个岗位未来在公司内部的发展如何？</strong><br>（在我看来，问这个问题也是对你自己的负责吧，谁不想发展前景更好的岗位呢？）</p></li><li><p><strong>团队现在面临的最大挑战是什么？</strong><br>（这样的问题不会暴露你对公司的不了解，并且也能让你对未来工作的挑战或困难有一个提前的预期）</p></li></ul><h3 id="面对Level比较高的-比如总裁-老板"><a href="#面对Level比较高的-比如总裁-老板" class="headerlink" title="面对Level比较高的(比如总裁,老板)"></a>面对Level比较高的(比如总裁,老板)</h3><hr><ul><li><p><strong>贵公司的发展目标和方向是什么？</strong><br>（看下公司的发展是否满足自己的期望）</p></li><li><p><strong>与同行业的竞争者相比，贵公司的核心竞争优势在什么地方？</strong><br>（充分了解自己的优势和劣势）</p></li><li><p><strong>公司现在面临的最大挑战是什么？</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面试官总会在面试结束时问我:”问了你这么多问题了，你有什么问题问我吗?”。&lt;/p&gt;
&lt;h2 id=&quot;有哪些有价值的问题值得问&quot;&gt;&lt;a href=&quot;#有哪些有价值的问题值得问&quot; class=&quot;headerlink&quot; title=&quot;有哪些有价值的问题值得问?&quot;&gt;&lt;/a&gt;有哪些有
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试问题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试-前端编程思路</title>
    <link href="http://yoursite.com/2019/03/02/%E9%9D%A2%E8%AF%95-%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A8%8B%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2019/03/02/面试-前端编程思路/</id>
    <published>2019-03-01T16:42:32.000Z</published>
    <updated>2019-03-02T08:52:59.382Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>编写一个js函数，该函数有一个n（数字类型），其返回值是一个数组，该数组内是n个随机且不重复的整数，且整数取值范围是[2,32] </p></blockquote><hr><h4 id="题目解读"><a href="#题目解读" class="headerlink" title="题目解读"></a>题目解读</h4><hr><p>输入一个数字类型的参数n，会返回一个包含2到32的数字的数组，数组长度是n(比如你输入数字是2，就会返回数组长度为2的数组); 数组里面的数字用 随机函数 生成，然后还要检查数字是否会重复，也要考虑负数情况等边界条件</p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><hr><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil();   <span class="comment">//向上取整。</span></span><br><span class="line"><span class="built_in">Math</span>.floor();  <span class="comment">//向下取整。</span></span><br><span class="line"><span class="built_in">Math</span>.round();  <span class="comment">//四舍五入。</span></span><br><span class="line"><span class="built_in">Math</span>.random(); <span class="comment">//0.0 ~ 1.0 之间的一个伪随机数。【包含0不包含1) 比如0.8647578968666494</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">10</span>); <span class="comment">// 获取从1到10的随机整数 ，取0的概率极小。</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random());   <span class="comment">//可均衡获取0到1的随机整数。</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">10</span>);  <span class="comment">//可均衡获取0到9的随机整数。</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random()*<span class="number">10</span>);  <span class="comment">//基本均衡获取0到10的随机整数，其中获取最小值0和最大值10的几率少一半。</span></span><br></pre></td></tr></table></figure><blockquote><p>直接使用 parseInt，parseFloat 或 Number 将一个非数字的值转化为数字时，表达式返回 NaN </p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'abc'</span> - <span class="number">3</span>   <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'abc'</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'abc'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'abc'</span>)    <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><blockquote><p>isNaN() 是一个全局方法，它的作用是检查一个值是否能被 Number() 成功转换 。 如果能转换成功，就返回 false，否则返回 true </p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>)    <span class="comment">// true 不能转换</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'123'</span>)   <span class="comment">// false 能转换</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'abc'</span>)    <span class="comment">// true 不能转换</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'123ab'</span>)   <span class="comment">// true 不能转换</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'123.45abc'</span>) <span class="comment">// true 不能转换</span></span><br></pre></td></tr></table></figure><h4 id="生成随机数方法总结"><a href="#生成随机数方法总结" class="headerlink" title="生成随机数方法总结"></a>生成随机数方法总结</h4><hr><blockquote><p>生成[1,max]的随机数，公式如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// max - 期望的最大值</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*max,<span class="number">10</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*max)+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*max);</span><br></pre></td></tr></table></figure><blockquote><p>生成[0,max]到任意数的随机数，公式如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// max - 期望的最大值</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*(max+<span class="number">1</span>),<span class="number">10</span>);</span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(max+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><blockquote><p>生成[min,max]的随机数，公式如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// max - 期望的最大值</span></span><br><span class="line"><span class="comment">// min - 期望的最小值</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*(max-min+<span class="number">1</span>)+min,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(max-min+<span class="number">1</span>)+min);</span><br></pre></td></tr></table></figure><h4 id="编程思维："><a href="#编程思维：" class="headerlink" title="编程思维："></a>编程思维：</h4><hr><p>可用 —&gt; 健壮 —&gt; 可靠 —&gt; 宽容</p><p>健壮：</p><ul><li>最基本的兼容性处理、边界处理、异常处理、用户输入校验</li><li>对n的取值范围进行校验；对n是否为数字进行校验；对n是否存在进行校验</li></ul><p>宽容：</p><ul><li>n是一个字符串数字，是否允许进入处理流程？是的话，经验系数*1.1</li><li>n是一个含有小数的数字，是否允许进入处理流程？是的话，经验系数*1.1</li><li>代码是否有足够多且清晰的注释？是的话，经验系数*1.2</li><li>调整[2，32]的范围，你的代码是否可以快速调整甚至不用调整？是的话，经验系数*1.2</li></ul><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成一个随机数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRand</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>) + min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去重校验</span></span><br><span class="line"><span class="comment">// function checkArrIn(rand,array)&#123;</span></span><br><span class="line"><span class="comment">//     if(array.indexof(rand) &gt; -1)&#123;</span></span><br><span class="line"><span class="comment">//         return true;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return false;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断n是不是一个数字，包含字符串类型的数字</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNotNum</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isNaN</span>(<span class="built_in">Number</span>(n)) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断n是不是在范围内</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRandOk</span>(<span class="params">n, min, max</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt;= min &amp;&amp; n &lt;= max ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断n是不是含有小数的数字</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isXiaoShu</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(n).indexOf(<span class="string">"."</span>) &gt; <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去重检验 arr.includes(e) includes 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 准备一个容器保存结果</span></span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="comment">// 将整数取值范围用变量保存起来</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (isNotNum(n)) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">if</span> (!isRandOk(n,min,max)) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">if</span> (isXiaoShu(n)) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> rand = getRand(min, max);</span><br><span class="line">        <span class="keyword">if</span> (arr.includes(rand)) &#123; </span><br><span class="line">            i--; <span class="comment">// 减一是因为如果第i次循环的时候如果数组有了该值，就重新走一遍</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr.push(rand);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">2</span>); <span class="comment">// (2) [15, 11] 随机</span></span><br><span class="line">fn(<span class="string">'5'</span>); <span class="comment">// (5) [13, 2, 11, 27, 12] 随机</span></span><br><span class="line">fn(<span class="string">'3.33'</span>); <span class="comment">// []</span></span><br><span class="line">fn(<span class="number">5.5</span>); <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h4 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h4><p><a href="https://mp.weixin.qq.com/s/tj8PQXk3CpACYUknE0TpyA" target="_blank" rel="noopener">程序员！为什么你的前端工作经验不值钱？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;编写一个js函数，该函数有一个n（数字类型），其返回值是一个数组，该数组内是n个随机且不重复的整数，且整数取值范围是[2,32] &lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h4 id=&quot;题目解读&quot;&gt;&lt;a href=&quot;#题目解读&quot; class
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="编程逻辑" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>远程调试</title>
    <link href="http://yoursite.com/2018/10/02/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    <id>http://yoursite.com/2018/10/02/远程调试/</id>
    <published>2018-10-02T07:21:39.000Z</published>
    <updated>2019-03-05T10:18:14.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在真实设备上测试非常重要，所以你需要确保随时能进行测试</p></blockquote><h2 id="如何在-Chrome-中对-Android-进行远程调试"><a href="#如何在-Chrome-中对-Android-进行远程调试" class="headerlink" title="如何在 Chrome 中对 Android 进行远程调试"></a>如何在 Chrome 中对 Android 进行远程调试</h2><ul><li><p><a href="https://www.google.com/chrome/browser/canary.html" target="_blank" rel="noopener">下载Chrome Canary版</a>（它不会影响现有的Chrome安装）</p></li><li><p><a href="https://developers.google.cn/web/tools/chrome-devtools/remote-debugging/?hl=zh" target="_blank" rel="noopener">在装有 Chrome 的 Android 上远程调试</a></p></li></ul><blockquote><p>什么是 Chrome Canary版 ，我为什么要使用它呢？</p></blockquote><p>Chrome Canary版 是Chrome浏览器的开发版本。它的外观和行为与常规的Chrome浏览器类似，但它包含那些尚未公布的新的试验性功能。我们建议你使用最新的 Canary 来分析网站。然而，需要注意的一点是，Canary 不能保证稳定，因此可能会有崩溃和偶尔出错的情况。</p><h2 id="用-iOS-网页调试代理-配合移动端的-Safari"><a href="#用-iOS-网页调试代理-配合移动端的-Safari" class="headerlink" title="用 iOS 网页调试代理 配合移动端的 Safari"></a>用 iOS 网页调试代理 配合移动端的 Safari</h2><ul><li><p><a href="https://github.com/google/ios-webkit-debug-proxy" target="_blank" rel="noopener">iOS WebKit 调试代理(英)</a></p></li><li><p><a href="https://www.smashingmagazine.com/2014/09/testing-mobile-emulators-simulators-remote-debugging/" target="_blank" rel="noopener">Testing Mobile: Emulators, Simulators And Remote Debugging(英)</a></p></li><li><p><a href="https://sebastianblade.com/debug-ios-safari-with-chrome-devtools/" target="_blank" rel="noopener">如何用 Chrome DevTools 调试 iOS Safari</a></p></li></ul><blockquote><p>想要使用云中的不同浏览器测试,尝试 <a href="https://www.browserstack.com/" target="_blank" rel="noopener">BrowserStack</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在真实设备上测试非常重要，所以你需要确保随时能进行测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;如何在-Chrome-中对-Android-进行远程调试&quot;&gt;&lt;a href=&quot;#如何在-Chrome-中对-Android-进行远程调试&quot; 
      
    
    </summary>
    
      <category term="调试" scheme="http://yoursite.com/categories/%E8%B0%83%E8%AF%95/"/>
    
    
      <category term="移动设备" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87/"/>
    
      <category term="调试" scheme="http://yoursite.com/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>原型继承:子类</title>
    <link href="http://yoursite.com/2018/07/14/%E5%AD%90%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/07/14/子类/</id>
    <published>2018-07-14T10:05:25.000Z</published>
    <updated>2019-03-05T10:11:22.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><hr><p>实现继承的好处之一就是它允许你重用现有代码。通过建立继承，我们可以子类化，也就是让一个“子”对象接受“父”对象的大部分或全部属性和方法，同时保留它自己独特的方法。</p><p>假设我们有一个父 <code>Animal</code> 对象（即构造函数），其中包含诸如 <code>age</code> 和 <code>weight</code> 等属性。同一个 <code>Animal</code> 对象还可以访问 <code>eat</code> 和 <code>sleep</code> 等方法。</p><p>现在，再假设我们要创建一个 <code>Cat</code> 子对象。与描述其他动物一样，你也可以通过 <code>age</code> 或 <code>weight</code> 来描述一只猫，而且你也可以确定猫会 <code>eat</code> 和 <code>sleep</code>。因此，在创建这个 <code>Cat</code> 对象的时候，我们可以简单地重写和重新实现 <code>Animal</code> 中的所有方法和属性——或者，我们也可以让 <code>Cat</code> 从 <code>Animal</code> <strong>继承</strong> 这些现有的属性和方法，从而节省时间并防止重复代码！</p><p>我们不仅可以让 <code>Cat</code> 接受 <code>Animal</code> 的属性和方法，还可以赋予 <code>Cat</code> 独特的属性和方法！也许一只 <code>Cat</code> 具有独特的 <code>lives</code> 属性为 9，或有一个专门的 <code>meow()</code> 方法，是其他 <code>Animal</code> 所没有的。使用原型继承，<code>Cat</code> 只需要实现 <code>Cat</code> 的独特功能，并重用 <code>Animal</code> 的现有功能即可。</p><h2 id="通过原型继承"><a href="#通过原型继承" class="headerlink" title="通过原型继承"></a>通过原型继承</h2><hr><p>回想一下上一部分的原型链：</p><p><img src="/images/prototype.png" alt="原型链"></p><p>当在任何对象上调用任何属性时，JavaScript 引擎将首先在该对象中查找该属性（即该对象自己的、非继承的属性）。如果没有找到该属性，JavaScript 将查看该对象的原型。如果在对象原型中 <strong>仍然</strong> 找不到该属性，则 JavaScript 将在原型链上继续搜索。</p><p><strong>JavaScript 中的继承重点就是建立原型链。</strong></p><h2 id="秘密链接"><a href="#秘密链接" class="headerlink" title="秘密链接"></a>秘密链接</h2><hr><p>如你所知，在尝试搜索一个不存在于某个对象中的属性时，该对象的构造函数的原型是被首先搜索的。请考虑以下具有两个属性 <code>claws</code> 和 <code>diet</code> 的 <code>bear</code> 对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bear = &#123;</span><br><span class="line">    claws: <span class="literal">true</span>,</span><br><span class="line">    diet: <span class="string">'carnivore'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>让我们将以下 <code>PolarBear()</code> 构造函数的 <code>prototype</code> 属性赋为 <code>bear</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PolarBear</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PolarBear.prototype = bear;</span><br></pre></td></tr></table></figure><p>现在，让我们调用 PolarBear() 构造函数来创建一个新的对象，然后给它两个属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> snowball = <span class="keyword">new</span> PolarBear();</span><br><span class="line"></span><br><span class="line">snowball.color = <span class="string">'white'</span>;</span><br><span class="line"></span><br><span class="line">snowball.favoriteDrink = <span class="string">'cola'</span>;</span><br></pre></td></tr></table></figure><p><code>snowball</code> 对象目前看起来像这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    color: <span class="string">'white'</span>,</span><br><span class="line">    favoriteDrink: <span class="string">'cola'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>snowball</code> 只有两个自己的属性：<code>color</code> 和 <code>favoriteDrink</code>。但是，<code>snowball</code> 也可以访问自身并不具有的属性：<code>claws</code> 和 <code>diet</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(snowball.claws);</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(snowball.diet);</span><br><span class="line"><span class="comment">//'carnivore'</span></span><br></pre></td></tr></table></figure><p>由于 claw 和 diet 都作为 <code>prototype</code> 对象中的属性存在，因此它们会被查找，因为对象被秘密链接到其构造函数的 <code>prototype</code> 属性。</p><p>太棒了！但你可能会想：这个通向 <code>prototype</code> 对象的秘密链接到底是什么呢？当从 <code>PolarBear()</code> 构造函数构造对象之后（如 <code>snowball</code>），这些对象可以立即访问 <code>PolarBear()</code> 的原型中的属性。这究竟是怎么做到的呢？</p><p>事实证明，这个秘密链接是 <code>snowball</code> 的 <code>__proto__</code> 属性（注意每一端有两个下划线）。</p><p><code>__proto__</code> 是构造函数所创建的所有对象（即实例）的一个属性，并直接指向该构造函数的 <code>prototype</code> 对象。让我们来看看它是什么样的！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(snowball.__proto__);</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123; claws: true, diet: 'carnivore' &#125;</span></span><br></pre></td></tr></table></figure><p>由于 <code>__proto__</code> 属性所指向的对象与 <code>PolarBear</code> 的原型 <code>bear</code> 相同，因此将它们进行比较会返回 <code>true</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(snowball.__proto__ === bear);</span><br><span class="line"></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>强烈建议不要重新分配 <strong>proto</strong> 属性，甚至不要在你编写的任何代码中使用它。</strong></p></blockquote><hr><p>首先，会有跨浏览器的兼容性问题。<br>更重要的是：由于 JavaScript 引擎会在原型链上搜索和访问属性，因此更改对象的原型可能会导致性能问题。<br>有关 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank" rel="noopener">proto</a> 的 MDN 文章甚至警告，不要在页面顶部的红色文本中使用此属性！</p><p>我们有必要知道这个秘密链接，以了解函数和对象是如何相互关联的，但你不应该使用 <code>__proto__</code> 来管理继承。如果你只是需要查看对象的原型，则仍然可以使用 <code>Object.getPrototypeOf()</code> 来达到目的。</p><hr><blockquote><p><strong>如果只继承原型呢？</strong></p></blockquote><hr><blockquote><p>假设我们希望一个 <code>Child</code> 对象从一个 <code>Parent</code> 对象继承。为什么不应该只设置 <code>Child.prototype = Parent.prototype</code> 呢？</p></blockquote><blockquote><p>首先，还记得吗，对象是通过<em>引用来传递的。这意味着，由于 <code>Child.prototype</code> 对象和 <code>Parent.prototype</code> 对象引用的是同一个对象</em>，因此你对 <code>Child</code> 的原型所作的任何更改也会被应用于 <code>Parent</code> 的原型！我们可不希望子对象能够修改其父对象的属性！</p></blockquote><blockquote><p>最重要的是，这样做不会创建原型链。如果我们想让一个对象从我们想要的任何对象进行继承，而不仅仅是它的原型呢？</p></blockquote><blockquote><p>我们仍然需要一种方式来有效地管理继承，同时又完全不会改变原型。</p></blockquote><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><hr><blockquote><p>请考虑以下代码:</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuineaPig</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.isCute = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> waffle = <span class="keyword">new</span> GuineaPig(<span class="string">'Waffle'</span>);</span><br></pre></td></tr></table></figure><p><code>waffle.__proto__</code>指向什么？</p><p><strong>参考答案：</strong> <code>GuineaPig.prototype</code></p><blockquote><p>请考虑以下代码:</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params">color, year</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">    <span class="keyword">this</span>.year = year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype.drive = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Vroom vroom!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = <span class="keyword">new</span> Car(<span class="string">'silver'</span>, <span class="number">1988</span>);</span><br></pre></td></tr></table></figure><p>当 <code>car.drive()</code> 被调用时，会发生什么？</p><p><strong>参考答案：</strong></p><table><thead><tr><th style="text-align:center">顺序</th><th style="text-align:center">事件</th></tr></thead><tbody><tr><td style="text-align:center">第一</td><td style="text-align:center">JavaScript引擎在<code>car</code>对象内搜索名为<code>drive</code>的属性</td></tr><tr><td style="text-align:center">第二</td><td style="text-align:center">JavaScript引擎在<code>car</code>对象中找不到<code>drive</code>属性</td></tr><tr><td style="text-align:center">第三</td><td style="text-align:center">然后，JavaScript引擎会访问<code>car.__proto__</code>属性</td></tr><tr><td style="text-align:center">第四</td><td style="text-align:center">由于<code>car.__proto__</code>指向<code>Car.prototype</code>,因此JavaScript引擎会在该原型中搜索<code>drive</code></td></tr><tr><td style="text-align:center">第五</td><td style="text-align:center">由于<code>Car.prototype.drive</code>是一个已定义的属性，因此它会被返回</td></tr><tr><td style="text-align:center">第六</td><td style="text-align:center">最后，由于<code>drive</code>作为一个方法在<code>car</code>上被调用，因此<code>this</code>的值会被设置为<code>car</code></td></tr></tbody></table><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><hr><p>到目前为止，我们在继承方面遇到了一些问题。首先，虽然 <code>__proto__</code> 可以访问被调用的对象的原型，但是在你编写的代码中使用它并不是好习惯。</p><p>另一方面，我们也不应该_只_继承原型；这样做不会创建原型链，而且我们对子对象所作的任何更改也会反映在父对象中。</p><p>那么，我们应该如何继续往前呢？</p><p>实际上，我们可以借助一种方式来自己设置对象的原型：使用 <code>Object.create()</code>。而且最棒的是，这种方式既可以让我们管理继承，同时又 <strong>不会</strong> 改变原型！</p><p><code>Object.create()</code> 会接受一个对象作为参数，并返回一个新的对象，其 <code>__proto__</code> 属性会被设置为传递给它的参数。然后，你只需要将所返回的对象设置为子对象构造函数的原型即可。让我们来看一个例子！</p><p>首先，假设我们有一个 <code>mammal</code> 对象，它有两个属性：<code>vertebrate</code> 和 <code>earBones</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mammal = &#123;</span><br><span class="line">    vertebrate: <span class="literal">true</span>,</span><br><span class="line">    earBones: <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还记得吗，<code>Object.create()</code> 会接受一个对象作为参数，并返回一个 <strong>新的</strong> 对象。这个新对象的 <code>__proto__</code> 属性会被设置为最初传递给 <code>Object.create()</code> 的参数。让我们把这个返回值保存到变量 <code>rabbit</code> 中：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rabbit = <span class="built_in">Object</span>.create(mammal);</span><br></pre></td></tr></table></figure><p>我们预期这个新的 <code>rabbit</code> 对象是空白的，没有自己的属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(rabbit);</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>但是，<code>rabbit</code> 现在应该已被秘密链接到 <code>mammal</code>。也就是说，它的 <code>__proto__</code> 属性应该指向 <code>mammal</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(rabbit.__proto__ === mammal);</span><br><span class="line"></span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>太棒了！这意味着，现在 <code>rabbit</code> 扩展了 <code>mammal</code>（即 <code>rabbit</code> 继承自 <code>mammal</code>），而且 <code>rabbit</code> 可以将 <code>mammal</code> 的属性当作自己的属性一样进行访问！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(rabbit.vertebrate);</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(rabbit.earBones);</span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure><p><code>Object.create()</code> 给了我们一个在 JavaScript 中建立原型继承的简洁方法。我们可以通过这种方式轻松扩展原型链，而且可以让对象从我们想要的任何对象进行继承！</p><p>下面让我们来看一个更复杂的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.walk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> walks!`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.lives = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个 Animal 构造函数，以及一个在 Animal 的原型上直接定义的 walk 方法，此外，还有一个 Cat 构造函数，你可能注意到，我们在 Cat 构造函数中使用了 call 方法，并且直接在 Animal 构造函数 中调用它。</p><p>我们使用 call 而不是关键字 new ，因为我们不想构造一个全新的 animal 对象。我们只关心 cat 实例或 cat 对象上的 animal 初始化逻辑，call 方法的作用是调用 Animal 并将 this 设为 cat 实例，否则 <code>this.name</code> 将是 <code>undefined</code>。</p><p>现在，有了这个继承自 Animal 的 Cat:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Cat.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line"><span class="comment">// Animal&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>我们还需要更改构造函数, 否则所有的 cat 对象的构造函数将设为 animal：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f Cat(name)&#123;</span></span><br><span class="line"><span class="comment">//     Animal.call(this, name);</span></span><br><span class="line"><span class="comment">//     this.lives = 9; </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>现在，我们向 cat 的原型添加一个 使所有 cat 对象都能共享的方法: Meow</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Cat.prototype.meow = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Meow!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f () &#123;</span></span><br><span class="line"><span class="comment">//    console.log('Meow!');</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>使用关键字 new 调用 cat 构造函数，并初始化新的 cat 对象 称之为 Bambi：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bambi = <span class="keyword">new</span> Cat(<span class="string">'Bambi'</span>);</span><br><span class="line"></span><br><span class="line">bambi.meow(); <span class="comment">// Meow!</span></span><br><span class="line">bambi.walk(); <span class="comment">// Bambi walks!</span></span><br><span class="line"></span><br><span class="line">bambi.name; <span class="comment">// "Bambi"</span></span><br></pre></td></tr></table></figure><blockquote><p>总结下，为了在JavaScript 中有效地管理继承,一个很好的方式是避免完全更改原型   ，为此，我们可以使用 <code>object.create</code></p></blockquote><h3 id="小练习-1"><a href="#小练习-1" class="headerlink" title="小练习"></a>小练习</h3><hr><blockquote><p>请考虑以下代码：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child();</span><br></pre></td></tr></table></figure><p>当 <code>child instanceof Parent;</code> 被执行时，什么会被输出到控制台？</p><p><strong>参考答案：</strong> <code>true</code></p><blockquote><p>以下哪一项有关 <code>Object.create()</code> 的说法是正确的？请选择所有适用项：</p></blockquote><ul><li>它会返回一个新的对象，其 <code>__proto__</code> 属性会被设置为传递给 <code>Object.create()</code> 的对象</li><li>使用 <code>Object.create()</code> ，我们可以让对象从我们想要的任何对象进行继承(即不仅是<code>prototype</code>)</li><li><code>Object.create()</code>让我们既可以实现原型继承，又不会改变原型</li><li>该方法直接在一个对象上被调用</li></ul><p><strong>参考答案：</strong> <code>1、2、3</code></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr><p>JavaScript 中的继承重点就是建立原型链。这让我们可以子类化，也就是创建一个“子”对象，让它继承“父”对象的大部分或全部属性和方法。然后，我们可以分别实现任何子对象的独特属性和方法，同时仍然保留其父对象的数据和功能。</p><p>对象（实例）通过该实例的 <code>__proto__</code> 属性被秘密链接到其构造函数的原型对象。 你不应该在你编写的任何代码中使用 <code>__proto__</code>。在任何代码中使用 <code>__proto__</code>，或者只继承原型，将会直接导致某些不必要的问题。要在 JavaScript 中高效地管理继承，一个有效的方式就是避免完全改变原型。</p><p><code>Object.create()</code> 可以帮助我们做到这一点，它可以接受一个父对象，返回一个 <strong>新的</strong> 对象，并将其 <code>__proto__</code> 属性设置为该父对象。</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><hr><ul><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">继承和原型链</a></p></li><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">Object.create()</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;子类&quot;&gt;&lt;a href=&quot;#子类&quot; class=&quot;headerlink&quot; title=&quot;子类&quot;&gt;&lt;/a&gt;子类&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;实现继承的好处之一就是它允许你重用现有代码。通过建立继承，我们可以子类化，也就是让一个“子”对象接受“父”对象的大部分或全部属性和
      
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="prototype" scheme="http://yoursite.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>原型继承</title>
    <link href="http://yoursite.com/2018/07/12/%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2018/07/12/原型继承/</id>
    <published>2018-07-12T10:16:59.000Z</published>
    <updated>2019-03-05T10:08:33.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型、原型链"><a href="#原型、原型链" class="headerlink" title="原型、原型链"></a>原型、原型链</h2><hr><blockquote><p>JavaScript 常被描述为一种基于原型的语言 (prototype-based language)。每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。</p></blockquote><p>准确地说，这些属性和方法定义在 Object的构造器函数(constructor functions)之上的 <code>prototype</code> 属性上，而非对象实例本身。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr><p>我的父母是黑色头发，我也是黑色的头发。可以看出，我从我父母那里遗传了黑头发基因。</p><p>在 JavaScript 中 继承是指一个对象基于另一个对象。</p><blockquote><p>假设有一个新建的 car 对象的构造函数，每个 car 对象都具有不同的颜色属性值，例如 红色、蓝色和绿色；对象不仅具有自己的属性，而且与通用对象秘密关联，这种通用对象称之为原型；我们可以向原型中添加 car 对象都能共享的方法 drive方法 ，因此在每次新建一个 car 时，它们可以共享相同的 drive 方法，而不是创建新的 drive 方法。</p></blockquote><p>和其他语言不同，JavaScript 利用原型来管理继承。</p><h2 id="添加方法到原型"><a href="#添加方法到原型" class="headerlink" title="添加方法到原型"></a>添加方法到原型</h2><hr><p>还记得吗，对象包含数据（即属性）和操纵数据的手段（即方法）。在此之前，我们都是将方法直接添加到构造函数本身：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.lives = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Meow! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过将一个函数保存到新创建的 <code>Cat</code> 对象的 <code>sayName</code> 属性中，可以将 <code>sayName()</code> 方法添加到所有 <code>Cat</code> 对象上。这样做没问题，但是如果我们想用这个构造函数实例化更多的 <code>Cat</code> 对象呢？你每一次都要为这个 <code>Cat</code> 对象的 <code>sayName</code> 创建一个新的函数！更重要的是：如果你想对方法进行更改，则必须<em>逐个更新所有对象。在这种情况下，最好是让同一个 <code>Cat</code> 构造函数所创建的所有对象共享</em>一个 <code>sayName</code> 方法。</p><p>为了节省内存并保持简洁，我们可以在构造函数的 <code>prototype</code> 属性中添加方法。原型只是一个对象，构造函数所创建的所有对象都会保持对原型的引用。这些对象甚至可以将       <code>prototype</code> 的属性当作自身属性来使用！</p><p>JavaScript 利用对象与其原型之间的这个秘密链接来实现继承。请考虑以下原型链：</p><p><img src="/images/prototype.png" alt="原型链"></p><p>还记得吗，每个函数都有一个 <code>prototype</code> 属性，它其实只是一个对象。当使用 new 运算符将该函数作为构造函数来调用时，它会创建并返回一个新的对象。该对象被秘密地链接到其构造函数的 <code>prototype</code>，而这个秘密链接让该对象可以访问 <code>prototype</code> 的属性和方法，就像它自己的一样！</p><p>由于我们知道 <code>prototype</code> 属性仅仅指向一个普通对象，因此<em>这个对象本身也有一个秘密链接指向它的原型。而且，这个原型对象也有引用指向它自己的</em>原型，以此类推。原型链就是这样形成的。</p><p>无论你是访问属性（例如 <code>bailey.lives</code>）还是调用方法（即 <code>bailey.meow()</code>），JavaScript 解释器都会按照特定的顺序在原型链中查找它们：</p><ul><li>首先，JavaScript 引擎将查看对象自身的属性。这意味着，直接在该对象中定义的任何属性和方法将优先于其他位置的任何同名属性和方法（类似于作用域链中的变量阴影）。</li><li>如果找不到目标属性，它将搜索对象的构造函数的原型，以寻找匹配。</li><li>如果原型中不存在该属性，则 JavaScript 引擎将沿着该链继续查找。</li><li>该链的最顶端是 Object() 对象，也就是顶级父对象。如果 <strong>仍然</strong> 找不到该属性，则该属性为未定义。</li></ul><p>之前，我们都是直接在构造函数中定义方法。让我们来看看，如果我们转而在构造函数的 prototype 中定义方法，情况又会如何！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">age, weight, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.bark = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> says woof!`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这是 Dog 构造函数，我们可以调用它来创建一个具有以下四种属性的对象：age, weight, name 和 bark， 可以在构造器中定义 bark 方法，我们也可以将 bark 方法移到 dog 的原型中，直接使用点记法来定义 bark，像这样:</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Dog.prototype.bark = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> says woof!`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>函数就变为:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">age, weight, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype.bark = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> says woof!`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们将调用 dog 的构造函数来创建一个新的对象, 并调用这个新的 dog 的 bark方法:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dog1 = <span class="keyword">new</span> Dog(<span class="number">2</span>, <span class="number">60</span>, <span class="string">'Java'</span>);</span><br><span class="line"></span><br><span class="line">dog2 = <span class="keyword">new</span> Dog(<span class="number">4</span>, <span class="number">55</span>, <span class="string">'Jodi'</span>);</span><br><span class="line"></span><br><span class="line">dog1.bark();  <span class="comment">// Java says woof!</span></span><br><span class="line"></span><br><span class="line">dog2.bark();  <span class="comment">// Jodi says woof!</span></span><br></pre></td></tr></table></figure><p>让我们回顾一下，发生了什么？</p><blockquote><p>当我们在新建的 dog 对象中调用 bark 方法时，JavaScript 引擎会查看自己的属性，尝试找到与 bark 方法相匹配的名称，由于 bark 没有直接定义在这个 dog 上，它会看看 bark 方法的原型，最后，我们不需要调用 <code>dog.prototype.bark()</code>，我们只需要调用 <code>dog.bark()</code> 就会起作用，因为这个 dog 对象已经通过它的原型与 bark 方法联系起来了。</p></blockquote><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><hr><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (A)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dalmatian</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.bark = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> barks!`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (B)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dalmatian</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dalmatian.prototype.bark = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> barks!`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>假设我们想定义一个可以在 Dalmatian 构造函数的实例（对象）上调用的方法（我们将会实例化至少 101 个对象！）。前面两种方式中的哪一种是最佳选择？</p></blockquote><p><strong>参考答案：</strong> <code>(B)是最佳选择，因为每次创建 Dalmatian 的实例时，将不需要重新创建 bark 所指向的函数。</code></p><h2 id="替换-prototype-对象"><a href="#替换-prototype-对象" class="headerlink" title="替换 prototype 对象"></a>替换 <code>prototype</code> 对象</h2><hr><p>如果完全替换某个函数的 prototype 对象，结果会怎样？这将如何影响该函数所创建的对象？让我们来看一个简单的 Hamster 构造函数，并实例化一些对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hamster</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.hasFur = <span class="literal">true</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> waffle = <span class="keyword">new</span> Hamster(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pancake = <span class="keyword">new</span> Hamster();</span><br></pre></td></tr></table></figure><p>首先要注意的是，在创建新的对象 waffle 和 pancake 之后，我们仍然可以为 Hamster 的原型添加属性，而且它仍然可以访问这些新的属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Hamster.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Chomp chomp chomp!'</span>); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">waffle.eat(); <span class="comment">// 'Chomp chomp chomp!'</span></span><br><span class="line"></span><br><span class="line">pancake.eat(); <span class="comment">// 'Chomp chomp chomp!'</span></span><br></pre></td></tr></table></figure><p>现在，让我们将 <code>Hamster</code> 的 <code>prototype</code> 对象完全替换为其他内容：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Hamster.prototype = &#123;</span><br><span class="line">    isHungry: <span class="literal">false</span>,</span><br><span class="line">    color: <span class="string">'brown'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先前的对象无法访问更新后的原型的属性；它们只会保留与旧原型的秘密链接：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(waffle.color); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">waffle.eat(); <span class="comment">// 'Chomp chomp chomp!'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pancake.isHungry); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>事实证明，此后创建的任何新的 <code>Hamster</code> 对象都会使用更新后的原型：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> muffin = <span class="keyword">new</span> Hamster();</span><br><span class="line"></span><br><span class="line">muffin.eat(); <span class="comment">// TypeError: muffin.eat is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(muffin.isHungry); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(muffin.color); <span class="comment">// 'brown'</span></span><br></pre></td></tr></table></figure><h2 id="检查对象的属性"><a href="#检查对象的属性" class="headerlink" title="检查对象的属性"></a>检查对象的属性</h2><hr><p>正如我们刚刚所看到的，如果一个对象本身没有某个特定属性，它可以访问原型链中某个这样的属性（当然，假设它是存在的）。由于选择很多，有时可能会不好判断某个特定的属性究竟来自哪里！这里有一些有用的方法可以帮助你进行判断。</p><h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h3><hr><p><code>hasOwnProperty()</code> 可以帮助你找到某个特定属性的来源。在向其传入你要查找的属性名称的字符串后，该方法会返回一个布尔值，指示该属性是否属于该对象本身（即该属性 <strong>不是</strong> 被继承的）。请考虑在函数中直接定义一个属性的 <code>Phone</code> 构造函数，以及它的 <code>prototype</code> 对象的另一个属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.operatingSystem = <span class="string">'Android'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Phone.prototype.screenSize = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>现在，让我们创建一个新的对象 myPhone，并检查 operatingSystem 是否为其本身的属性，也就是说，它不是从该对象的原型（或原型链上的其他地方）继承来的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPhone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> own = myPhone.hasOwnProperty(<span class="string">'operatingSystem'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(own);</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>它确实返回为真！那么，Phone 对象的 prototype 上的 screenSize 属性又如何呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inherited = myPhone.hasOwnProperty(<span class="string">'screenSize'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(inherited);</span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>使用 <code>hasOwnProperty()</code>，我们可以洞察某个属性的来源。</p><h3 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a>isPrototypeOf()</h3><hr><p>对象还可以访问 <code>isPrototypeOf()</code> 方法，该方法可以检查某个对象是否存在于另一个对象的原型链中。 使用这种方法，你可以确认某个特定的对象是否是另一个对象的原型。请看以下 <code>rodent</code> 对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rodent = &#123;</span><br><span class="line">    favoriteFood: <span class="string">'cheese'</span>,</span><br><span class="line">    hasTail: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，让我们来构建一个 <code>Mouse()</code> 构造函数，并将它的 <code>prototype</code> 赋给 <code>rodent</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mouse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.favoriteFood = <span class="string">'cheese'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mouse.prototype = rodent;</span><br></pre></td></tr></table></figure><p>如果我们创建一个新的 <code>Mouse</code> 对象，它的原型应该是 <code>rodent</code> 对象。让我们来确认一下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ralph = <span class="keyword">new</span> Mouse();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = rodent.isPrototypeOf(ralph)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>太棒了！<code>isPrototypeOf()</code> 是确认某个对象是否存在于另一个对象的原型链中的好办法。</p><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><hr><p><code>isPrototypeOf()</code> 很有用处，但要记住，要想使用它，你必须首先掌握原型对象！如果你不确定某个对象的原型是什么呢？<code>Object.getPrototypeOf()</code> 可以帮助你解决这个问题。</p><p>使用前面的例子，让我们将 <code>Object.getPrototypeOf()</code> 的返回值存储在变量 <code>myPrototype</code> 中，然后检查它是什么：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPrototype = <span class="built_in">Object</span>.getPrototypeOf(ralph);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myPrototype);</span><br><span class="line"><span class="comment">//&#123; favoriteFood: "cheese", hasTail: true &#125;</span></span><br></pre></td></tr></table></figure><p>太棒了！<code>ralph</code> 的原型 <code>rodent</code> 对象 与 返回的结果 具有相同的属性，因为它们就是同一个对象。 <code>Object.getPrototypeOf()</code> 很适合检索给定对象的原型。</p><h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><hr><p>每次创建一个对象时，都会有一个特殊的属性被暗中分配给它：<code>constructor</code>。</p><p>访问一个对象的 <code>constructor</code> 属性会返回一个对创建该对象的构造函数的引用！</p><p>以下是一个简单的 <code>Longboard</code> 构造函数。我们还会继续创建一个新的对象，然后将其保存到一个 <code>board</code> 变量中：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Longboard</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.material = <span class="string">'bamboo'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> board = <span class="keyword">new</span> Longboard();</span><br></pre></td></tr></table></figure><p>如果我们访问 <code>board</code> 的 <code>constructor</code> 属性，我们应该会看到原来的构造函数本身：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(board.constructor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// function Longboard() &#123;</span></span><br><span class="line"><span class="comment">//    this.material = 'bamboo';</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>好极了！请记住，如果某个对象是使用字面量表示法创建的，那么它的构造函数就是内置的 <code>Object()</code> 构造函数！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rodent = &#123;</span><br><span class="line">    teeth: <span class="string">'incisors'</span>,</span><br><span class="line">    hasTail: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(rodent.constructor);</span><br><span class="line"><span class="comment">//function Object() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><h3 id="小练习-1"><a href="#小练习-1" class="headerlink" title="小练习"></a>小练习</h3><hr><blockquote><p>以下哪一项有关 <code>hasOwnProperty()</code> 的说法是正确的？请选择所有适用项：</p></blockquote><ul><li>一个对象会作为参数传递给 <code>hasOwnProperty</code></li><li>它会返回一个布尔值，指示对象是否具有所指定的属性作为其本身属性(即该属性不是被继承的)</li><li>一个字符串不能作为参数传递给 <code>hasOwnProperty()</code></li><li><code>hasOwnProperty()</code> 作为一个方法被调用到一个对象</li></ul><p><strong>参考答案：</strong> 2、4</p><blockquote><p>以下哪一项有关 <code>isProtypeOf()</code> 或 <code>getPrototypeOf()</code> 的说法是正确的？请选择所有适用项：</p></blockquote><ul><li><code>isProtypeOf()</code> 可以检查某个对象是否存在于另一个对象的原型链中</li><li><code>isProtypeOf()</code> 会接受一个参数：一个原型链将被搜索的对象</li><li><code>getProtypeOf()</code> 在构造函数的一个实例(即单个对象本身)上被调用</li><li><code>getProtypeOf()</code> 会返回传递给它的对象的原型</li></ul><p><strong>参考答案：</strong> 2、4</p><blockquote><p>以下哪一项有关 <code>constructor</code> 属性的说法是正确的？请选择所有适用项：</p></blockquote><ul><li>访问一个对象的 <code>constructor</code> 属性会返回一个对创建该对象(实例)的构造函数的引用</li><li><code>constructor</code> 属性的值只是构造函数名称的一个字符串，而不是该函数本身</li><li>每个对象都有一个 <code>constructor</code> 属性</li><li>使用字面量表示法创建的对象是用 <code>Object()</code> 构造函数构建的</li></ul><p><strong>参考答案：</strong> 1、3、4</p><blockquote><p>假设我们使用常规的对象字面量表示法来创建以下对象 <code>capitals</code>：<br>当 Object.getPrototypeOf(capitals); 被执行时，会返回什么？</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> capitals = &#123;</span><br><span class="line">    California: <span class="string">'Sacramento'</span>,</span><br><span class="line">    Washington: <span class="string">'Olympia'</span>,</span><br><span class="line">    Oregon: <span class="string">'Salem'</span>,</span><br><span class="line">    Texas: <span class="string">'Austin'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>参考答案：</strong> 对 <code>Object()</code> 原型的引用</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr><p>JavaScript 中的继承是指一个对象基于另一个对象。继承让我们可以重用现有的代码，使对象具有其他对象的属性。</p><p>当使用 new 运算符将一个函数作为构造函数来调用时，该函数会创建并返回一个新的对象。这个对象会被秘密链接到其构造函数的 <code>prototype</code>，而它只是另一个对象。使用这个秘密链接，可以让一个对象访问原型的属性和方法，就像是它自己的一样。如果 JavaScript 没有在某个对象中找到一个特定属性，它将在原型链上继续查找。如有必要，它会一路查找到 <code>Object()</code>（顶级父对象）。</p><ul><li>对象如何查看对象的构造函数 –&gt; <code>obj.constructor</code> 属性</li><li>对象如何查看原型 –&gt; 隐式属性 <code>__proto__</code></li><li>修改原型 –&gt; <code>obj.prototype.xxx = xxx</code></li><li>(原型链的终端)绝大多数对象的最终原型: <code>Object.prototype</code></li></ul><p>为了更理解 原型 / 构造函数 / 实例 三者的关系，请看下面这张图：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实例.__proto__ === 原型</span><br><span class="line">构造函数.prototype === 原型</span><br><span class="line">原型.constructorr === 构造函数</span><br></pre></td></tr></table></figure><p><img src="/images/prototype1.png" alt="原型 / 构造函数 / 实例"></p><p>此外，我们还介绍了几个方法和属性，可以用于检查对象及其原型的来源和引用，即：</p><ul><li>hasOwnProperty()</li><li>isPrototypeOf()</li><li>Object.getPrototypeOf()</li><li>constructor</li></ul><p>在下一部分，我们将从子类化的角度来探索原型继承的另一方面。如果你想从一个对象中只继承几个属性，但是又想让这个对象具有其他专有属性，该怎么办呢？我们将在下一部分对原型继承进行更深入的探讨。</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><hr><ul><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="noopener">hasOwnProperty()</a></p></li><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf" target="_blank" rel="noopener">isPropertyOf()</a></p></li><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noopener">Object.getPrototypeOf()</a></p></li><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="noopener">constructor</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原型、原型链&quot;&gt;&lt;a href=&quot;#原型、原型链&quot; class=&quot;headerlink&quot; title=&quot;原型、原型链&quot;&gt;&lt;/a&gt;原型、原型链&lt;/h2&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;JavaScript 常被描述为一种基于原型的语言 (prototype
      
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="prototype" scheme="http://yoursite.com/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>设置自己的this</title>
    <link href="http://yoursite.com/2018/07/02/%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%B7%B1%E7%9A%84this/"/>
    <id>http://yoursite.com/2018/07/02/设置自己的this/</id>
    <published>2018-07-02T10:10:35.000Z</published>
    <updated>2019-03-05T10:16:56.077Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道 根据函数的调用方式 <code>this</code> 会设成不同的值，<code>Javascript</code> 提供了几种设置 <code>this</code>值的方法:</p><ul><li>call()</li><li>apply()</li><li>bind()</li></ul><blockquote><p><code>call</code> 和 <code>apply</code> 作为方法在函数上被调用，会因为参数的传入方式不同而有所不同，<code>bind</code> 是返回新函数的方法.</p></blockquote><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><hr><p><code>call()</code> 是一个直接调用到函数上的方法。我们传递给它一个单一的值，以设置为 this 的值，然后逐个传入该函数的任何参数，用逗号分隔。</p><p>请考虑以下函数 multiply()，它只会返回其两个参数的乘积：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1 * n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们在控制台中调用它：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">multiply(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>这里没有任何惊喜！但现在，让我们使用 <code>call()</code> 方法来调用同一个函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">multiply.call(<span class="built_in">window</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>我们得到了相同的结果！这是怎么发生的？我们首先直接调用 <code>call()</code> 方法到 <code>multiply()</code> 函数上。请注意，<code>.call(window, 3, 4)</code> 之前的 <code>multiply</code> 后​​面没有任何括号！ <code>call()</code> 将会处理该调用 和 <code>multiply()</code> 函数的参数本身！</p><p>这一步完成后，我们传递将设置为 <code>this</code> 的值作为 <code>call()</code> 的第一个参数：<code>window</code>。最后，我们逐个传递 <code>multiply()</code> 函数的参数，并用逗号分隔。</p><p>当 <code>multiply.call(window, 3, 4)</code>; 执行后，该函数将以 <code>this</code> 的给定值被调用，我们所看到的结果就是 12。在严格模式之外，调用 <code>multiply()</code> 的这两种方式是等价的。</p><p>除了调用常规函数之外，我们如何调用附加到对象上的函数（即方法）呢？这是 <code>call()</code> 真正发挥强大功能的地方。使用 <code>call()</code> 来调用方法允许我们从对象中“借用”方法，然后将其用于另一个对象！请看以下对象 <code>mockingbird</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mockingbird = &#123;</span><br><span class="line">    title: <span class="string">'To Kill a Mockingbird'</span>,</span><br><span class="line">    describe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.title&#125;</span> is a classic novel`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以让 <code>mockingbird</code> 调用自己的 <code>describe()</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mockingbird.describe();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'To Kill a Mockingbird is a classic novel'</span></span><br></pre></td></tr></table></figure><p>但是，借助 <code>call()</code>，以下 <code>pride</code> 对象可以使用 <code>mockingbird</code> 的 <code>describe()</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pride = &#123;</span><br><span class="line">    title: <span class="string">'Pride and Prejudice'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mockingbird.describe.call(pride);</span><br><span class="line"><span class="comment">// 'Pride and Prejudice is a classic novel'</span></span><br></pre></td></tr></table></figure><p>让我们来分析一下当 <code>mockingbird.describe.call(pride)</code>; 被执行时，究竟发生了什么！首先，<code>call()</code> 方法被调用到 <code>mockingbird.describe</code>（它指向一个函数）上。然后，<code>this</code> 的值被传递给 <code>call()</code> 方法：<code>pride</code>。</p><p>由于 <code>mockingbird</code> 的 <code>describe()</code> 方法引用了 <code>this.title</code>，我们需要访问 this 所指向的对象的 <code>title</code> 属性。但是，由于我们已经设置了自己的 <code>this</code> 的值，<code>this.title</code> 的值将会从 <code>pride</code> 对象中被访问！结果，<code>mockingbird.describe.call(pride)</code>; 被执行，我们在控制台中看到 <code>&#39;Pride and Prejudice is a classic novel&#39;</code>。</p><p>如果你打算在传递给它的第一个参数的作用域内调用一个函数，那么 <code>call()</code> 是非常有效的。同样，我们可以利用 <code>apply()</code> 方法达到相同的目的，尽管在参数传入的方式上有所不同。让我们来仔细看看！</p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><hr><p>就像 <code>call()</code> 一样，<code>apply()</code> 在一个函数上被调用，不仅可以调用该函数，而且还可以为它关联一个特定的 this 值。但是，<code>apply()</code> 并不是逐个传递参数并用逗号分隔，而是将函数的参数放在一个_数组_中。请回想一下之前的 <code>multiply()</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1 * n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用了 <code>call()</code>，并逐个传递参数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">multiply.call(<span class="built_in">window</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>然而，使用 <code>apply()</code>，我们则是将 <code>multiply()</code> 函数的所有参数收集到一个数组中，然后再将这个数组传递给 <code>apply()</code>：</p><p>太棒了！那么，使用 <code>apply()</code> 来调用对象的方法，又会怎样呢？请回想一下之前的 <code>mockingbird</code> 和 <code>pride</code> 对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mockingbird = &#123;</span><br><span class="line">    title: <span class="string">'To Kill a Mockingbird'</span>,</span><br><span class="line">    describe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.title&#125;</span> is a classic novel`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pride = &#123;</span><br><span class="line">    title: <span class="string">'Pride and Prejudice'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之前，我们使用了 <code>call()</code> 来允许 <code>pride</code> 对象”借用” <code>mockingbird</code> 的 <code>describe()</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mockingbird.describe.call(pride);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'Pride and Prejudice is a classic novel'</span></span><br></pre></td></tr></table></figure><p>我们可以使用 apply() 来达到相同的结果！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mockingbird.describe.apply(pride);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'Pride and Prejudice is a classic novel'</span></span><br></pre></td></tr></table></figure><p>请注意，传递给 <code>call()</code> 和 <code>apply()</code> 的第一个参数是相同的（即绑定 this 值的对象）。由于 <code>describe()</code> 方法不接受任何参数，因此 <code>mockingbird.describe.call(pride)</code>; 和 <code>mockingbird.describe.apply(pride)</code>; 唯一的区别就是方法！这两种方法都会产生相同的结果。</p><h2 id="偏向选择其中一种方法"><a href="#偏向选择其中一种方法" class="headerlink" title="偏向选择其中一种方法"></a>偏向选择其中一种方法</h2><hr><p><code>call()</code> 和 <code>apply()</code> 都会在其传入的第一个参数（即作为 this 值的对象）的作用域内调用一个函数。那么，你什么时候会偏向于选择 <code>call()</code>，或偏向于选择 <code>apply()</code> 呢？</p><p>如果你事先并不知道函数所需要的参数个数，那么 <code>call()</code> 的使用可能会受到限制。在这种情况下，<code>apply()</code> 是一个更好的选择，因为它只接受一个参数数组，然后将其解包并传递给函数。请记住，解包可能会略微影响性能，但这种影响并不显著。</p><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><blockquote><p>请考虑以下 dave 对象和 sayHello() 函数：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dave = &#123;</span><br><span class="line">    name: <span class="string">'Dave'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;message&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>. You're looking well today.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设你想将消息 <code>&#39;Hello, Dave. You&#39;re looking well today.&#39;</code> 输出到控制台。你应该编写哪个表达式来达到这个目的？</p><p><strong>参考答案：</strong> sayHello.apply(dave, [‘Hello’]);</p><blockquote><p>请考虑以下 Andrew 和 Richard 对象：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Andrew = &#123;</span><br><span class="line">    name: <span class="string">'Andrew'</span>,</span><br><span class="line">    introduce: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Richard = &#123;</span><br><span class="line">    name: <span class="string">'Richard'</span>,</span><br><span class="line">    introduce: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Hello there! I'm <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 <code>Richard.introduce.call(Andrew)</code>; 被执行时，什么会被记录到控制台？</p><p><strong>参考答案：</strong> <code>&#39;Hello there! I&#39;m Andrew.&#39;</code></p><blockquote><p>请考虑以下代码：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> andrew = &#123;</span><br><span class="line">    name: <span class="string">'Andrew'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">introduce</span>(<span class="params">language</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`I'm <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and my favorite programming language is <span class="subst">$&#123;language&#125;</span>.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请编写一个表达式，使用 call() 方法产生以下消息：<br><code>&#39;I&#39;m Andrew and my favorite programming language is JavaScript.&#39;</code></p><p><strong>参考答案：</strong> <code>introduce.call(andrew,&#39;JavaScript&#39;)</code></p><h2 id="回调和-this"><a href="#回调和-this" class="headerlink" title="回调和 this"></a>回调和 <code>this</code></h2><hr><p>当涉及到回调函数时，this 的值有一些潜在的作用域问题，事情会变得比较棘手。接下来，让我们来看看这个问题。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeTwice</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">    age: <span class="number">5</span>,</span><br><span class="line">    growOneYear: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先，调用 <code>growOneYear()</code> 按预期运作，将 <code>dog</code> 对象的 <code>age</code> 属性的值从 <code>5</code> 更新为 <code>6</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dog.growOneYear();</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">dog.age; </span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>但是，将 <code>dog.growOneYear</code>（一个函数）作为参数传递给 <code>invokeTwice()</code> 则会产生不希望的结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">invokeTwice(dog.growOneYear);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">dog.age; </span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>这是什么原因呢？事实证明，invokeTwice() 确实会调用 growOneYear，但它是被调用为一个 <strong>函数而不是一个方法</strong>！让我们回顾一下先前的 this 网格：</p><table><thead><tr><th style="text-align:center">Call Style</th><th style="text-align:center"><code>new</code></th><th style="text-align:center">method</th><th style="text-align:center">function</th></tr></thead><tbody><tr><td style="text-align:center"><code>this</code></td><td style="text-align:center">{}</td><td style="text-align:center">object itself</td><td style="text-align:center">global object</td></tr><tr><td style="text-align:center">Example</td><td style="text-align:center">new Cat()</td><td style="text-align:center">bailey.sayName()</td><td style="text-align:center">introduce()</td></tr></tbody></table><blockquote><p>如果使用 <code>new</code> 运算符来调用构造函数，<code>this</code> 的值将被设置为新创建的对象，如果在对象上调用方法，<code>this</code> 将被设置为该对象本身，如果简单地调用一个函数，<code>this</code> 将被设置为全局对象: <code>window</code></p></blockquote><h2 id="使用匿名闭包来保存-this"><a href="#使用匿名闭包来保存-this" class="headerlink" title="使用匿名闭包来保存 this"></a>使用匿名闭包来保存 this</h2><hr><p>还记得吗，简单地调用一个普通函数会将 <code>this</code> 的值设置为全局对象（即 <code>window</code>）。我们如何解决这个问题呢？</p><p>解决这个问题的一种方式就是使用一个匿名闭包来遮蔽 <code>dog</code> 对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">invokeTwice(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    dog.growOneYear(); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dog.age</span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>使用这种方式，调用 <code>invokeTwice()</code> 仍然会将 <code>this</code> 的值设置为 <code>window</code>。但是，这对闭包没有影响；在匿名函数中，<code>growOneYear()</code> 方法仍然会被直接调用到 <code>dog</code> 对象上。因此，<code>dog</code> 的 age 属性的值会从 5 更新为 7。</p><p>由于这是一种十分常见的模式，因此 JavaScript 提供了另一种比较简洁的方式：<code>bind()</code> 方法。</p><h2 id="使用-bind-来保存-this"><a href="#使用-bind-来保存-this" class="headerlink" title="使用 bind() 来保存 this"></a>使用 bind() 来保存 this</h2><hr><p>与 <code>call()</code> 和 <code>apply()</code> 类似，<code>bind()</code> 方法也允许用户直接为 <code>this</code> 定义一个值。<code>bind()</code> 也是一个在函数上调用的方法，但不同于 <code>call()</code> 或 <code>apply()</code>，它们都会立即调用函数——<code>bind()</code> 会返回一个新的函数。当被调用时，该函数会将 <code>this</code> 设置为我们赋给它的值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">    age: <span class="number">5</span>,</span><br><span class="line">    growOneYear: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeTwice</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">invokeTwice(dog.growOneYear);</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>因为<code>bind()</code> 会返回一个新的函数，将其保存在新的变量中，称之为 <code>myGrow</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myGrow = dog.growOneYear.bind(dog);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">invokeTwice(myGrow);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">dog.age;</span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h3 id="小练习-1"><a href="#小练习-1" class="headerlink" title="小练习"></a>小练习</h3><blockquote><p>请考虑以下 <code>driver</code> 和 <code>car</code> 对象：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> driver = &#123;</span><br><span class="line">    name: <span class="string">'Danica'</span>,</span><br><span class="line">    displayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Name: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">    name: <span class="string">'Fusion'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>请使用 <code>bind()</code> 编写一个表达式，让我们可以从 <code>driver</code> 中”借用” <code>displayName()</code> 方法，以供 <code>car</code> 对象使用。</p><p><strong>参考答案：</strong> <code>driver.displayName.bind(car)</code></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr><p>JavaScript 提供了三种方法，让我们可以为一个给定的函数设置 <code>this</code> 的值：</p><ul><li><code>call()</code> 会调用该函数，逐个传入参数，并用逗号分隔。</li><li><code>apply()</code> 与 <code>call()</code> 类似；它会照样调用该函数，但它会将参数作为一个数组传入。</li><li><code>bind()</code> 会返回一个新的函数，并将 this 绑定到一个特定对象，让我们可以按照函数的样式来调用它。<br>如需进一步研究，我们建议你查看 Kyle Simpson 有关 this 的你不了解 JS 系列，链接已在下方提供。</li></ul><p>到目前为止，你已经看到函数、对象和 this 关键字是如何相互关联的。你也看到了 JavaScript 中的几乎所有东西都是一个对象！你知道吗，你甚至可以将对象建立在其他对象上！这是原型继承背后的主要思想。通过实现它，对象可以接受其他对象的属性。接下来，我们将探索这一切，以及更多知识！</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><hr><ul><li><p><a href="https://github.com/doraeige/document/blob/master/js/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8A%E5%8D%B7%EF%BC%89.pdf" target="_blank" rel="noopener">你不知道的JavaScript（上卷）</a></p></li><li><p><a href="https://github.com/doraeige/document/blob/master/js/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%AD%E5%8D%B7%EF%BC%89.pdf" target="_blank" rel="noopener">你不知道的JavaScript（中卷）</a></p></li><li><p><a href="https://github.com/doraeige/document/blob/master/js/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20JavaScript%EF%BC%88%E4%B8%8B%E5%8D%B7%EF%BC%89.pdf" target="_blank" rel="noopener">你不知道的 JavaScript（下卷）</a></p></li><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">call()</a></p></li><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener">apply()</a></p></li><li><p>MDN 上的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">bind()</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道 根据函数的调用方式 &lt;code&gt;this&lt;/code&gt; 会设成不同的值，&lt;code&gt;Javascript&lt;/code&gt; 提供了几种设置 &lt;code&gt;this&lt;/code&gt;值的方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;call()&lt;/li&gt;
&lt;li&gt;apply()&lt;/li&gt;
      
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="this" scheme="http://yoursite.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 的 this 用法</title>
    <link href="http://yoursite.com/2018/06/28/Javascript-%E7%9A%84-this-%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2018/06/28/Javascript-的-this-用法/</id>
    <published>2018-06-28T11:40:13.000Z</published>
    <updated>2019-03-05T10:16:11.599Z</updated>
    
    <content type="html"><![CDATA[<p><code>this</code> 是 JavaScript 语言的一个关键字。</p><h3 id="构造函数中的-this"><a href="#构造函数中的-this" class="headerlink" title="构造函数中的 this"></a>构造函数中的 this</h3><hr><p>在上一部分，我们使用了方法中的 <code>this</code> 来访问该方法所属的 <strong>对象</strong>。让我们再来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.lives = <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'Meow! My name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bailey = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><p>在上面的 <code>Cat()</code> 构造函数中，<code>sayName</code> 所指向的函数引用了 <code>this.name</code>。之前，我们已经看到过在方法中使用 <code>this</code>，但在这里，<code>this</code> 是指什么呢？</p><p>事实证明，当使用 <code>new</code> 运算符来调用构造函数时，<code>this</code> 会被设置为新创建的对象！让我们来看看新的 <code>bailey</code> 对象是什么样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: Bailey,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Meow! My name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码段中，请注意 this 位于构造函数 <strong>外部</strong>。正如我们在上一篇文章中所看到的，当你说 this 时，你其实是在说“这个对象”或“当前对象”。因此，<code>sayName()</code> 方法可以使用 this 来访问该对象的 <code>name</code> 属性！这使得以下方法调用成为可能：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bailey.sayName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Meow! My name is Bailey</span></span><br></pre></td></tr></table></figure><h2 id="this-什么时候会被赋值？"><a href="#this-什么时候会被赋值？" class="headerlink" title="this 什么时候会被赋值？"></a>this 什么时候会被赋值？</h2><hr><p>一个常见的误解是，this 指向定义它的对象。事实并非如此！直到某个对象调用使用 this 的方法，this 才会被赋值。换句话说，赋给 this 的值取决于 调用定义 this 的方法的对象。让我们来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">  bark: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Woof!'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  barkTwice: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bark();</span><br><span class="line">    <span class="keyword">this</span>.bark();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>让我们继续调用 <code>dog</code> 的两个方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dog.bark();</span><br><span class="line"><span class="comment">// Woof!</span></span><br><span class="line"></span><br><span class="line">dog.barkTwice();</span><br><span class="line"><span class="comment">// Woof!</span></span><br><span class="line"><span class="comment">// Woof!</span></span><br></pre></td></tr></table></figure><p>我们知道，当我们调用 <code>dog.bark()</code> 或 <code>dog.barkTwice()</code> 时，变量 <code>this</code> 将被设置。由于 <code>this</code> 可以访问调用它的对象，因此 <code>barkTwice</code> 可以使用 this 来访问包含 <code>bark</code> 方法的 <code>dog</code> 对象。<br>但是，如果我们在 <code>barkTwice</code> 中使用 <code>bark()</code>，而不是 <code>this.bark()</code>，将会怎样？该函数会先在 <code>barkTwice</code> 的作用域内查找一个名为 <code>bark</code> 的局部变量。如果没有找到 <code>bark</code>，则会沿着作用域链继续查找。<br>综合来看：<code>this.bark()</code> 会告诉 <code>barkTwice</code> 查看 <code>dog</code>（调用该方法的对象）以查找 <code>bark</code>。</p><h2 id="this-会被设置为什么？"><a href="#this-会被设置为什么？" class="headerlink" title="this 会被设置为什么？"></a>this 会被设置为什么？</h2><hr><p>到目前为止，我们已经在许多不同的上下文中看到了 <code>this</code>，比如在方法中，或被构造函数引用。现在，让我们把它们放在一起来看一下！<br>有四种方式可以调用函数，而每种方式都会不同地设置 <code>this</code>。</p><ul><li>首先，使用 new 关键字来调用构造函数会将  <code>this</code> 设置为一个新创建的对象。还记得吗，在我们之前创建 <code>Cat()</code> 的实例时，this 被设置为新的 <code>bailey</code> 对象。</li><li>另一方面，调用属于一个对象的函数（即_方法_）会将 <code>this</code> 设置为该对象本身。回想一下前面的示例，<code>dog</code> 对象的 <code>barkTwice</code> 方法能够访问 <code>dog</code> 本身的属性。</li><li>第三，单独调用一个函数（即简单地调用一个常规函数）将把 <code>this</code> 设置为 <code>window</code>。如果主机环境是浏览器，则它将是全局对象。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funFunction();</span><br><span class="line"><span class="comment">// (返回全局对象, `window`)</span></span><br></pre></td></tr></table></figure><ul><li>第四种调用函数的方式可以让我们自己设置 this！现在不用在意这一点，我们将在下一部分进行深入探讨。</li></ul><table><thead><tr><th style="text-align:center">Call Style</th><th style="text-align:center"><code>new</code></th><th style="text-align:center">method</th><th style="text-align:center">function</th></tr></thead><tbody><tr><td style="text-align:center"><code>this</code></td><td style="text-align:center">{}</td><td style="text-align:center">object itself</td><td style="text-align:center">global object</td></tr><tr><td style="text-align:center">Example</td><td style="text-align:center">new Cat()</td><td style="text-align:center">bailey.sayName()</td><td style="text-align:center">introduce()</td></tr></tbody></table><blockquote><p>如果使用 <code>new</code> 运算符来调用构造函数，<code>this</code> 的值将被设置为新创建的对象，如果在对象上调用方法，<code>this</code> 将被设置为该对象本身，如果简单地调用一个函数，<code>this</code> 将被设置为全局对象: <code>window</code></p></blockquote><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><blockquote><p>请考虑以下构造函数 <code>City</code>：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">City</span>(<span class="params">name, population</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.population = population;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.identify = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>'s population is <span class="subst">$&#123;<span class="keyword">this</span>.population&#125;</span>.`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>const sanFrancisco = new City(&#39;San Francisco&#39;, 870000)</code>; 被执行时，<code>this</code> 的值是什么？</p><p><strong>答案：</strong> 新创建的对象，被 <code>sanFrancisco</code> 引用</p><blockquote><p>请考虑以下对象 <code>building</code>：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> building = &#123;</span><br><span class="line">    floors: <span class="number">5</span>,</span><br><span class="line">    addFloor: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.floors += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">building.addFloor();</span><br></pre></td></tr></table></figure><p>当 <code>building.addFloor()</code> 被执行时，<code>this</code> 的值是什么？</p><p><strong>答案：</strong> <code>building</code></p><blockquote><p>当以下函数被调用时，this 的值是多少？</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"What is the value of 'this'?"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案：</strong> <code>window</code></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>函数、对象和 <code>this</code> 彼此相互关联。当使用 <code>new</code> 运算符来调用构造函数时，<code>this</code> 变量会被设置为新创建的对象。当在对象上调用方法时，<code>this</code> 会被设置为该对象本身。当在浏览器环境中调用函数时，<code>this</code> 会被设置为 <code>window</code>，也被称为全局对象。</p><p>除此之外，还有一组方式可以调用函数：使用 <code>apply()</code> 和使用 <code>call()</code>。这两种方式有许多相似之处，每一种方式都允许我们指定如何设置 <code>this</code>。接下来，我们会对它们进行详细分析！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;this&lt;/code&gt; 是 JavaScript 语言的一个关键字。&lt;/p&gt;
&lt;h3 id=&quot;构造函数中的-this&quot;&gt;&lt;a href=&quot;#构造函数中的-this&quot; class=&quot;headerlink&quot; title=&quot;构造函数中的 this&quot;&gt;&lt;/a&gt;构造函数中
      
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="this" scheme="http://yoursite.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>构造函数</title>
    <link href="http://yoursite.com/2018/06/20/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/06/20/构造函数/</id>
    <published>2018-06-20T03:22:12.000Z</published>
    <updated>2019-03-05T10:15:56.115Z</updated>
    
    <content type="html"><![CDATA[<p>创建对象的一个重要方式是使用构造函数，构造函数以大写字母开头，构造函数必须始终使用特殊关键字 new 来调用，<br>与普通函数的区别是：普通函数必须创建将返回的对象并直接修改该对象，而构造函数会自动创建对象，<br>然后，为了向此对象中添加属性或方法，需要使用特殊的关键字 <code>this</code>。</p><ul><li>要实例化（即 创建 ）一个新的对象，我们可以使用 <code>new</code> 运算符来调用这个函数：<br><code>new SoftwareDeveloper()</code>;</li></ul><h1 id="构造函数：结构和语法"><a href="#构造函数：结构和语法" class="headerlink" title="构造函数：结构和语法"></a>构造函数：结构和语法</h1><hr><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SoftwareDeveloper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.favoriteLanguage = <span class="string">'JavaScript'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，构造函数并不声明局部变量，而是使用 <code>this</code> 关键字来保存数据。以上函数将为所创建的任何对象添加一个 <code>favoriteLanguage</code> 属性，并为其分配一个默认值 ‘JavaScript’。现在不用太在意构造函数中的 <code>this</code>；只要知道 <code>this</code> 是指在构造函数前面使用 <code>new</code> 关键字创建的新对象即可。我们很快就会详细介绍这个 <code>this</code>！<br>最后一点比较特别的是，这个函数似乎不会返回任何东西！<code>JavaScript</code> 中的构造函数不应该有一个显式的返回值（即使用 <code>return</code> 语句）。</p><h2 id="创建一个新的对象"><a href="#创建一个新的对象" class="headerlink" title="创建一个新的对象"></a>创建一个新的对象</h2><hr><p>正如我们在上面看到的，让我们使用 new 运算符来创建一个新的对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> developer = <span class="keyword">new</span> SoftwareDeveloper();</span><br></pre></td></tr></table></figure><p>我们已经把这个调用的返回值保存到了变量 <code>developer</code> 中。让我们执行 <code>console.log(developer)</code>; 将这个 <code>SoftwareDeveloper</code> 对象记录到控制台：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(developer); <span class="comment">// SoftwareDeveloper &#123;favoriteLanguage: "JavaScript"&#125;</span></span><br></pre></td></tr></table></figure><p>用对象字面量的方式来创建对象，看看有何不同</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> orderDeveloper = &#123; <span class="attr">favoriteLanguage</span>: <span class="string">'JavaScript'</span> &#125;;</span><br><span class="line"></span><br><span class="line">otherDeveloper; <span class="comment">// &#123; favoriteLanguage: "JavaScript" &#125;</span></span><br></pre></td></tr></table></figure><p>可以看出 与 <code>developer</code> 相比，创建对象的构造函数 <code>SoftwareDeveloper</code> 没有列在Chrome 开发者工具中；<br>在 Chrome 开发者工具中 构造函数通常显示在 {} 前面；<br><code>developer</code> 的构造函数是 <code>SoftwareDeveloper</code>，而 <code>orderDeveloper</code> 的构造函数是 <code>object</code> 构造函数；比较之下，两者原型将有所不同。</p><h2 id="构造函数可以有参数"><a href="#构造函数可以有参数" class="headerlink" title="构造函数可以有参数"></a>构造函数可以有参数</h2><hr><p>与常规函数一样，使用构造函数的一个好处是它们也可以接受参数。让我们更新以上构造函数来接受一个参数，并为其分配 name 属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SoftwareDeveloper</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.favoriteLanguage = <span class="string">'JavaScript'</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在更新的 <code>SoftwareDeveloper()</code> 函数中，无论传入函数的值是什么，它都将是对象的 <code>name</code> 属性的值。让我们来看看：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instructor = <span class="keyword">new</span> SoftwareDeveloper(<span class="string">'Andrew'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instructor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SoftwareDeveloper &#123; favoriteLanguage: 'JavaScript', name: 'Andrew' &#125;</span></span><br></pre></td></tr></table></figure><p>正如我们在上面看到的，我们可以使用相同的构造函数来创建不同的对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> teacher = <span class="keyword">new</span> SoftwareDeveloper(<span class="string">'Richard'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(teacher);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SoftwareDeveloper &#123; favoriteLanguage: 'JavaScript', name: 'Richard' &#125;</span></span><br></pre></td></tr></table></figure><p>构造函数的好处是，我们可以调用相同的构造函数，创建无数个实例或对象。</p><h2 id="省略-new-运算符"><a href="#省略-new-运算符" class="headerlink" title="省略 new 运算符"></a>省略 new 运算符</h2><hr><p>如果你无意中 <strong>没有</strong> 使用 <code>new</code> 运算符来调用构造函数，会发生什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SoftwareDeveloper</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.favoriteLanguage = <span class="string">'JavaScript'</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> coder = SoftwareDeveloper(<span class="string">'David'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(coder);</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这是怎么回事？如果不使用 <code>new</code> 运算符，则不会创建对象。该函数会像任何其他常规函数一样被调用。由于该函数不会 _返回_ 任何东西（除了所有函数都会默认返回的 undefined 之外），因此 <code>coder</code> 变量最终会被分配给 <code>undefined</code>。</p><p>还有一点需要注意：由于这个函数作为一个常规函数被调用，因此 <code>this</code> 的值也会截然不同。现在不用太在意这一点，我们将在下一部分深入探讨 <code>this</code> 关键字！</p><h2 id="查看对象的构造函数-instanceof"><a href="#查看对象的构造函数-instanceof" class="headerlink" title="查看对象的构造函数(instanceof)"></a>查看对象的构造函数(instanceof)</h2><hr><p>如果我们想查看某个对象是否是用构造函数创建的呢？我们可以使用 <code>instanceof</code>（它会返回一个布尔值）来窥见一些端倪。让我们来看看吧！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Developer</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dev = <span class="keyword">new</span> Developer(<span class="string">'Veronkia'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> dev;  <span class="comment">// "object"</span></span><br><span class="line"></span><br><span class="line">dev <span class="keyword">instanceof</span> Developer;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="instanceof-和原型链"><a href="#instanceof-和原型链" class="headerlink" title="instanceof 和原型链"></a>instanceof 和原型链</h3><hr><p>在以上示例中，<code>instanceof</code> 确认一个特定的构造函数确实创建了一个特定的对象。我们知道这一点，是因为我们在调用 <code>Developer()</code> 构造函数之后直接实例化了 <code>dev</code> 对象。</p><p>然而，很多时候并没有这么简单：instanceof 运算符实际上会测试构造函数是否出现在某个对象的原型链中。这意味着，虽然我们不是总能检查到底是 <em>哪个构造函数</em> 创建了该对象，但是它使我们能够洞察某个对象可能访问哪些其他的属性和方法。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><hr><p>JavaScript 的类系统是直接使用函数和对象来构建的。使用 new 运算符来调用构造函数可以实例化一个新的对象。相同的构造函数可以用于创建不同的对象。</p><p>我们在整篇中广泛讨论了函数、对象和 this。事实证明，这三者是密切相关的！ 我们将在下一部分深入探讨 this 关键字，并仔细分析这三者之间的关系。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;创建对象的一个重要方式是使用构造函数，构造函数以大写字母开头，构造函数必须始终使用特殊关键字 new 来调用，&lt;br&gt;与普通函数的区别是：普通函数必须创建将返回的对象并直接修改该对象，而构造函数会自动创建对象，&lt;br&gt;然后，为了向此对象中添加属性或方法，需要使用特殊的关键字
      
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="Constructor" scheme="http://yoursite.com/tags/Constructor/"/>
    
      <category term="Object" scheme="http://yoursite.com/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>响应式设计(五)</title>
    <link href="http://yoursite.com/2018/05/08/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1-%E4%BA%94/"/>
    <id>http://yoursite.com/2018/05/08/响应式设计-五/</id>
    <published>2018-05-08T06:56:14.000Z</published>
    <updated>2019-03-11T09:11:34.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h2><hr><p>图片平均消耗 60% 以上的字节数来打开网页，但“网络中”大多数字节数用于视频。</p><p>在这章中，你将用到 <strong>Google Chrome</strong> 和 <a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="noopener">Chrome开发者工具</a>。</p><p>你可以用 <strong>Chrome开发者工具</strong> 快速得知你的网页在各种设备上的表现。当然，设备模拟器并不能真正代替在实际设备上的体验。为了在手机或平板设备上进行测试，你需要确保已经配置好了远程调试所需的环境。</p><h3 id="比特和像素"><a href="#比特和像素" class="headerlink" title="比特和像素"></a>比特和像素</h3><hr><blockquote><p><strong>Total bits = pixels x bits per pixel</strong></p></blockquote><p>照片等图片文件的大小，取决于 <strong>像素数</strong> 乘以 <strong>存储每个像素所需比特的数量</strong>。因此，为了提高网站性能，你要使用 <strong>尽可能小的图片尺寸</strong> 以及 <strong>尽可能高的图片压缩率</strong>。</p><p><strong>保存图片时的第一条原则是 用尽可能最低的质量和尽可能小的尺寸。不过，你该如何在保持图片质量的同时减少文件大小呢。</strong></p><h3 id="请求和盈利"><a href="#请求和盈利" class="headerlink" title="请求和盈利"></a>请求和盈利</h3><hr><p>更重要的是 平均每个网页发出 <strong>56个</strong> 请求以加载图片；每次请求对页面加载都是一项成本。</p><p>谷歌，亚马逊和其他公司的研究表明，即使是一个非常小的页面加载延误都可能造成明显的流量和经济损失。</p><h3 id="相对大小"><a href="#相对大小" class="headerlink" title="相对大小"></a>相对大小</h3><hr><p>将图片的 <code>max-width</code> 设置为 <strong>100%</strong>，图片会很好的扩大，不过最大也只能放大到它的自然宽度。</p><p>如果想要两张图片（假设图片宽426px）并列对齐，无论视图区域的尺寸如何，该怎么做？简单，调整相对尺寸为50%的宽度。如果想要在两个图片之间加一个 10px 的边距，可以使用 <code>margin-right: 10px;</code> 也可以使用 <code>calc</code>，这是一个结合绝对值和相对值的好办法。比如，将百分比宽度与一个固定的边距组合</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">426px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>((100% - 10px) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="横向和纵向"><a href="#横向和纵向" class="headerlink" title="横向和纵向"></a>横向和纵向</h3><hr><p>对于响应式设计来说，一个黄金法则就是 <strong>不要假设视图区域的尺寸一致保持相同</strong>。</p><p>学习对于不同屏幕方向，如何使用 <strong>media queries</strong></p><h3 id="鲜为人知的CSS单位"><a href="#鲜为人知的CSS单位" class="headerlink" title="鲜为人知的CSS单位"></a>鲜为人知的CSS单位</h3><hr><p>你想要一张图片响应式铺满视图区域的整个高度吗？随意拿一张图片（<strong>宽512px,高384px；屏幕尺寸：800px x 612px</strong>）来测试一下。</p><p>你可能经常设置图片高度为 100%，不过这个只在 HTML 的高度下起作用。而且 body 元素得高度也同样被设置为 100%。</p><p>一个简单方法是使用 <code>VH</code> 单位，是视图高度的缩写。一个VH 单位对应着 1% 的视图高度。因而，100VH 对应着 100% 的高度。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>屏幕上测试图片比例为：<strong>816px x 612px</strong></p></blockquote><p>你可以同样使用 <code>VW</code> 视图宽度，你可以设置图片的宽度为 <code>100VW</code> ，等于 100% 的视图宽度。都是最大的。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>屏幕上测试图片比例为：<strong>800px x 600px</strong></p></blockquote><p>另一个常见的响应式用例是 当你想要调整图片尺寸去适应视图区域较小的高度或宽度，可以使用 <code>vmin</code>单位，对应着 1% 的宽度或高度，使得视图区域最小化。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vmin</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vmin</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>屏幕上测试图片比例为：<strong>612px x 612px</strong></p></blockquote><p>如果你想要一张图片铺满整个视图区域而不需要拉伸或收缩图片的话，可以使用 <code>vmax</code>单位，对应着 1% 的视图区域宽度或高度，都是最大的。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vmax</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vmax</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>屏幕上测试图片比例为：<strong>800px x 800px</strong></p></blockquote><p>是否注意到，将 <code>height</code> 和 <code>width</code> 设置为 <code>100vmax</code> 或 <code>100vmin</code> 会如何改变图片的宽高比？<strong>它会将你的图片压缩成正方形</strong>，所以，如果你想要保留其宽高比，请小心！</p><h3 id="光栅图-Raster-和矢量图-Vector"><a href="#光栅图-Raster-和矢量图-Vector" class="headerlink" title="光栅图(Raster)和矢量图(Vector)"></a>光栅图(Raster)和矢量图(Vector)</h3><hr><p>有两种不同的基础方式去创建和存储图片，以及这会影响你如何响应式地部署图片：<strong>光栅图(Raster)和矢量图(Vector)。</strong></p><p><strong>光栅图</strong> 就是照片以及其他类型的图片以及单独颜色点所组成的网格。可能来源于照相机、扫描仪或者由HTML画布元素创建。</p><p><strong>矢量图</strong> 就是比如商标和线条艺术的图片，可以由一组曲线、直线、形状、填充颜色和渐变所定义的。可以由 Adobe Illustrator 等类型的程序创建 Inkscape 或者 由 <strong>SVG</strong>一类的矢量格式。<strong>SVG</strong> 使得响应式矢量图像运用在网页中成为可能。</p><p>矢量文档格式优于光栅文档格式是浏览器可以渲染各种尺寸的矢量图片。毕竟，矢量图片格式描述了图片的几何形状，是由线条、曲线、颜色等组成，而非单独颜色点组成。矢量图片的缩放不会降低图片质量。</p><p>有一个很好的基本原则提高跨平台的图片性能，就是为相片使用JPEG格式，以及例如 Chrome 的浏览器也同样支持其他格式。例如 <a href="https://developers.google.com/speed/webp/?csw=1" target="_blank" rel="noopener">WebP</a> 是一种可以提供更好的压缩比例和特性的图像格式，支持 alpha 有损动画处理以及无损压缩。</p><p>你可以为矢量图使用 <strong>SVG</strong>。对于 矢量图和纯色图，例如商标以及线条艺术，如果你不能使用 <strong>SVG</strong> 格式就使用 <strong>PNG</strong> 格式。优先选择 <strong>PNG</strong> 而不是 GIF 格式是因为前者有更多颜色，更好的压缩率以及没有版权问题。</p><h3 id="压缩、优化和自动化"><a href="#压缩、优化和自动化" class="headerlink" title="压缩、优化和自动化"></a>压缩、优化和自动化</h3><p>图像通常占据了网页上下载字节的大部分，通常也占据了大量的视觉空间。 因此，优化图像通常可以最大限度地减少从网站下载的字节数以及提高网站性能：浏览器需要下载的字节越少，占用客户端的带宽就越少，浏览器下载并在屏幕上渲染有用内容的速度就越快。</p><p>一个最著名的批量图片处理软件叫 <a href="http://www.imagemagick.org/" target="_blank" rel="noopener">ImageMagick</a>，光栅图和矢量图都可以处理。它是一款免费的开源软件，它将你在平时基于GUI界面的图片处理软件中的操作自动化执行，比如转换图片格式、裁剪或者应用滤镜。对于响应式图片，这意味着 可以自动生成同一幅图片的多种版本，不同尺寸或格式。</p><ul><li><p><a href="http://cactuslab.com/imagemagick/" target="_blank" rel="noopener">Mac 上的一个简单的 ImageMagick 安装包</a></p></li><li><p><a href="http://www.graphicsmagick.org/" target="_blank" rel="noopener">Graphicsmagick</a>(ImageMagick 的一个分叉)</p></li></ul><p>你可以将图片自动优化工具融合进你的工作流：</p><ul><li><p><a href="https://gruntjs.com/getting-started" target="_blank" rel="noopener">Grunt 简介</a></p></li><li><p><a href="http://24ways.org/2013/grunt-is-not-weird-and-hard/" target="_blank" rel="noopener">Grunt 使用入门</a></p></li><li><p><a href="https://addyosmani.com/blog/generate-multi-resolution-images-for-srcset-with-grunt/" target="_blank" rel="noopener">用 Grunt 生成不同分辨率的图片</a></p></li><li><p><a href="https://github.com/andismith/grunt-responsive-images" target="_blank" rel="noopener">用于生成多张图片的 grunt-responsive-images 插件</a></p></li><li><p><a href="https://www.npmjs.com/package/grunt-respimg" target="_blank" rel="noopener">用于响应式图片工作流的 grunt-respimg 插件</a></p></li></ul><p>图片处理工具：</p><ul><li><p><a href="http://imageoptim.com/" target="_blank" rel="noopener">ImageOptim</a>(Mac)</p></li><li><p><a href="https://trimage.org/" target="_blank" rel="noopener">Trimage</a> 和 ImageOptim 类似 (Windows, Mac, Linux)</p></li><li><p><a href="https://github.com/pornel/ImageAlpha" target="_blank" rel="noopener">ImageAlpha</a></p></li><li><p><a href="https://nikkhokkho.sourceforge.io/static.php?page=FileOptimizer" target="_blank" rel="noopener">File Optimizer</a>(Windows, Linux)</p></li></ul><p>我们怎样才能检查网页上的所有图片都被优化了呢？</p><p>现在这有一个很棒的检查图片的工具是 <a href="https://developers.google.com/speed/pagespeed/insights/?url=simpl.info%2Fcssfilters" target="_blank" rel="noopener">PageSpeed Insights</a>。我们可以在开发者工具中使用它。</p><ul><li><a href="https://www.npmjs.com/package/grunt-pagespeed" target="_blank" rel="noopener">Grunt PageSpeed 插件</a></li><li><a href="https://github.com/addyosmani/psi/" target="_blank" rel="noopener">PageSpeed Insights Node module</a></li><li><a href="https://www.thegeekstuff.com/2012/04/curl-examples/" target="_blank" rel="noopener">cURL 示例</a></li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><hr><p>现实中，移动网络的实际情况是 文件请求次数和请求文件的大小同样重要。也就是说，你需要减少请求图片的次数，而不仅仅是图片文件的大小。</p><p>性能是真正响应式设计的基本组成部分。在实践中，这意味着你需要减小文件大小的同时，还要减少请求文件的次数。一种减少图片数据的好办法是压缩图片或者减少图片的数量。</p><p>要减少图片下载次数，你也可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/CSS_Image_Sprites" target="_blank" rel="noopener">CSS 图片精灵</a> 或 <a href="https://pagecrafter.com/responsive-background-image-sprites-css-tutorial/" target="_blank" rel="noopener">响应式精灵</a> 。精灵页 图片组合了大量图片，这些图片可以通过将精灵页设置为元素背景，然后通过 CSS 调整背景位置来单独显示。此技巧对图标和其他重复图形尤为有用。</p><p>无论你采用何种技巧来避免延迟，都请注意 <a href="http://labazhou.net/2015/03/http2-for-front-end-web-developers/" target="_blank" rel="noopener">HTTP/2</a> 带来的变化。</p><p>简单地说，HTTP/2 表示请求多个文件的成本更小：准备停止使用脚本编写、连接和其他 HTTP/1 技巧！</p><h3 id="CSS-背景图片技巧"><a href="#CSS-背景图片技巧" class="headerlink" title="CSS 背景图片技巧"></a>CSS 背景图片技巧</h3><hr><p>图片的尺寸会尽可能的小，但仍然会覆盖整个包含块：<br><code>background-size: cover;</code> cover 属性确保包含块被完全填充，意味着某一个边的边长过长。</p><p>图片的尺寸会尽可能大，并保持在包含块中是完整可见的：<br><code>background-size: contain;</code> contain 属性时，图片会完全被显示出来，意味着某一边长可能会小于包含块的边长</p><h3 id="符号字符"><a href="#符号字符" class="headerlink" title="符号字符"></a>符号字符</h3><hr><p>避免使用图片并保持网站的响应性，如果需要图形标志，例如箭头、星星或者桃心，可以看看有无这样的字符。</p><p><a href="https://unicode-table.com/cn/sets/" target="_blank" rel="noopener">Unicode 字符集</a><br><a href="https://en.wikipedia.org/wiki/List_of_Unicode_characters" target="_blank" rel="noopener">Unicode 符号集合</a></p><p>Unicode 字符真的非常厉害。它包含 110,000 个字符。<br>使用 Unicode 字符时，你需要确保 在 meta 标签中将 charset 属性值设为 utf-8。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta" target="_blank" rel="noopener">更多关于 meta tag charsets 的信息</a></p><p><a href="https://unicode-table.com/cn/" target="_blank" rel="noopener">这是一个 unicode 符号的列表</a></p><p>查看 unicode 字符时遇到问题？很遗憾，并非所有浏览器默认情况下都能查看所有 unicode 字符所需的字体。<a href="http://www.alanwood.net/unicode/#links" target="_blank" rel="noopener">此站点</a>将帮助你确定你的浏览器可以呈现的字符。请参阅<a href="https://gschoppe.com/uncategorized/fixing-unicode-support-in-google-chrome/" target="_blank" rel="noopener">此处的一些建议</a>，了解如何在 Windows 上通过 Chrome 启用 unicode。</p><h3 id="图标字体"><a href="#图标字体" class="headerlink" title="图标字体"></a>图标字体</h3><hr><p>图标字体相比于图片有很多优点。它们是矢量的图形，可以被无限的缩放，并且整套图像可以以一种字体被下载，这使得它成为一种非常有潜力的响应式设计解决方案。它只需要最小的下载量而能达到最大的可伸缩性。</p><ul><li><p><a href="http://zocial.smcllns.com/" target="_blank" rel="noopener">Zocial</a></p></li><li><p><a href="https://fontawesome.com/?from=io" target="_blank" rel="noopener">Font Awesome</a></p></li><li><p><a href="http://weloveiconfonts.com/" target="_blank" rel="noopener">We Love Icon Fonts!</a></p></li><li><p><a href="https://css-tricks.com/examples/IconFont/" target="_blank" rel="noopener">Icon fonts on CSS-Tricks</a></p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"http://weloveiconfonts.com/api/?family=zocial"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"zocial-facebook"</span>&gt;</span>Facebook<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"zocial-twitter"</span>&gt;</span>Twitter<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"zocial-googleplus"</span>&gt;</span>Google+<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"zocial-digg"</span>&gt;</span>Digg<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[class*="zocial-"]</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'zocial'</span>, sans-serif;</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">3px</span> <span class="number">3px</span> <span class="number">3px</span> <span class="number">#aaa</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SVG-和数据-URI-内嵌图片"><a href="#SVG-和数据-URI-内嵌图片" class="headerlink" title="SVG 和数据 URI 内嵌图片"></a>SVG 和数据 URI 内嵌图片</h3><hr><p>说到文本，如果你真的想要减少网页的文件请求数量，那你可以利用代码实现内嵌图片。有两种方式可以做到，就是 <strong>SVG</strong> 或者 <strong>DataURIs</strong>。</p><p>内嵌 <strong>SVG</strong> 具有非常好的手机和电脑<a href="https://caniuse.com/#feat=svg-html5" target="_blank" rel="noopener">浏览器支持</a>，并且<a href="http://petercollingridge.appspot.com/svg-optimiser" target="_blank" rel="noopener">优化工具</a>可以极大的减少 <strong>SVG</strong> 的字节。</p><p><strong>DataURIs</strong> 提供了一种将文件 例如图片 内嵌为一个 <strong>base64</strong> 编码的字符串，使用格式如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"data:image/svg+xml;base64,[data]"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和 <strong>SVG</strong>一样 <strong>DataURIs</strong>也有很好的手机和电脑<a href="https://caniuse.com/#feat=datauri" target="_blank" rel="noopener">浏览器支持</a>。</p><p>但是 <strong>DataURIs</strong> 和 <strong>SVG</strong> 还可以内嵌在 CSS 里，手机和电脑都支持。</p><h2 id="一些不同的技巧，用来处理网页的图片"><a href="#一些不同的技巧，用来处理网页的图片" class="headerlink" title="一些不同的技巧，用来处理网页的图片"></a>一些不同的技巧，用来处理网页的图片</h2><hr><ul><li>利用 <strong>外部文件</strong> 然后把它们链接到你的 HTML <code>&lt;img src=&quot;file.png&quot;&gt;</code></li><li>或者可以使用 <strong>内嵌图片</strong> 将你需要的所有图片数据都放在你的网页中 <code>&lt;img src=&quot;data:image/png;base64.....&quot;&gt;</code></li><li>可以利用 <strong>光栅图片</strong></li><li>可以用 <strong>矢量图片</strong></li><li>将图片打包然后用类似 <strong>font awesome</strong> 的 <strong>图标字体</strong> <code>&lt;i class=&quot;fa fa-adjust&quot;&gt;&lt;/i&gt;</code> 然后利用css技术为它们添加效果</li></ul><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><hr><blockquote><p>当你在 开发一个手机应用来展示随时会变化的商品，你需要一张 <strong>星星图片</strong> 放在右上角，你希望这个图片能够在应用中自由缩放以分别适应手机及电脑客户端的显示，所以，你应该选择 <strong>矢量图片</strong> 还是 <strong>光栅图片</strong>？ 是 <strong>内嵌图标</strong> 还是 <strong>外部文件链接</strong>？</p></blockquote><p><strong>答案：</strong> 矢量图片  <strong>内嵌图标</strong> 或者 <strong>外部文件链接</strong> 都可以。站在 <strong>内嵌图标</strong> 的角度，星星是一个非常简单的图形，很容易创建出它的 SVG 文件，并且内嵌它们并不会增加太多字节；如果需要重复利用这张图片，链接外部文件也有道理，这意味着可以缓存图片，当用户每查看新一个网页时也不用再次加载它。</p><blockquote><p>开发一个可以自行发布图片日记的手机网站，也就是说图片都是单次利用的。用户会创建一些独有的网页来发布单张图片并佐以说明文字，你应该把它们转化为 <strong>矢量图</strong> 还是 <strong>仅仅保留格式为 .jpg 的图片</strong>呢？是 <strong>内嵌图片</strong> 还是 设置它们的 <strong>src</strong> 属性来链接外部文件呢？</p></blockquote><p><strong>答案：</strong> 首先，用户的图片应该仍然被保留为 jpeg 格式，这些图片本来就是光栅图，所以还是以光栅图的形式保存它们。</p><p>考虑到你的用户是手机上访问网站，实际上内嵌图片是个不错的想法，如果你可以做到的话。内嵌图片可以减少浏览器的请求次数，而文件请求是造成手机访问延迟和网页加载不全的重要原因之一。文件请求会增加往返通讯，而往返通讯是手机网页加载缓慢的最重要因素之一。但是内嵌图片会限制你的响应式网站，这个下面会讲到，所以最终，外部文件链接依然可以是一种选择。</p><blockquote><p>开发一个公司网站，公司希望它的 logo 出现在任何一个页面的左上角，很有可能他们还希望一个更大版本的公司logo能出现在搜索引擎的着陆页面，通常来说，用户可以通过手机或者电脑的任何一种来访问，所以你应该使用logo的 <strong>矢量图片</strong> 还是 <strong>光栅图片</strong>？ 是 <strong>内嵌logo图片</strong> 还是 设置它的 <strong>src</strong> 外部文件链接呢？</p></blockquote><p><strong>答案：</strong> 第一个问题是 应该使用 矢量图，首先，这个logo 非常简单，因为它是基于文本的，所以将其装换为矢量图不会太困难，其次，你希望它有一大一小两个版本，矢量图可伸缩性很好。所以 logo 的大小版本可以使用同一个源文件。</p><p>第二个问题，我觉得应该选择外部文件链接，这样它可以被用于多个页面，浏览器可以将它缓存。</p><blockquote><p>你在创建一个叫做 vicarious concerts 的 <strong>移动网页应用</strong>，用来比较任意观众为音乐会录制的视频，每个视频的加载都需要几秒钟的时间，你决定显示一个旋转的光碟图标，在视频加载时，出现在视频的位置，你应该用这个光碟图标的 <strong>gif动画</strong> 还是 <strong>svg 动图</strong> 呢？是应该 <strong>内嵌</strong> 这个旋转动画呢？还是 设置它的 <strong>src</strong> 外部文件链接呢？</p></blockquote><p><strong>答案：</strong> 第一个问题是 应该使用 <strong>svg 动图</strong>；首先，矢量图形更好因为它们可以被无限伸缩而不像 gif 是光栅图形；其次，svg 文件实际上要比 gif 文件小，因为你用的是同一张图片，只是生成了它的旋转动画，而不是播放许多张光碟的图片来表示它在旋转时每个时刻的样子。</p><p>第二个问题，选择外部文件链接就很合理，因为多个视频都使用同一个旋转光碟的图标，让浏览器缓存动画再应用到各个页面非常合理。</p><h2 id="image-的-srcset-属性"><a href="#image-的-srcset-属性" class="headerlink" title="image 的 srcset 属性"></a>image 的 srcset 属性</h2><hr><p>srcset 有两种自定义方式，<strong>一种使用 x 来区分设备像素比 (DPR)</strong>，<strong>另一种使用 w 来描述图像的宽度。</strong></p><p><strong>对设备像素比的反应</strong>:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image_2x.jpg"</span> <span class="attr">srcset</span>=<span class="string">"image_2x.jpg 2x, image_1x.jpg 1x"</span> <span class="attr">alt</span>=<span class="string">"a cool image"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将 <strong>srcset</strong> 设置为与逗号分隔的一连串 filename multiplier 对相等，其中每个 multiplier乘数 必须是后跟 x 的整数。</p><p>例如，1x 表示 1 倍显示屏，2x 表示像素密度为两倍的显示屏，如 Apple 的 Retina 显示屏。</p><p>浏览器会下载与其 DPR 对应的最佳图片。</p><p>另请注意，有一个作为备用的 src 属性。</p><p><strong>对图片宽度的反应</strong>:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image_200.jpg"</span> <span class="attr">srcset</span>=<span class="string">"image_200.jpg 200w, image_100.jpg 100w"</span> <span class="attr">alt</span>=<span class="string">"a cool image"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将 <strong>srcset</strong> 设置为与逗号分隔的一连串 <strong>filename widthDescriptor</strong> 对相等，其中每个 <strong>widthDescriptor宽度描述符</strong> 都以像素为测量单位， 并且必须是后跟 <strong>w</strong> 的整数。在这里，<strong>widthDescriptor宽度描述符</strong> 指定每个图片文件的自然宽度，使浏览器能够根据窗口大小和 DPR 选择要请求的最适当的图片。 （如果有 <strong>widthDescriptor宽度描述符</strong>，浏览器下载图片才能知道其宽度！）</p><p>另请注意，有一个作为备用的 src 属性。</p><p><strong>包含大小的图片宽度</strong><br>如果图片不以全窗口宽度显示会怎样？那么，除了 <strong>srcset</strong> 外，你还需要其他元素（假设图片将为全窗口宽度）</p><p>向包含媒体查询的图片添加一个 <strong>sizes</strong> 属性和一个 vw 值。<strong>srcset</strong> 和 <strong>sizes</strong> 合起来可让浏览器知道图片的自然宽度以及图片相对于窗口宽度的显示宽度。 知道图片的显示宽度和可用图片文件的宽度后，浏览器将获得下载具有满足其需求的适当分辨率且尽可能小的图片所需的信息。 而且，浏览器在页面加载初期，解析 HTML 时即可做出此选择。</p><p><strong>srcset 与 sizes 配合使用的语法</strong><br>示例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"w"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"images/great_pic_800.jpg"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">sizes</span>=<span class="string">"(max-width: 400px) 100vw, (min-width: 401px) 50vw"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">srcset</span>=<span class="string">"images/great_pic_400.jpg 400w, images/great_pic_800.jpg 800w"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">alt</span>=<span class="string">"great picture"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在本示例中，如果浏览器的窗口宽度等于或小于 400 像素，浏览器知道图片将为全窗口宽度；如果窗口宽度大于 400 像素，则为一半窗口宽度。浏览器知道它具有两个图片选项 - 一个具有 400 像素的自然宽度，另一个具有 800 像素。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"w"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"images/Coffee_1280w.jpg"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">srcset</span>=<span class="string">"images/Coffee_1280w.jpg 1280w, images/Coffee_640w.jpg 640w"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">sizes</span>=<span class="string">"(max-width: 960px) 50vw, 100vw"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">alt</span>=<span class="string">"Coffee by Amy March from Turkey"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在本示例中，浏览器知道它可以选择使用Coffee_1280w.jpg 和Coffee_640w.jpg，宽度分别为1280px和640px。如果页面宽度为960px或更小，浏览器图像将以一半窗口宽度 50vw显示，否则图像将显示为全窗口宽度 100vw。</p><p>我没有在 sizes 中包括第二个媒体查询，因为如果没有媒体查询，列出的宽度会被视为默认值。</p><p>另外请注意，sizes 中的媒体查询与 CSS 匹配。说明一下，更改 sizes 不会影响 CSS。它只会提醒浏览器注意最终需要在该处显示的图片。</p><p><strong>sizes</strong> 由以逗号分隔的 mediaQuery width 对组成。<strong>sizes</strong> 会在加载流程初期告诉浏览器，该图片会在点击 mediaQuery 时以某个 width 显示。</p><p>实际上，如果 <strong>sizes</strong> 缺失，浏览器会将 <strong>sizes</strong> 默认为 100vw，表示它预计图片将以全窗口宽度显示。</p><p><strong>sizes</strong> 会为浏览器额外提供一条信息，以确保它根据图片的最终显示宽度下载正确的图片文件。说明一下，它实际上不会调整图片的大小 - 这是 CSS 的工作。</p><p><a href="http://scottjehl.github.io/picturefill/" target="_blank" rel="noopener">Picture polyfill</a></p><p><a href="http://responsiveimages.org/" target="_blank" rel="noopener">响应式图片社区</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr><p>通过这节，你已经学会图片并不总是必要的，利用 css 和 图标字体来替代传统图片给响应式设计提供了高性能的解决方案。</p><h3 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h3><p>要求：</p><ul><li>首先，找到笑脸标志，这是个PNG 图片，把它替换成 Unicode 字符</li><li>博客怎能没有社交链接，利用 zocial 在页面底部添加一些社交媒体链接</li><li>看到底部那张诡异的装饰图了吗？是个 PNG 图片，它显然非常的不合时宜，所以请将它替换成一个更合理的内容</li><li>你可以添加一个响应式 logo，尽情发挥你的灵感</li><li>利用 picture 元素提供不同尺寸的图片基于不同的视窗宽度</li><li>利用 source 属性设置不同的图片基于设备的像素比</li><li>并为所有图片添加合适的 alt 属性</li></ul><p><a href="https://github.com/doraeige/tests/tree/master/blog/start" target="_blank" rel="noopener">项目链接</a></p><p><a href="https://github.com/doraeige/tests/tree/master/blog/solution" target="_blank" rel="noopener">项目参考答案</a></p><h3 id="延展"><a href="#延展" class="headerlink" title="延展"></a>延展</h3><ul><li><p><a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="noopener">Chrome 开发者工具概览</a></p></li><li><p><a href="https://news.ycombinator.com/item?id=273900" target="_blank" rel="noopener">页面加载时间每延迟 100 毫秒，Amazon 的利润就会降低 1%</a></p></li><li><p><a href="https://httparchive.org/reports/state-of-the-web#bytesImg&amp;reqImg" target="_blank" rel="noopener">HTTP 存档</a>：一般来说，网页会对图片发出 56 次请求</p></li><li><p><a href="https://litmus.com/blog/png-gif-or-jpeg-which-ones-should-you-use-in-email" target="_blank" rel="noopener">PNG，GIF 还是 JPEG？哪个是电子邮件的最佳图像格式？</a></p></li><li><p><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/image-optimization" target="_blank" rel="noopener">图片优化</a></p></li><li><p><a href="https://github.com/BBC-News/Imager.js/" target="_blank" rel="noopener">Imager.js</a>:为 BBC 新闻开发的响应式图片加载</p></li><li><p><a href="https://www.linuxjournal.com/content/tech-tip-really-simple-http-server-python" target="_blank" rel="noopener">简单的 HTTP 服务器</a></p></li><li><p><a href="https://upload.wikimedia.org/wikipedia/commons/6/6c/Trajans-Column-lower-animated.svg" target="_blank" rel="noopener">Trajan 的 Column SVG 例子</a></p></li><li><p><a href="https://www.creativebloq.com/design/examples-svg-7112785" target="_blank" rel="noopener">20 个让你惊艳不已的 SVG 例子</a></p></li><li><p><a href="https://codepen.io/chrisgannon/" target="_blank" rel="noopener">SVG 动画示例</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;响应式图片&quot;&gt;&lt;a href=&quot;#响应式图片&quot; class=&quot;headerlink&quot; title=&quot;响应式图片&quot;&gt;&lt;/a&gt;响应式图片&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;图片平均消耗 60% 以上的字节数来打开网页，但“网络中”大多数字节数用于视频。&lt;/p&gt;
&lt;p&gt;在这章中，
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="响应式" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>响应式设计(四)</title>
    <link href="http://yoursite.com/2018/05/05/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1-%E5%9B%9B/"/>
    <id>http://yoursite.com/2018/05/05/响应式设计-四/</id>
    <published>2018-05-05T07:26:39.000Z</published>
    <updated>2019-03-07T06:55:56.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><hr><p>一图胜千言，而且图片是每个网站的重要组成部分。</p><p>每个页面的 HTTP 文档大约有 <code>1.2MB</code> 的图片。这意味着图片占据每个网页的 65% 的体积。</p><p>设计响应式网页时，我们需要把图片考虑进去。</p><p><a href="https://developers.google.cn/web/fundamentals/design-and-ux/responsive/images" target="_blank" rel="noopener">自适应网页设计</a></p><p>其余时候，图像也许需要更大幅度的修改：更改比例、裁剪甚至更换整个图像。 在这种情况下，更改图像通常称作艺术指导</p><p><a href="https://responsiveimages.org/demos/variable-width/index.html" target="_blank" rel="noopener">实例</a></p><p>下一节，具体说明 <strong>响应式图片</strong> 处理。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><hr><p>表格有很多花样，如果表格的列超过一定数量，那么它很有可能会溢出视窗。小屏幕会从产生水平滚动条。这里有三种方式可以解决：</p><ul><li>隐藏某些列</li><li>取消表格样式</li><li>封闭表格，例如转折点</li></ul><h3 id="隐藏某些列"><a href="#隐藏某些列" class="headerlink" title="隐藏某些列"></a>隐藏某些列</h3><hr><p>当视窗尺寸缩小时，隐藏纵列实质上是根据它们的重要性来进行的。让我们来看看一个棒球计分板的做法：</p><p><a href="http://htmlpreview.github.io/?https://github.com/doraeige/tests/blob/master/table/index.html" target="_blank" rel="noopener">Demo</a></p><p>在这个例子，从小屏幕开始，什么信息最重要？<strong>短队名</strong> 和 <strong>最终得分</strong>，使用不显示的属性来隐藏所有其他东西。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.longName</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inning</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后随着视窗尺寸变大，显示出长队名，接着开始显示每局的得分。隐藏纵列最大的问题是你在向用户隐瞒内容，如果我需要知道狄启菊有多少得分怎么办？如果我用一个狭窄屏幕的设备，它就不见了，所以使用这些技术的时候要注意，如果可能，请使用 <strong>缩写</strong> 而不是完全隐藏它。</p><h3 id="取消表格样式"><a href="#取消表格样式" class="headerlink" title="取消表格样式"></a>取消表格样式</h3><hr><p>用这种方式，当视窗宽度小于一定值的时候，表格会瓦解重组成长列表，与数据表很不同，这种技术的好处是所有的数据，都是可见的，不管视窗的尺寸是多大。让我们看一下案例。</p><p><a href="http://htmlpreview.github.io/?https://github.com/doraeige/tests/blob/master/table/index2.html" target="_blank" rel="noopener">Demo</a></p><p>当视窗变小时，表格瓦解。每个纵列实际上变成独立一行，表头在旁边。使用 <strong>媒体查询</strong> 我需要告诉表格 当视窗小于一定宽度，这里是500px，我不想让它表现得像一个表格，所以强制 所有的表格、表头元素、表格主体执行块级显示。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">500px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">table</span>, <span class="selector-tag">thead</span>, <span class="selector-tag">tbody</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span>, <span class="selector-tag">tr</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 移除thead 里的tr */</span></span><br><span class="line">    <span class="selector-tag">thead</span> <span class="selector-tag">tr</span> &#123;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">top</span>: -<span class="number">9999px</span>;</span><br><span class="line">        <span class="attribute">left</span>: -<span class="number">9999px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">td</span> &#123; </span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">padding-left</span>: <span class="number">50%</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">td</span><span class="selector-pseudo">:before</span> &#123; </span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">6px</span>;</span><br><span class="line">        <span class="attribute">content</span>: <span class="built_in">attr</span>(data-th);</span><br><span class="line">        <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">td</span><span class="selector-pseudo">:first-of-type</span> &#123;</span><br><span class="line">        <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>值得注意的是，我可以设置不显示 <code>thead tr</code>，但是那会对使用屏幕阅读器的人引起可访问性问题，因为浏览器不会告诉它们表格标题，相反，我将内容置于屏幕之外。</p></blockquote><blockquote><p>为了添加行的标签，使用前置伪选择器 <code>td:before</code>，我用 <code>content: attr(data-th)</code> 来设置使得 <code>data-th</code> 的值应用到每个 <code>td</code> 元素。</p></blockquote><h3 id="表格内滚动"><a href="#表格内滚动" class="headerlink" title="表格内滚动"></a>表格内滚动</h3><hr><p>为了把表格放在视窗里，其中一个你可以做的最简单的事情，就是把它放在一个 <code>div</code> 里面，然后设置宽度为 <code>100%</code>，接着设置 <code>overflow-x:auto</code>；然后，与其溢出视窗，表格会占据同样的宽度。但是可以用滚动条在视窗里拉动。</p><p><a href="http://htmlpreview.github.io/?https://github.com/doraeige/tests/blob/master/table/index3.html" target="_blank" rel="noopener">Demo</a></p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><hr><p>在网页上大约每行 <strong>65</strong> 个字符是最普遍的。我们设计的时候要考虑用户的阅读方式，因为它会影响我们的布局，这就是为什么行的长度是你建立网站时的重要参考因素，也是在选择断点时经常拿来参考的。</p><p>使字体足够大以适应不同设备的阅读效果是很重要的。我总是把基本字体设置为至少 <strong>16像素</strong>，行高至少有 <strong>1.2em</strong>。根据情况，可能会在文本很多网站增加更多行高。</p><h3 id="增加次要断点"><a href="#增加次要断点" class="headerlink" title="增加次要断点"></a>增加次要断点</h3><hr><p>在主要断点之间调整元素的外边距和内边距是可能有帮助的，或者给一些内容增加字号，会更容易阅读，而且在布局上会感到更自然。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这一篇主要描述了响应式设计的几个优化点。下一篇，具体说明 <strong>响应式图片</strong> 处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图片&quot;&gt;&lt;a href=&quot;#图片&quot; class=&quot;headerlink&quot; title=&quot;图片&quot;&gt;&lt;/a&gt;图片&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;一图胜千言，而且图片是每个网站的重要组成部分。&lt;/p&gt;
&lt;p&gt;每个页面的 HTTP 文档大约有 &lt;code&gt;1.2MB&lt;/code
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="响应式" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>响应式设计(三)</title>
    <link href="http://yoursite.com/2018/05/04/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1-%E4%B8%89/"/>
    <id>http://yoursite.com/2018/05/04/响应式设计-三/</id>
    <published>2018-05-04T02:39:45.000Z</published>
    <updated>2019-03-05T10:05:02.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="响应模式"><a href="#响应模式" class="headerlink" title="响应模式"></a>响应模式</h2><hr><p>响应模式的变化是快的，但是也有一些确定的模式，能在几乎任何设备上都有不错的表现。</p><p>响应式网页布局可以大致分为四种模式：</p><ul><li>大体流动模型(Mostly Fluid)</li><li>掉落列模型(Column Drop)</li><li>活动布局模型(Layout Shifter)</li><li>画布溢出模型(Off Canvas)</li></ul><p>有时，一个网页同时结合几种模式，例如 掉落列和画布溢出模型。以下部分将会讲解每种模式是怎样工作的，然后你就可以运用所学的 <code>flexbox</code> 和 <code>媒体查询</code> 技术来实现它们了。</p><h2 id="掉落列模型-Column-Drop"><a href="#掉落列模型-Column-Drop" class="headerlink" title="掉落列模型(Column Drop)"></a>掉落列模型(Column Drop)</h2><hr><p><strong>掉落列模型(Column Drop)</strong> 可能是最简单的。</p><p><img src="/images/css5.png" alt="掉落列模型"></p><p>在视窗最窄的时候，每个元素都纵向堆放，一个接着一个；当视窗变宽，元素也随之延展，直至到达第一个断点；在第一个断点，所有元素不再竖直堆放，而是前两个元素并排显示，第三个元素在它们下面，这些元素会继续随着视窗而延展，直至到达下一个断点，接着，它们会重排成一个三列布局，通常，当视窗到达最大宽度，列也到达最大宽度，然后它们便不再随视窗而延展，而是在两侧添加外边距。</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><hr><h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>从最小的视图开始，我们现在有三个 <code>div</code> 标签，包含在一个 <code>container</code> 标签里</p><p><img src="/images/css6.png" alt="掉落列模型"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box dark_blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box light_blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box green"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加相应的 <code>css</code> 属性，将所有的元素宽度设为 <code>100%</code>:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h4><p>因为这是个例子，我就随机的将断点设为 <code>450px</code>。</p><p><img src="/images/css11.png" alt="掉落列模型"></p><p>我想让这个 <strong>深蓝的div</strong> 占据视窗宽度的 <strong>25%</strong>，这个 <strong>浅蓝色的div</strong> 占据 <strong>75%</strong>，然后我将 <strong>绿色的div</strong> 占据整个视窗。</p><p>为了实现这些，我需要添加一个新的 <strong>媒体查询</strong> 来检查，视窗宽度是否大于等于 <code>450px</code>，然后将 <strong>深蓝的div</strong> 的宽度 设为 <strong>25%</strong>，<strong>浅蓝色的div</strong> 的宽度 设为 <strong>75%</strong>。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">450px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.dark_blue</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.light_blue</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">75%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h4><p>在 <code>550px</code> 处添加第二个断点，然后让 <strong>深蓝的div</strong> 为 <strong>25%</strong>，<strong>浅蓝色的div</strong> 为 <strong>50%</strong>， <strong>绿色的div</strong> 为 <strong>25%</strong>，为了实现这些，我需要添加一个新的 <strong>媒体查询</strong>。</p><p><img src="/images/css12.png" alt="掉落列模型"></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">550px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.dark_blue</span>, <span class="selector-class">.green</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.light_blue</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成！可以在浏览器中查看效果。</p><h2 id="大体流动模型-Mostly-Fluid"><a href="#大体流动模型-Mostly-Fluid" class="headerlink" title="大体流动模型(Mostly Fluid)"></a>大体流动模型(Mostly Fluid)</h2><hr><p><strong>大体流动模型(Mostly Fluid)</strong> 与 <strong>掉落列模型(Column Drop)</strong> 非常相似，但是它更像网格系统。它有更多的列，而且列的响应方式也不想她，这要取决于视窗宽度。</p><p><img src="/images/css7.png" alt="大体流动模型"></p><p>在视窗宽度最窄时，与 <strong>掉落列模型(Column Drop)</strong> 一样，为竖直堆放布局；但是随着视窗变宽，网格模型开始出现，最终，当视窗宽度到达最大宽度，两边会出现外边距，而内容不再延展。</p><h3 id="如何实现-1"><a href="#如何实现-1" class="headerlink" title="如何实现"></a>如何实现</h3><hr><h4 id="第一阶段-1"><a href="#第一阶段-1" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>我把这个网页做的复杂一点，加了几个 <code>div</code>。</p><p><img src="/images/css8.png" alt="大体流动模型"></p><p>从最小的视图开始，我们现在有五个 <code>div</code> 标签，包含在一个 <code>container</code> 标签里</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box dark_blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box light_blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box green"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box orange"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>与 <strong>掉落列模型(Column Drop)</strong> 一样，我需要用 <code>flexbox</code>，并在最窄视窗时，将所有的元素宽度设为 <code>100%</code>:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二阶段-1"><a href="#第二阶段-1" class="headerlink" title="第二阶段"></a>第二阶段</h4><p>在第一个断点，我将 <strong>浅蓝色的div</strong> 和 <strong>绿色的div</strong> 宽度设为 <strong>50%</strong>，和之前一样，我要加上最小宽度检测，确保视窗宽度大于 <code>450px</code>：</p><p><img src="/images/css9.png" alt="大体流动模型"></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">450px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.light_blue</span>, <span class="selector-class">.green</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三阶段-1"><a href="#第三阶段-1" class="headerlink" title="第三阶段"></a>第三阶段</h4><p>在 <code>550px</code>设置另一个断点，添加 <strong>媒体查询</strong> 语句，并为每个元素设置相应的宽度：</p><p><img src="/images/css10.png" alt="大体流动模型"></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">550px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.dark_blue</span>, <span class="selector-class">.light_blue</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.green</span>, <span class="selector-class">.red</span>, <span class="selector-class">.orange</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">33.333333%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h4><p>最后，再设一个断点来添加两边的外边距，当视窗宽度大于 <code>700px</code> 时：</p><p><img src="/images/css13.png" alt="大体流动模型"></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">700px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.container</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">700px</span>;</span><br><span class="line">        <span class="attribute">margin-left</span>: auto;</span><br><span class="line">        <span class="attribute">margin-right</span>: auto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太棒了，你可以在浏览器上查看成果。</p><h2 id="活动布局模型-Layout-Shifter"><a href="#活动布局模型-Layout-Shifter" class="headerlink" title="活动布局模型(Layout Shifter)"></a>活动布局模型(Layout Shifter)</h2><hr><p><strong>活动布局模型</strong> 应该是最灵活的响应式模型了。</p><p><img src="/images/css14.png" alt="活动布局模型"></p><p>它有很多适用于不同设备的断点，但最关键的是它的布局变化方式，并不是单纯的重排到其他列的下方；<code>flexbox</code> 的亮点在这才真正凹显，因为我们可以利用 <code>CSS</code>顺序属性，这很了不起，因为这样一来，每个布局可变化的地方太多，这就需要更多的计划来维持。</p><h3 id="如何实现-2"><a href="#如何实现-2" class="headerlink" title="如何实现"></a>如何实现</h3><hr><h4 id="第一阶段-2"><a href="#第一阶段-2" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>这一回我做的页面，要稍微复杂一些：</p><p><img src="/images/css15.png" alt="活动布局模型"></p><p>为了实现我想要的布局，我将 <strong>浅蓝 div</strong> 和 <strong>绿色 div</strong> 都打包进 <strong>id</strong> 为 <strong>container2</strong> 的这个 <strong>div</strong> 里:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box dark_blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span> <span class="attr">id</span>=<span class="string">"container2"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box light_blue"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box green"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我还对 <strong>container</strong> 这个类做了一些小改动，将它的宽度设为了 <strong>100%</strong>，所以它包含的元素也占据全部宽度，当没有触发任何断点时，应用的默认样式使所有元素都占据100%宽度，竖直堆放在一起:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二阶段-2"><a href="#第二阶段-2" class="headerlink" title="第二阶段"></a>第二阶段</h4><p>当在 <code>500px</code> 触发第一个媒体查询时，断点的设置让 <code>深蓝色</code> 和 <code>container2</code> 的宽度都变为 <code>50%</code>，<code>红色的 div</code> 依然宽 <code>100%</code>，因为我们没有修改它的属性。</p><p><img src="/images/css16.png" alt="活动布局模型"></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">500px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.dark_blue</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-id">#container2</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三阶段-2"><a href="#第三阶段-2" class="headerlink" title="第三阶段"></a>第三阶段</h4><p>当在 <code>600px</code> 触发第二个媒体查询时，事情就开始变得很有意思了。</p><p><img src="/images/css17.png" alt="活动布局模型"></p><p>为了让所有元素就位，我需要将 <code>container2</code> 的宽度设为 <code>50%</code>， 并将 <code>深蓝色块</code> 和 <code>红色块</code> 的宽度都设为 <code>25%</code>，接着，为了改变显示顺序，我需要为每个元素指定次序数，如果我将 <code>红色 div</code> 的次序设为 _-1_，他将会在第一个出现，为了让深蓝色元素在最后一个显示，我需要将它的次序数大于 <strong>0</strong>， 所以我设为 <strong>1</strong>：</p><blockquote><p>记住 每个元素的默认次序数是 <strong>0</strong></p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.dark_blue</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">        <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-id">#container2</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.red</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">        <span class="attribute">order</span>: -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们在浏览器上看看效果，是不是很棒呢！</p><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><hr><blockquote><p>如图所示，在为红色、绿色和深蓝色的元素中，哪个 div 相对应哪个元素？ 在下方的文本框里，请写出它们对应的 id。你的选项分别是 boxA、boxB 和 boxC.</p></blockquote><p><img src="/images/css18.png" alt="活动布局模型"></p><p><strong>答案：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Red Box (红色框） -----  boxA</span><br><span class="line">Green Box ( 绿色框）-----  boxC</span><br><span class="line">Dark Blue Box ( 深蓝色框 ) ----- boxB</span><br></pre></td></tr></table></figure></p><h2 id="画布溢出模型-Off-Canvas"><a href="#画布溢出模型-Off-Canvas" class="headerlink" title="画布溢出模型(Off Canvas)"></a>画布溢出模型(Off Canvas)</h2><hr><p>在画布溢出模型中，内容并不是竖直堆放的。</p><p><img src="/images/css19.png" alt="画布溢出模型"></p><p>而是将不常用的内容，比如 <strong>导航栏</strong> 或者 <strong>应用菜单</strong> 放在屏幕以外，只有当屏幕足够大的时候，才显示出来。在小尺寸屏幕上，溢出画布的内容通常会在用户点击菜单按钮时出现。</p><p>溢出画布的内容，可能的确是从屏幕之外进入屏幕。在这个示例中，内容是从画面左侧进入的。但在其他案例中，它也可以从右侧进入。</p><h3 id="如何实现-3"><a href="#如何实现-3" class="headerlink" title="如何实现"></a>如何实现</h3><hr><h4 id="第一阶段-3"><a href="#第一阶段-3" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>这里有两个元素，<strong>深蓝色</strong>的 <code>nav</code> 元素 和 <strong>浅蓝色</strong>的 <code>main</code> 元素。</p><p><img src="/images/css20.png" alt="画布溢出模型"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">id</span>=<span class="string">"drawer"</span> <span class="attr">class</span>=<span class="string">"dark_blue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>关闭画布<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>单击抽屉外的区域关闭<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">"light_blue"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 24 24"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M2 6h20v3H2zm0 5h20v3H2zm0 5h20v3H2z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>单击菜单图标打开抽屉<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了确保元素占据整个视窗宽度，我需要将 <code>html、body、main</code> 元素的宽度都设为 <code>100%</code>：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我要为 <code>nav</code> 元素设置添加 <strong>画布溢出样式</strong>，指定宽度时要小心，以防止元素占满视窗宽度。我要将 <code>translate</code>属性 值设为 <code>-300px</code>，来将它移出屏幕，然后添加 <code>transition</code> 属性值为 0.3秒，使动画平滑过渡，当我想让它出现时，我要添加 <code>open</code> 类并重设 <code>transform</code> 值。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="comment">/* 该变换将菜单移出画布. */</span></span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(-300px, 0);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-300px, 0);</span><br><span class="line">    <span class="comment">/* 我们还可以为菜单添加过渡动画。 */</span></span><br><span class="line">    <span class="attribute">transition</span>: transform <span class="number">0.3s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span><span class="selector-class">.open</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(0, 0);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二阶段-3"><a href="#第二阶段-3" class="headerlink" title="第二阶段"></a>第二阶段</h4><p>现在，在 <code>600px</code> 添加一个断点，让所有元素都回到原来的位置，在 <code>600px</code> 的 <strong>媒体查询</strong> 中重设 <code>transform</code> 值，将 <code>main</code> 元素的 <code>flex-grow</code> 属性设为1，来使元素能够伸缩至占据余下的视窗宽度。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">nav</span> &#123;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translate</span>(0, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">flex-flow</span>: row nowrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">main</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: auto;</span><br><span class="line">        <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是用于切换 <code>open</code> 类的 JavaScript：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">menu.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    drawer.classList.toggle(<span class="string">'open'</span>);</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>源码：</strong><br><a href="http://htmlpreview.github.io/?https://github.com/doraeige/tests/blob/master/off-canvas/pattern-off-canvas.html" target="_blank" rel="noopener">画布溢出模型</a><br>让我们在浏览器上看看效果，是不是很棒呢！</p><h3 id="小练习-1"><a href="#小练习-1" class="headerlink" title="小练习"></a>小练习</h3><hr><p>使用以下的 CSS 来明确这组图，以便准确地展现 nav 在屏幕中的呈现形式。 这个 open 类，会在点击后应用。</p><blockquote><p>下面的四幅图里的哪一个表示的是点击后的结果呢？这几幅图中，灰色方框代表视窗， 蓝紫色块代表弹出菜单， 请选择一幅最能体现这段 CSS 代码运行结果的图。</p></blockquote><p><img src="/images/css21.png" alt="画布溢出模型"></p><p><strong>答案：</strong> 第一幅图</p><h2 id="综合Demo"><a href="#综合Demo" class="headerlink" title="综合Demo"></a>综合Demo</h2><p><a href="http://htmlpreview.github.io/?https://github.com/doraeige/tests/blob/master/responsive/index.html" target="_blank" rel="noopener">响应式页面</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr><p>这篇中，你已经学到了 四个常见的响应式设计模式。下一部分，你将学习一些更高级的技巧来让你的网页出类拔萃。</p><h3 id="延展"><a href="#延展" class="headerlink" title="延展"></a>延展</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Examples#Example_5:_Event_Propagation" target="_blank" rel="noopener">e.stopPropagation()</a>的作用是什么</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;响应模式&quot;&gt;&lt;a href=&quot;#响应模式&quot; class=&quot;headerlink&quot; title=&quot;响应模式&quot;&gt;&lt;/a&gt;响应模式&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;响应模式的变化是快的，但是也有一些确定的模式，能在几乎任何设备上都有不错的表现。&lt;/p&gt;
&lt;p&gt;响应式网页布局可以
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="响应式" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>响应式设计(二)</title>
    <link href="http://yoursite.com/2018/05/03/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1-%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/05/03/响应式设计-二/</id>
    <published>2018-05-03T06:22:40.000Z</published>
    <updated>2019-03-05T10:05:05.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><hr><p>响应式网页会基于设备的特征而变化。也就是说，你的响应式网页，需要在不同的设备上应用不同的样式。有几种办法可以有选择性的应用CSS代码，最简单的是 使用 <strong>媒体查询</strong>。</p><p><strong>媒体查询</strong> 提供了简单的逻辑方法，来根据不同的设备特征应用不同的样式，比如设备的宽度、高度或者像素比。你可以修改所有内容，从背景图片到页面布局，甚至其他的任何东西。</p><p>添加响应式样式很简单，在需要在你的页面里添加另外的样式表，并附上 <strong>媒体查询</strong> :</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"screen and (min-width:300px)"</span> <span class="attr">href</span>=<span class="string">"patterns.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* patterns.css */</span></span><br><span class="line"><span class="comment">/* 屏幕宽带 大于300px 时应用下面这个样式 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除了利用样式表链接的媒体查询属性，还有两种方式可以应用媒体查询，你可以在 <code>@media</code> 标签嵌入 或者在 <code>@import</code> 标签嵌入</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">500px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(<span class="string">"patterns.css"</span>) only screen and (min-width: <span class="number">500px</span>);</span><br></pre></td></tr></table></figure><blockquote><p>因为性能原因，你应该绝对避免使用 <code>@import</code>; 它是一个代价和优先级都非常高的标签</p></blockquote><p>你需要权衡 CSS链接 和 <code>@media</code> 的代价:</p><ul><li>如果使用 CSS链接，你会有很多小文件，但是很多 HTTP 请求</li><li>如果使用 <code>@media</code>，HTTP 请求 会少一些，但是文件都会变大</li></ul><p>响应式网页设计中，最常用的媒体查询变量是 <code>min-width</code> 和 <code>max-width</code>；<code>max-width</code> 的规则是在视窗宽度小于其赋值时生效。<code>min-width</code>的规则是在视窗宽度大于其赋值时生效。</p><p>你还可以创建基于 <code>min-device-width</code> 或者 <code>max-device-width</code> 的媒体查询，但是这十分不推荐，它们的区别很细微，但却很重要。</p><p><code>min-width</code> 是基于浏览器窗口大小的；<code>min-device-width</code> 是基于屏幕大小的；额外添加 <code>device-width</code> 变量可以防止在电脑或其他桌面设备上的网页内容 随窗口大小 而变化，因为这样的媒体查询是基于真实设备的尺寸的，而非浏览器窗口；另外一个原因是 一些浏览器 比如 Legacy 安卓浏览器可能返回错误的设备值。</p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><hr><blockquote><p>页面改变布局的那个点叫断点</p></blockquote><h3 id="要在哪设置断点？"><a href="#要在哪设置断点？" class="headerlink" title="要在哪设置断点？"></a>要在哪设置断点？</h3><blockquote><p>根据你的内容来设置断点</p></blockquote><p>一开始设置断点时，先在电脑浏览器上将窗口尺寸设置到最小，顺便打开 Chrome 的开发者工具，因为当改变窗口时，它会在右上角显示当前窗口的分辨率。接下来慢慢拉大窗口，仔细观察内容，看它什么时候需要断点</p><h2 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Basic_Concepts_of_Grid_Layout" target="_blank" rel="noopener">网格布局的基本概念</a></p><p>动态网格系统中，有一些动态调整的纵列，当窗口变小时，它们会自动顺延到下一行，有很多不错的范例可供使用，比如 <code>Bootstrap</code> 或者 <code>960px 网格布局系统</code>，它们都非常易于使用，并且已经为你做好了一切准备工作。</p><h2 id="弹性框-–-Flexbox"><a href="#弹性框-–-Flexbox" class="headerlink" title="弹性框 – Flexbox"></a>弹性框 – Flexbox</h2><p><code>Flexbox</code> 是最好用的布局工具之一。</p><p>之所以功能强大，是因为它能够自动填充空白区域。如果一个元素周围出现了空白，它会自动填补上，而如果空间变得拥挤，它会缩小，直至占据最小空间</p><h3 id="怎样用-Flexbox-实现设计？"><a href="#怎样用-Flexbox-实现设计？" class="headerlink" title="怎样用 Flexbox 实现设计？"></a>怎样用 Flexbox 实现设计？</h3><ul><li><p><code>display: flex</code><br>  flex 的默认堆放方式为 横向堆放；默认情况下 flex 项目会自动填充在一行内，所以无论将元素的宽度设为多少，它们都不会换行。相反，浏览器将其大小适应在视窗内，要改变这些，可以为元素添加 <code>flex-wrap:wrap</code> 语句，这是在告诉浏览器，可以允许内部的元素换行。</p></li><li><p><code>flexbox</code> 另外一个很有用的特性，是 <strong>能够改变元素的次序，利用 CSS  order 属性</strong>。比如以下 5个div 在浏览器窗口宽度大于 700px 时会根据 order 属性从小到大的顺序排列</p></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">700px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.dark_blue</span> &#123; <span class="attribute">order</span>: <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="selector-class">.light_blue</span> &#123; <span class="attribute">order</span>: <span class="number">5</span>; &#125;</span><br><span class="line">    <span class="selector-class">.green</span> &#123; <span class="attribute">order</span>: <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="selector-class">.orange</span> &#123; <span class="attribute">order</span>: <span class="number">3</span>; &#125;</span><br><span class="line">    <span class="selector-class">.red</span> &#123; <span class="attribute">order</span>: <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><hr><blockquote><p>看以下图片，从左图设置成右图的布局</p></blockquote><p><img src="/images/css1.png" alt="flex"></p><p><strong>答案：</strong><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &#123; <span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">order</span>:<span class="number">1</span>; &#125;</span><br><span class="line"><span class="selector-class">.red</span> &#123; <span class="attribute">width</span>: <span class="number">50%</span>; <span class="attribute">order</span>: <span class="number">2</span>; &#125;</span><br><span class="line"><span class="selector-class">.orange</span> &#123; <span class="attribute">width</span>: <span class="number">50%</span>; <span class="attribute">order</span>: <span class="number">3</span>; &#125;</span><br><span class="line"><span class="selector-tag">footer</span> &#123; <span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">order</span>:<span class="number">4</span> &#125;</span><br><span class="line"><span class="selector-class">.light_blue</span> &#123; <span class="attribute">width</span>: <span class="number">20%</span>; <span class="attribute">order</span>: <span class="number">5</span>; &#125;</span><br><span class="line"><span class="selector-class">.dark_blue</span> &#123; <span class="attribute">width</span>: <span class="number">60%</span>; <span class="attribute">order</span>: <span class="number">6</span>; &#125;</span><br><span class="line"><span class="selector-class">.green</span> &#123; <span class="attribute">width</span>: <span class="number">20%</span>; <span class="attribute">order</span>: <span class="number">7</span>; &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>请为图片上你看到所有不同颜色的元素，写出它们的宽度和和每个元素在这个布局中所需要的次序。Width (宽度） Order （次序）</p></blockquote><p><img src="/images/css2.png" alt="flex"></p><p><strong>参考答案：</strong></p><p><img src="/images/css3.png" alt="flex"></p><p>或者：</p><p><img src="/images/css4.png" alt="flex"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>flexbox</code> 和 <strong>动态网格</strong> 看起来都是响应式设计中很棒的通用策略。</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><p><a href="http://zh.learnlayout.com/" target="_blank" rel="noopener">学习CSS布局</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;媒体查询&quot;&gt;&lt;a href=&quot;#媒体查询&quot; class=&quot;headerlink&quot; title=&quot;媒体查询&quot;&gt;&lt;/a&gt;媒体查询&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;响应式网页会基于设备的特征而变化。也就是说，你的响应式网页，需要在不同的设备上应用不同的样式。有几种办法可以有选择
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="响应式" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>响应式设计(一)</title>
    <link href="http://yoursite.com/2018/05/02/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1-%E4%B8%80/"/>
    <id>http://yoursite.com/2018/05/02/响应式设计-一/</id>
    <published>2018-05-02T07:43:44.000Z</published>
    <updated>2019-03-05T10:04:59.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视窗"><a href="#视窗" class="headerlink" title="视窗"></a>视窗</h2><hr><blockquote><p>视窗是指浏览器能够显示内容的区域。</p></blockquote><p>举个例子，在我的电脑上，我把浏览器窗口设置为 <strong>800px</strong> 宽，这让我的可视部分也为 <strong>800px</strong> 宽。如果我拉宽显示窗口，可视部分的宽度也随之变化。</p><p>Chromebook 显示器的像素是 宽度 <strong>2560px</strong>, 高度为 <strong>1700px</strong>；但是当我把浏览器全屏显示，然后查看显示窗口宽度的话，他显示的宽度只有 <strong>1280px</strong>。</p><blockquote><p>为什么显示的宽度不是 <strong>2560px</strong> 呢？</p></blockquote><p>浏览器并不是根据 <strong>物理硬件的像素宽度(Hardware Pixels,这里指 2560px)</strong> 而工作的，而是根据 <strong>DIPs(Device Independent Pixels)宽度</strong>，也就是 设备独立像素值。</p><p>一如其名，<strong>DIP</strong> 是一种计量单位，它将像素值与实际距离联系起来，同一 <strong>DIP</strong> 值表示的是 屏幕上同样大小的空间，而不论显示器的像素密度是多少。</p><p>所以说，如果物理硬件的实际像素值 是 浏览器像素的两倍的话，那么 Chromebook 的像素比就是 <strong>2</strong>；</p><p>所以，浏览器视图的宽度是 <strong>1280</strong> dips， <strong>1280</strong> dips 在实际显示的时候，其实是被硬件扩展到了 <strong>2560</strong> 的硬件像素宽度。</p><blockquote><p>如果没有设定视图端口，浏览器会怎么做呢？</p></blockquote><p>除非你告诉浏览器，你的网页会在更小的屏幕上显示，否则它不会知道。</p><blockquote><p>以 <strong>Nexus 5</strong> 手机为例，<strong>1080px</strong> hw pixels 物理硬件的像素宽度, 像素比 <strong>deviec pixel radio: 3</strong>，既是 <strong>360 dips</strong></p></blockquote><p>在渲染网页的时候，如果它原本是显示在宽 980 DIPs 的屏幕上的，能够放在一个宽度仅有 <strong>360 DIPs</strong> 的手机屏幕，被压缩了一半还多，显示的效果如下图所见：</p><p><img src="/images/viewport.png" alt="viewport"></p><p>然后它为了让内容看上去好一些，会开启字体改善机制，浏览器会试图挑出页面上的首要内容，并把他们放大。也就是说有的字体会变大，易于阅读，但是其他字体还是会一样小，非常难看清。用户必须花好多时间放大屏幕，才能看清或者与内容互动。</p><p><img src="/images/viewport2.png" alt="viewport2"></p><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3><hr><blockquote><p>假设你在查看一个手机屏幕技术规格，其分辨率是 <strong>1920 * 1080 px</strong>， 这里的像素是指以下哪一种像素呢？</p></blockquote><ul><li>DIPs （设备独立像素）</li><li>硬件像素</li><li>CSS 像素</li></ul><p><strong>参考答案：</strong> 硬件像素</p><blockquote><p>以下四个图中，哪个图能代表像素比为 <strong>2</strong> 的设备呢？<br>要知道，像素比是一维数字比，请从一维空间思考。</p></blockquote><p><img src="/images/viewport3.png" alt="viewport3"></p><p><strong>参考答案：</strong> 右边第一幅图  </p><blockquote><p>为什么同样的文字会在两个分辨率相同的屏幕上表现不同呢？</p></blockquote><p><img src="/images/viewport5.png" alt="viewport5"></p><ul><li>CSS 样式没有按预设渲染</li><li>两个设备的像素比不同</li><li><code>&lt;meta&gt;</code> 的 <code>initial- scale</code> 导致在不同设备上缩放比例不一致</li><li>没有设置好视图端口</li></ul><p><strong>参考答案：</strong> 两个设备的像素比不同、没有设置好视图端口</p><blockquote><p>计算 CSS 像素<br>已知一个屏幕的分辨率是 <strong>1920 ＊ 1080px</strong>，像素比为 2，那么它横屏放置时，最大视窗宽度是多少 CSS 像素呢？</p></blockquote><p><strong>参考答案：</strong> <strong>960pixels</strong>  1920/2 = 960</p><blockquote><p>计算视窗宽度:请计算以下这四个设备的视窗宽度 (dips)</p></blockquote><p><img src="/images/viewport6.png" alt="viewport6"></p><p><strong>参考答案：</strong></p><p><img src="/images/viewport7.png" alt="viewport7"></p><p>第二个答案，有时候设备的制造商会模糊处理一些数字，所以任何接近 <strong>300</strong> 的数字都可以。<br>第四个注意：笔记本屏幕的总宽度是大于浏览器宽度的，但是这个视窗只跟浏览器有关，与整个屏幕宽度无关，所以它只是 <strong>800px</strong>。</p><h2 id="设置窗口"><a href="#设置窗口" class="headerlink" title="设置窗口"></a>设置窗口</h2><hr><blockquote><p>为 head 元素添加 viewport 标签</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以让浏览器知道我们的意图，我们需要在视窗值后面设置页面宽度，来指导页面针对具体设备进行宽度调整，这使页面内容可以匹配不同屏幕尺寸，不论在较小的手机还是笔记本上；</li><li>添加初始缩放比例属性<code>initial-scale</code>，并赋值为1，告诉浏览器相对像素与CSS像素的比例是一比一。</li><li>CSS 像素值曾经是我们调整最多的属性，也是唯一需要担心的，如果不把初始缩放比例设为1的话，有的浏览器会在切换到横屏模式时，依旧保持之前的页面宽度；而且它们还会使内容进行缩放，而无法自动调整布局</li></ul><h2 id="元素的最大宽度"><a href="#元素的最大宽度" class="headerlink" title="元素的最大宽度"></a>元素的最大宽度</h2><hr><blockquote><p>内容需要适应视窗宽度，这样才能避免左右滚动</p></blockquote><p>在定义元素宽度时，应采用 <strong>相对宽度</strong>，来防止元素溢出视窗。</p><blockquote><p>CSS 是允许内容溢出其容器的，所以如果你没有定义边长，当某一元素，例如图片，其尺寸大于其容器时，它就会溢出。你完全可以避免这一困扰，只需要将最大宽度设为 100%。</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，我推荐你添加一个多类选择器，将 image、embed、object、video元素的属性一次性都设好。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>,<span class="selector-tag">embed</span>,</span><br><span class="line"><span class="selector-tag">object</span>, <span class="selector-tag">video</span>&#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小练习-1"><a href="#小练习-1" class="headerlink" title="小练习"></a>小练习</h3><hr><blockquote><p>以下选项中，哪段代码是响应式的？请选出所有适用项。</p></blockquote><p><img src="/images/viewport8.png" alt="viewport8"></p><p><strong>答案：</strong></p><p><img src="/images/viewport9.png" alt="viewport9"></p><blockquote><p>因为 125px 比任何设备都小得多，所以它符合响应式要求；350px 在一些小的设备视窗宽度可能低至320px的来说会溢出。</p></blockquote><h2 id="触控目标"><a href="#触控目标" class="headerlink" title="触控目标"></a>触控目标</h2><blockquote><p>敲击目标，也就是任何用户可能会点击或者输入的控件，都应该足够大，以便于触击，还要留足空隙，以避免不小心同时按到两个按钮。如果是鼠标，用户可以精准的点击，而如果用我们的手指，操作的精确度会很糟糕。</p></blockquote><blockquote><p>我们的手指大约有 10mm宽，也就是半英尺，差不多就等于40 CSS像素，与其把按钮尺寸设为 <strong>40*40px</strong>，你更应该把按钮尺寸设为 <strong>48*48px</strong>。这样确保元素之间有足够的距离，但是，请确保任何两个敲击目标之间 至少有 <strong>40px</strong> 的距离，这样能防止用户同时点击到两个按钮，或者完全看不到按钮。</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span>, <span class="selector-tag">a</span>, <span class="selector-tag">button</span>&#123;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">48px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">48px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="响应式页面的概念和过程"><a href="#响应式页面的概念和过程" class="headerlink" title="响应式页面的概念和过程"></a>响应式页面的概念和过程</h3><p>设计响应式网页的概念和过程，和非响应式是一样的，除了不只是画一种宽度的设计稿，而是要多画几种来适应不同屏幕尺寸。</p><p>我的设计是从最小的屏幕开始做起，通常是手机设备，做完一个，我会接着做下一个更大一点的，当所有的设计都完成，我会问我自己，还需要为更宽的屏幕做设计吗？有时候，真的不需要做更宽的设计了。</p><blockquote><p>从最小的屏幕做起，我就必须优先考虑什么是对用户最重要的，什么事情是用户最想做的，或者什么是用户最希望在屏幕上看到的。</p></blockquote><blockquote><p>如果是从最大的屏幕开始设计，一些重要的信息很可能会被轻易删掉，相反，明确内容的优先级，然后最小到大的实际，最重要的内容永远都会留在页面上，用户也能得到最完整的体验，无论使用什么样的设备。</p></blockquote><blockquote><p>比如一个硬件商店的设计，优先考虑的信息是商店的地址，营业时间和联系方式。把这些信息放在页面的顶部可以让我更好的看到。</p></blockquote><p>除了从小到大的设计，我的代码编写也是从小到大的，这样我就能知道主要风格和布局是否能兼容任何设备，甚至是古老的不支持媒体查询浏览器，但是我最喜欢的理由是性能，如果从小的视图开始设计，我必须一开始就去思考性能的问题，我需要有意识的去做一些决定，来确定内容优先级以及要为用户提供多少信息。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr><p>本篇，你已经学习了响应式设计的各个部分，比如，视图端口、元素尺寸以及触控目标</p><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><hr><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Mobile/Viewport_meta_tag" target="_blank" rel="noopener">在移动浏览器中使用viewport元标签控制布局</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;视窗&quot;&gt;&lt;a href=&quot;#视窗&quot; class=&quot;headerlink&quot; title=&quot;视窗&quot;&gt;&lt;/a&gt;视窗&lt;/h2&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;视窗是指浏览器能够显示内容的区域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个例子，在我的电脑上，我
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="响应式" scheme="http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>程序猿必备英语单词</title>
    <link href="http://yoursite.com/2018/04/02/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%BF%85%E5%A4%87%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"/>
    <id>http://yoursite.com/2018/04/02/程序猿必备英语单词/</id>
    <published>2018-04-01T16:15:58.000Z</published>
    <updated>2019-03-05T10:10:51.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><hr><p>abstract 抽象的<br>abstract base class (ABC)抽象基类<br>abstract class 抽象类<br>abstraction 抽象、抽象物、抽象性<br>access 存取、访问<br>access function 访问函数<br>access level访问级别<br>account 账户<br>action 动作<br>activate 激活<br>active 活动的<br>actual parameter 实参<br>adapter 适配器<br>add-in 插件<br>address 地址<br>address space 地址空间<br>ADO(ActiveX Data Object)ActiveX数据对象<br>advanced 高级的<br>aggregation 聚合、聚集<br>algorithm 算法<br>alias 别名<br>align 排列、对齐<br>allocate 分配、配置<br>allocator分配器、配置器<br>angle bracket 尖括号<br>annotation 注解、评注<br>API (Application Programming Interface) 应用(程序)编程接口<br>appearance 外观<br>append 附加<br>application 应用、应用程序<br>application framework 应用程序框架<br>Approximate String Matching 模糊匹配<br>architecture 架构、体系结构<br>archive file 归档文件、存档文件<br>argument参数。<br>array 数组<br>arrow operator 箭头操作符<br>assert(ion) 断言<br>assign 赋值<br>assignment 赋值、分配<br>assignment operator 赋值操作符<br>associated 相关的、相关联的<br>asynchronous 异步的<br>attribute 特性、属性<br>authentication service 验证服务<br>authorization 授权</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><hr><p>background 背景、后台(进程)<br>backup 备份<br>backup device备份设备<br>backup file 备份文件<br>backward compatible 向后兼容、向下兼容<br>base class 基类<br>base type 基类型<br>batch 批处理<br>BCL (base class library)基类库<br>Bin Packing 装箱问题<br>binary 二进制<br>binding 绑定<br>bit 位<br>bitmap 位图<br>block 块、区块、语句块<br>boolean 布林值(真假值，true或false)<br>border 边框<br>bounds checking 边界检查<br>boxing 装箱、装箱转换<br>brace (curly brace) 大括号、花括号<br>bracket (square brakcet) 中括号、方括号<br>breakpoint 断点<br>browser applications 浏览器应用(程序)<br>browser-accessible application 可经由浏览器访问的应用程序<br>bug 缺陷错误<br>build 编连(专指编译和连接)<br>built-in 内建、内置<br>bus 总线<br>business 业务、商务(看场合)<br>business Logic 业务逻辑<br>business rules 业务规则<br>buttons 按钮<br>by/through 通过<br>byte 位元组(由8 bits组成)</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><hr><p>cache 高速缓存<br>calendar 日历<br>Calendrical Calculations 日期<br>call 调用<br>call operator 调用操作符<br>callback 回调<br>candidate key 候选键 (for database)<br>cascading delete 级联删除 (for database)<br>cascading update 级联更新 (for database)<br>casting 转型、造型转换<br>catalog 目录<br>chain 链(function calls)<br>character 字符<br>character format 字符格式<br>character set 字符集<br>check box 复选框<br>check button 复选按钮<br>CHECK constraints CHECK约束 (for database)<br>checkpoint 检查点 (for database)<br>child class 子类<br>CIL (common intermediate language)通用中间语言、通用中介语言<br>class 类<br>class declaration 类声明<br>class definition 类定义<br>class derivation list 类继承列表<br>class factory 类厂<br>class hierarchy 类层次结构<br>class library 类库<br>class loader 类装载器<br>class template 类模板<br>class template partial specializations 类模板部分特化<br>class template specializations 类模板特化<br>classification 分类<br>clause 子句<br>cleanup 清理、清除<br>CLI (Common Language Infrastructure) 通用语言基础设施<br>client 客户、客户端<br>client application 客户端应用程序<br>client area 客户区<br>client cursor 客户端游标 (for database)<br>client-server 客户机/服务器、客户端/服务器<br>clipboard 剪贴板<br>clone 克隆<br>CLS (common language specification) 通用语言规范<br>code access security 代码访问安全<br>code page 代码页<br>COFF (Common Object File Format) 通用对象文件格式<br>collection 集合<br>COM (Component Object Model) 组件对象模型<br>combo box 组合框<br>command line 命令行<br>comment 注释<br>commit 提交 (for database)<br>communication 通讯<br>compatible 兼容<br>compile time 编译期、编译时<br>compiler 编译器<br>component组件<br>composite index 复合索引、组合索引 (for database)<br>composite key 复合键、组合键 (for database)<br>composition 复合、组合<br>concept 概念<br>concrete具体的<br>concrete class 具体类<br>concurrency 并发、并发机制<br>configuration 配置、组态<br>Connected Components 连通分支<br>connection 连接 (for database)<br>connection pooling 连接池<br>console 控制台<br>constant 常量<br>Constrained and Unconstrained Optimization 最值问题<br>constraint 约束 (for database)<br>construct 构件、成分、概念、构造（for language）<br>constructor (ctor) 构造函数、构造器<br>container 容器<br>containment包容<br>context 环境、上下文<br>control 控件<br>cookie<br>copy 拷贝<br>CORBA 通用对象请求中介架构(Common Object Request Broker Architecture)<br>cover 覆盖、涵盖<br>create/creation 创建、生成<br>crosstab query 交叉表查询 (for database)<br>Cryptography 密码<br>CTS (common type system)通用类型系统<br>cube 多维数据集 (for database)<br>cursor 光标<br>cursor 游标 (for database)<br>custom 定制、自定义</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><hr><p>data 数据<br>data connection 数据连接 (for database)<br>data dictionary 数据字典 (for database)<br>data file 数据文件 (for database)<br>data integrity 数据完整性 (for database)<br>data manipulation language (DML)数据操作语言(DML) (for database)<br>data member 数据成员、成员变量<br>data source 数据源 (for database)<br>Data source name (DSN) 数据源名称(DSN) (for database)<br>data structure数据结构<br>Data Structures 基本数据结构<br>data table 数据表 (for database)<br>data-bound 数据绑定 (for database)<br>database 数据库 (for database)<br>database catalog 数据库目录 (for database)<br>database diagram 数据关系图 (for database)<br>database file 数据库文件 (for database)<br>database object 数据库对象 (for database)<br>database owner 数据库所有者 (for database)<br>database project 数据库工程 (for database)<br>database role 数据库角色 (for database)<br>database schema 数据库模式、数据库架构 (for database)<br>database script 数据库脚本 (for database)<br>datagram 数据报文<br>dataset 数据集 (for database)<br>dataset 数据集 (for database)<br>DBMS (database management system)数据库管理系统 (for database)<br>DCOM (distributed COM)分布式COM<br>dead lock 死锁 (for database)<br>deallocate 归还<br>debug 调试<br>debugger 调试器<br>decay 退化<br>declaration 声明<br>default 缺省、默认值<br>DEFAULT constraint默认约束 (for database)<br>default database 默认数据库 (for database)<br>default instance 默认实例 (for database)<br>default result set 默认结果集 (for database)<br>defer 推迟<br>definition 定义<br>delegate 委托<br>delegation 委托<br>deploy 部署<br>derived class 派生类<br>design pattern 设计模式<br>destroy 销毁<br>destructor(dtor)析构函数、析构器<br>device 设备<br>DHTML (dynamic HyperText Markup Language)动态超文本标记语言<br>dialog 对话框<br>Dictionaries 字典<br>digest 摘要<br>digital 数字的<br>directive (编译)指示符<br>directory 目录<br>disassembler 反汇编器<br>DISCO (Discovery of Web Services)Web Services的查找<br>dispatch 调度、分派、派发<br>distributed computing 分布式计算<br>distributed query 分布式查询 (for database)<br>DNA (Distributed interNet Application) 分布式网间应用程序<br>document 文档<br>DOM (Document Object Model)文档对象模型<br>dot operator (圆)点操作符<br>double-byte character set (DBCS)双字节字符集(DBCS)<br>driver 驱动(程序)<br>DTD (document type definition) 文档类型定义<br>dump 转储<br>dump file 转储文件</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><hr><p>e-business 电子商务<br>efficiency 效率<br>efficient 高效<br>encapsulation 封装<br>end user 最终用户<br>end-to-end authentication 端对端身份验证<br>engine 引擎<br>entity 实体<br>enum (enumeration) 枚举<br>enumerators 枚举成员、枚举器<br>equal 相等<br>equality 相等性<br>equality operator 等号操作符<br>error log 错误日志 (for database)<br>escape character 转义符、转义字符<br>escape code 转义码<br>evaluate 评估<br>event 事件<br>event driven 事件驱动的<br>event handler 事件处理器<br>evidence 证据<br>exception 异常<br>exception declaration 异常声明<br>exception handling 异常处理、异常处理机制<br>exception specification 异常规范<br>exception-safe 异常安全的<br>exit 退出<br>explicit 显式<br>explicit specialization 显式特化<br>explicit transaction 显式事务 (for database)<br>export 导出<br>expression 表达式</p><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><hr><p>fat client 胖客户端<br>feature 特性、特征<br>fetch 提取<br>field 字段 (for database)<br>field 字段(java)<br>field length 字段长度 (for database)<br>file 文件<br>filter 筛选 (for database)<br>finalization 终结<br>finalizer 终结器<br>firewall 防火墙<br>flag 标记<br>flash memory 闪存<br>flush 刷新<br>font 字体<br>foreign key (FK) 外键(FK) (for database)<br>form 窗体<br>formal parameter 形参<br>forward declaration 前置声明<br>forward-only 只向前的<br>forward-only cursor 只向前游标 (for database)<br>framework 框架<br>full specialization 完全特化<br>function 函数<br>function call operator (即operator ()) 函数调用操作符<br>function object 函数对象<br>function template函数模板<br>functionality 功能<br>functor 仿函数</p><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><hr><p>GC (Garbage collection) 垃圾回收(机制)、垃圾收集(机制)<br>generate 生成<br>generic 泛化的、一般化的、通用的<br>generic algorithm通用算法<br>genericity 泛型<br>getter (相对于 setter)取值函数<br>global 全局的<br>global object 全局对象<br>grant 授权 (for database)<br>group 组、群<br>group box 分组框<br>GUI 图形界面<br>GUID (Globally Unique Identifier) 全球唯一标识符</p><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><hr><p>handle 句柄<br>handler 处理器<br>hard disk 硬盘<br>hard-coded 硬编码的<br>hard-copy 截屏图<br>hardware 硬件<br>hash table 散列表、哈希表<br>header file头文件<br>heap 堆<br>help file 帮助文件<br>hierarchical data 阶层式数据、层次式数据<br>hierarchy 层次结构、继承体系<br>high level 高阶、高层<br>hook 钩子<br>Host (application)宿主(应用程序)<br>hot key 热键<br>HTML (HyperText Markup Language) 超文本标记语言<br>HTTP (HyperText Transfer Protocol) 超文本传输协议<br>HTTP pipeline HTTP管道<br>hyperlink 超链接</p><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><hr><p>icon 图标<br>IDE (Integrated Development Environment)集成开发环境<br>identifier 标识符<br>IDL (Interface Definition Language) 接口定义语言<br>idle time 空闲时间<br>if and only if当且仅当<br>IL (Intermediate Language) 中间语言、中介语言<br>image 图象<br>IME 输入法<br>immediate base 直接基类<br>immediate derived 直接派生类<br>immediate updating 即时更新 (for database)<br>implement 实现<br>implementation 实现、实现品<br>implicit 隐式<br>implicit transaction隐式事务 (for database)<br>import 导入<br>incremental update 增量更新 (for database)<br>Independent Set 独立集<br>index 索引 (for database)<br>infinite loop 无限循环<br>infinite recursive 无限递归<br>information 信息<br>inheritance 继承、继承机制<br>initialization 初始化<br>initialization list 初始化列表、初始值列表<br>initialize 初始化<br>inline 内联<br>inline expansion 内联展开<br>inner join 内联接 (for database)<br>instance 实例<br>instantiated 具现化、实体化(常应用于template)<br>instantiation 具现体、具现化实体(常应用于template)<br>integrate 集成、整合<br>integrity 完整性、一致性<br>integrity constraint完整性约束 (for database)<br>interacts 交互<br>interface 接口<br>interoperability 互操作性、互操作能力<br>interpreter 解释器<br>introspection 自省<br>invariants 不变性<br>invoke 调用<br>isolation level 隔离级别 (for database)<br>item 项、条款、项目<br>iterate 迭代<br>iteration 迭代(回圈每次轮回称为一个iteration)<br>iterative 反复的、迭代的<br>iterator 迭代器</p><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><hr><p>JIT compilation JIT编译即时编译<br>Job Scheduling 工程安排</p><h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><hr><p>key 键 (for database)<br>key column 键列 (for database)</p><h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><hr><p>left outer join 左向外联接 (for database)<br>level 阶、层例<br>library 库<br>lifetime 生命期、寿命<br>Linear Programming 线性规划<br>link 连接、链接<br>linkage 连接、链接<br>linker 连接器、链接器<br>list 列表、表、链表<br>list box 列表框<br>literal constant 字面常数<br>livelock 活锁 (for database)<br>load 装载、加载<br>load balancing 负载平衡<br>loader 装载器、载入器<br>local 局部的<br>local object 局部对象<br>lock 锁<br>log 日志<br>login 登录<br>login security mode登录安全模式 (for database)<br>lookup table 查找表 (for database)<br>loop 循环<br>loose coupling 松散耦合<br>lvalue 左值</p><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><hr><p>machine code 机器码、机器代码<br>macro 宏<br>maintain 维护<br>managed code 受控代码、托管代码<br>Managed Extensions 受控扩充件、托管扩展<br>managed object 受控对象、托管对象<br>manifest 清单<br>many-to-many relationship 多对多关系 (for database)<br>many-to-one relationship 多对一关系 (for database)<br>marshal 列集<br>Matching 匹配<br>member 成员<br>member access operator 成员取用运算子(有dot和arrow两种)<br>member function 成员函数<br>member initialization list成员初始值列表<br>memory 内存<br>memory leak 内存泄漏<br>menu 菜单<br>message 消息<br>message based 基于消息的<br>message loop 消息环<br>message queuing消息队列<br>metadata 元数据<br>metaprogramming元编程<br>method 方法<br>micro 微<br>middle tier 中间层<br>middleware 中间件<br>modeling 建模<br>modeling language 建模语言<br>modem 调制解调器<br>modifier 修饰字、修饰符<br>module 模块<br>most derived class最底层的派生类<br>mouse 鼠标<br>multi-tasking 多任务<br>multi-thread 多线程<br>multicast delegate 组播委托、多点委托<br>multithreaded server application 多线程服务器应用程序<br>multiuser 多用户<br>mutable 可变的<br>mutex 互斥元、互斥体</p><h2 id="N"><a href="#N" class="headerlink" title="N"></a>N</h2><hr><p>named parameter 命名参数<br>named pipe 命名管道<br>namespace 名字空间、命名空间<br>native 原生的、本地的<br>native code 本地码、本机码<br>nested class 嵌套类<br>nested query 嵌套查询 (for database)<br>nested table 嵌套表 (for database)<br>network 网络<br>network card 网卡<br>Network Flow 网络流</p><h2 id="O"><a href="#O" class="headerlink" title="O"></a>O</h2><hr><p>object 对象<br>object based 基于对象的<br>object model 对象模型<br>object oriented 面向对象的<br>ODBC data source ODBC数据源 (for database)<br>ODBC driver ODBC驱动程序 (for database)<br>one-to-many relationship 一对多关系 (for database)<br>one-to-one relationship 一对一关系 (for database)<br>operating system (OS) 操作系统<br>operation 操作<br>operator 操作符、运算符<br>option 选项<br>outer join 外联接 (for database)<br>overflow 上限溢位(相对于underflow)<br>overload 重载<br>override 覆写、重载、重新定义</p><h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><hr><p>package 包<br>packaging 打包<br>palette 调色板<br>parallel 并行<br>parameter 参数、形式参数、形参<br>parameter list 参数列表<br>parameterize 参数化<br>parent class 父类<br>parentheses 圆括弧、圆括号<br>parse 解析<br>parser 解析器<br>part 零件、部件<br>partial specialization 局部特化<br>pass by reference 引用传递<br>pass by value 值传递<br>pattern 模式<br>persistence 持久性<br>pixel 像素<br>placeholder 占位符<br>platform 平台<br>Point Location 位置查询<br>pointer 指针<br>polymorphism 多态<br>pooling 池化<br>pop up 弹出式<br>port 端口<br>postfix 后缀<br>precedence 优先序(通常用于运算子的优先执行次序)<br>prefix 前缀<br>preprocessor 预处理器<br>primary key (PK)主键(PK) (for database)<br>primary table 主表 (for database)<br>primitive type 原始类型<br>print 打印<br>printer 打印机<br>procedure 过程<br>process 进程<br>program 程序<br>programmer 程序员<br>programming编程、程序设计<br>progress bar 进度指示器<br>project 项目、工程<br>property 属性<br>protocol 协议<br>pseudo code伪码</p><h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><hr><p>qualified 合格的<br>qualifier 修饰符<br>quality 质量<br>queue 队列</p><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><hr><p>radio button 单选按钮<br>random number 随机数<br>Random Number Generation 随机数生成<br>range 范围、区间<br>rank 等级<br>raw 未经处理的<br>re-direction 重定向<br>readOnly只读<br>record 记录 (for database)<br>recordset 记录集 (for database<br>recursion —— 递归<br>recursive 递归<br>refactoring 重构<br>refer 引用、参考<br>reference 引用、参考<br>reflection 反射<br>refresh data 刷新数据 (for database)<br>register 寄存器<br>regular expression 正则表达式<br>relational database 关系数据库<br>remote 远程<br>remote request 远程请求<br>represent 表述，表现<br>resolution 解析过程<br>resolve 解析、决议<br>result set 结果集 (for database)<br>retrieve data 检索数据<br>return 返回<br>return type 返回类型<br>return value 返回值<br>revoke 撤销<br>right outer join 右向外联接 (for database)<br>robust 健壮<br>robustness 健壮性<br>roll back 回滚 (for database)<br>roll forward 前滚 (for database)<br>routine 例程<br>row 行 (for database)<br>rowset 行集 (for database)<br>RPC (remote procedure call)RPC(远程过程调用)<br>runtime 执行期、运行期、执行时、运行时<br>rvalue 右值</p><h2 id="S"><a href="#S" class="headerlink" title="S"></a>S</h2><hr><p>Satisfiability 可满足性<br>save 保存<br>savepoint 保存点 (for database)<br>SAX (Simple API for XML)<br>scalable 可伸缩的、可扩展的<br>schedule 调度<br>scheduler 调度程序<br>schema 模式、纲目结构<br>scope 作用域、生存空间<br>screen 屏幕<br>scroll bar滚动条<br>SDK (Software Development Kit)软件开发包<br>sealed class 密封类<br>search 查找<br>Searching 查找<br>semantics 语义<br>sequential container序列式容器<br>serial 串行<br>serialization/serialize 序列化<br>server 服务器、服务端<br>session 会话 (for database)<br>Set and String Problems 集合与串的问题<br>Set Cover 集合覆盖<br>Set Data Structures 集合<br>Set Packing 集合配置<br>setter 设值函数<br>side effect 副作用<br>signature 签名<br>single-threaded 单线程<br>slider滑块<br>slot 槽<br>SMTP (Simple Mail Transfer Protocol) 简单邮件传输协议<br>snapshot 截屏图<br>snapshot 快照 (for database)<br>SOAP (simple object access protocol) 简单对象访问协议<br>software 软件<br>Sorting 排序<br>source code 源码、源代码<br>specialization 特化<br>specification 规范、规格<br>splitter 切分窗口<br>SQL (Structured Query Language) 结构化查询语言 (for database)<br>stack 栈、堆栈<br>standard library 标准库<br>standard template library 标准模板库<br>stateless 无状态的<br>statement 语句、声明<br>static cursor 静态游标 (for database)<br>static SQL statements 静态SQL语句 (for database)<br>status bar 状态条<br>stored procedure 存储过程 (for database)<br>stream 流<br>string 字符串<br>String Matching 模式匹配<br>stub 存根<br>subobject子对象<br>subquery 子查询 (for database)<br>subscript operator 下标操作符<br>support 支持<br>suspend 挂起<br>symbol 记号<br>syntax 语法<br>system databases 系统数据库 (for database)<br>system tables 系统表 (for database)</p><h2 id="T"><a href="#T" class="headerlink" title="T"></a>T</h2><hr><p>table 表 (for database)<br>table-level constraint 表级约束 (for database)<br>target 标的,目标<br>task switch 工作切换<br>TCP (Transport Control Protocol) 传输控制协议<br>template 模板<br>temporary object 临时对象<br>temporary table 临时表 (for database)<br>text 文本<br>Text Compression 压缩<br>text file 文本文件<br>thin client 瘦客户端<br>third-party 第三方<br>thread 线程<br>thread-safe 线程安全的<br>throw 抛出、引发(常指发出一个exception)<br>trace 跟踪<br>transaction 事务 (for database)<br>transaction log 事务日志 (for database)<br>transaction rollback 事务回滚 (for database)<br>traverse 遍历<br>trigger 触发器 (for database)<br>type 类型</p><h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><hr><p>UDDI(Universary Description, Discovery and Integration)统一描述、查询与集成<br>UML (unified modeling language)统一建模语言<br>unary function 单参函数<br>unary operator 一元操作符<br>unboxing 拆箱、拆箱转换<br>underflow 下限溢位(相对于overflow)<br>Unicode 统一字符编码标准，采用双字节对字符进行编码<br>Union query 联合查询 (for database)<br>UNIQUE constraints UNIQUE约束 (for database)<br>unique index 唯一索引 (for database)<br>unmanaged code 非受控代码、非托管代码<br>unmarshal 散集<br>unqualified 未经限定的、未经修饰的<br>URI (Uniform Resource identifier) 统一资源标识符<br>URL (Uniform Resource Locator) 统一资源定位器<br>user 用户<br>user interface 用户界面</p><h2 id="V"><a href="#V" class="headerlink" title="V"></a>V</h2><hr><p>value types 值类型<br>variable 变量<br>vector 向量(一种容器，有点类似array)<br>vendor 厂商<br>viable 可行的<br>video 视频<br>view 视图 (for database)<br>view 视图<br>virtual function 虚函数<br>virtual machine 虚拟机<br>virtual memory 虚拟内存</p><h2 id="W"><a href="#W" class="headerlink" title="W"></a>W</h2><hr><p>Web Services web服务<br>WHERE clause WHERE子句 (for database)<br>wildcard characters 通配符字符 (for database)<br>wildcard search 通配符搜索 (for database)<br>window 窗口<br>window function 窗口函数<br>window procedure 窗口过程<br>Windows authentication Windows身份验证<br>wizard 向导<br>word 单词<br>write enable 写启用 (for database)<br>write-only 只写<br>WSDL (Web Service Description Language)Web Service描述语言</p><h2 id="X"><a href="#X" class="headerlink" title="X"></a>X</h2><hr><p>XML (eXtensible Markup Language) 可扩展标记语言<br>XML Message Interface (XMI) XML消息接口<br>XSD (XML Schema Definition) XML模式定义语言<br>XSL (eXtensible Stylesheet Language) 可扩展样式表语言<br>XSLT (eXtensible Stylesheet Language Transformation)可扩展样式表语言转换<br>xxx based 基于xxx的<br>xxx oriented 面向xxx</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;A&quot;&gt;&lt;a href=&quot;#A&quot; class=&quot;headerlink&quot; title=&quot;A&quot;&gt;&lt;/a&gt;A&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;abstract 抽象的&lt;br&gt;abstract base class (ABC)抽象基类&lt;br&gt;abstract class 抽象类&lt;b
      
    
    </summary>
    
      <category term="English" scheme="http://yoursite.com/categories/English/"/>
    
    
      <category term="word" scheme="http://yoursite.com/tags/word/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/03/05/hello-world/"/>
    <id>http://yoursite.com/2018/03/05/hello-world/</id>
    <published>2018-03-05T11:26:39.000Z</published>
    <updated>2019-03-05T10:08:39.003Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="Multiple-hexo-personalization-settings"><a href="#Multiple-hexo-personalization-settings" class="headerlink" title="Multiple hexo personalization settings"></a>Multiple hexo personalization settings</h3><p>More info: <a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">settings</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
